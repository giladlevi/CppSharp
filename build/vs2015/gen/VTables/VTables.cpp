// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include "VTables.h"

using namespace System;
using namespace System::Runtime::InteropServices;

VTables::Foo::Vfoo::Vfoo(::Foo::Vfoo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

VTables::Foo::Vfoo^ VTables::Foo::Vfoo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::VTables::Foo::Vfoo((::Foo::Vfoo*) native.ToPointer());
}

VTables::Foo::Vfoo::~Vfoo()
{
    delete NativePtr;
}

VTables::Foo::Vfoo::Vfoo()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Foo::Vfoo();
}

VTables::Foo::Vfoo::Vfoo(VTables::Foo::Vfoo^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo::Vfoo*)_0->NativePtr;
    NativePtr = new ::Foo::Vfoo(__arg0);
}

System::IntPtr VTables::Foo::Vfoo::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void VTables::Foo::Vfoo::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Foo::Vfoo*)object.ToPointer();
}
VTables::Foo::Foo(::Foo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

VTables::Foo^ VTables::Foo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::VTables::Foo((::Foo*) native.ToPointer());
}

VTables::Foo::~Foo()
{
    delete NativePtr;
}

VTables::Foo::Foo()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Foo();
}

int VTables::Foo::Append()
{
    auto __ret = ((::Foo*)NativePtr)->append();
    return __ret;
}

int VTables::Foo::Append(int a)
{
    auto __ret = ((::Foo*)NativePtr)->append(a);
    return __ret;
}

int VTables::Foo::CallVirtualWithParameter(int a)
{
    auto __ret = ((::Foo*)NativePtr)->callVirtualWithParameter(a);
    return __ret;
}

VTables::Foo::Foo(VTables::Foo^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)_0->NativePtr;
    NativePtr = new ::Foo(__arg0);
}

int VTables::Foo::CallFoo()
{
    auto __arg0 = (::Foo*)NativePtr;
    auto __ret = ::FooCallFoo(__arg0);
    return __ret;
}

System::IntPtr VTables::Foo::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void VTables::Foo::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Foo*)object.ToPointer();
}

int VTables::Foo::vfoo::get()
{
    auto __ret = ((::Foo*)NativePtr)->vfoo();
    return __ret;
}

int VTables::Foo::Vbar::get()
{
    auto __ret = ((::Foo*)NativePtr)->vbar();
    return __ret;
}

VTables::BaseClassVirtual::BaseClassVirtual(::BaseClassVirtual* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

VTables::BaseClassVirtual^ VTables::BaseClassVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::VTables::BaseClassVirtual((::BaseClassVirtual*) native.ToPointer());
}

VTables::BaseClassVirtual::~BaseClassVirtual()
{
    delete NativePtr;
}

VTables::BaseClassVirtual::BaseClassVirtual()
{
    __ownsNativeInstance = true;
    NativePtr = new ::BaseClassVirtual();
}

VTables::BaseClassVirtual::BaseClassVirtual(VTables::BaseClassVirtual^ other)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(other, nullptr))
        throw gcnew ::System::ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::BaseClassVirtual*)other->NativePtr;
    NativePtr = new ::BaseClassVirtual(__arg0);
}

int VTables::BaseClassVirtual::VirtualCallRetInt(VTables::BaseClassVirtual^ base)
{
    auto __arg0 = (::BaseClassVirtual*)base->NativePtr;
    auto __ret = ::BaseClassVirtual::virtualCallRetInt(__arg0);
    return __ret;
}

int VTables::BaseClassVirtual::RetInt()
{
    auto __ret = ((::BaseClassVirtual*)NativePtr)->retInt();
    return __ret;
}

System::IntPtr VTables::BaseClassVirtual::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void VTables::BaseClassVirtual::__Instance::set(System::IntPtr object)
{
    NativePtr = (::BaseClassVirtual*)object.ToPointer();
}

VTables::BaseClassVirtual^ VTables::BaseClassVirtual::Base::get()
{
    auto __ret = ::BaseClassVirtual::getBase();
    auto ____ret = new ::BaseClassVirtual(__ret);
    return (____ret == nullptr) ? nullptr : gcnew VTables::BaseClassVirtual((::BaseClassVirtual*)____ret);
}

VTables::BaseClassVirtual^ VTables::BaseClassVirtual::BasePtr::get()
{
    auto __ret = ::BaseClassVirtual::getBasePtr();
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew VTables::BaseClassVirtual((::BaseClassVirtual*)__ret);
}

VTables::DerivedClassVirtual::DerivedClassVirtual(::DerivedClassVirtual* native)
    : VTables::BaseClassVirtual((::BaseClassVirtual*)native)
{
}

VTables::DerivedClassVirtual^ VTables::DerivedClassVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::VTables::DerivedClassVirtual((::DerivedClassVirtual*) native.ToPointer());
}

VTables::DerivedClassVirtual::~DerivedClassVirtual()
{
}

VTables::DerivedClassVirtual::DerivedClassVirtual()
    : VTables::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::DerivedClassVirtual();
}

int VTables::DerivedClassVirtual::RetInt()
{
    auto __ret = ((::DerivedClassVirtual*)NativePtr)->retInt();
    return __ret;
}

VTables::DerivedClassVirtual::DerivedClassVirtual(VTables::DerivedClassVirtual^ _0)
    : VTables::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DerivedClassVirtual*)_0->NativePtr;
    NativePtr = new ::DerivedClassVirtual(__arg0);
}

