// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace VTables
{
    public unsafe partial class Foo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Foo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?callVirtualWithParameter@Foo@@QAEHH@Z")]
            internal static extern int CallVirtualWithParameter_0(global::System.IntPtr instance, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FooCallFoo@@YAHPAVFoo@@@Z")]
            internal static extern int CallFoo_0(global::System.IntPtr instance);
        }

        public unsafe partial class Vfoo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Vfoo@Foo@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.Foo.Vfoo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.Foo.Vfoo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::VTables.Foo.Vfoo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Vfoo(native.ToPointer(), skipVTables);
            }

            internal static global::VTables.Foo.Vfoo __CreateInstance(global::VTables.Foo.Vfoo.__Internal native, bool skipVTables = false)
            {
                return new Vfoo(native, skipVTables);
            }

            private static void* __CopyValue(global::VTables.Foo.Vfoo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.Vfoo.__Internal));
                *(global::VTables.Foo.Vfoo.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Vfoo(global::VTables.Foo.Vfoo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Vfoo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Vfoo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.Vfoo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Vfoo(global::VTables.Foo.Vfoo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.Vfoo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::VTables.Foo.Vfoo.__Internal*) __Instance) = *((global::VTables.Foo.Vfoo.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::VTables.Foo.Vfoo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.Foo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.Foo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VTables.Foo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Foo(native.ToPointer(), skipVTables);
        }

        internal static global::VTables.Foo __CreateInstance(global::VTables.Foo.__Internal native, bool skipVTables = false)
        {
            return new Foo(native, skipVTables);
        }

        private static void* __CopyValue(global::VTables.Foo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.__Internal));
            global::VTables.Foo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Foo(global::VTables.Foo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Foo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Foo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "VTables.Foo");
        }

        public Foo(global::VTables.Foo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "VTables.Foo");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::VTables.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::VTables.Foo.__Internal*) __Instance)->vfptr_Foo = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual int Append()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
            var ___Append_0Delegate = (global::VTables.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::VTables.Delegates.Func_int_IntPtr));
            var __ret = ___Append_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public virtual int Append(int a)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___Append_1Delegate = (global::VTables.Delegates.Func_int_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::VTables.Delegates.Func_int_IntPtr_int));
            var __ret = ___Append_1Delegate((__Instance + __PointerAdjustment), a);
            return __ret;
        }

        public int CallVirtualWithParameter(int a)
        {
            var __ret = __Internal.CallVirtualWithParameter_0((__Instance + __PointerAdjustment), a);
            return __ret;
        }

        public int CallFoo()
        {
            var __ret = __Internal.CallFoo_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public virtual int vfoo
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___vfoo_0Delegate = (global::VTables.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::VTables.Delegates.Func_int_IntPtr));
                var __ret = ___vfoo_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public virtual int Vbar
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___Vbar_0Delegate = (global::VTables.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::VTables.Delegates.Func_int_IntPtr));
                var __ret = ___Vbar_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // int vfoo()
        private static global::VTables.Delegates.Func_int_IntPtr _vfoo_0DelegateInstance;

        private static int _vfoo_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.Foo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.vfoo;
            return __ret;
        }

        // int vbar()
        private static global::VTables.Delegates.Func_int_IntPtr _Vbar_0DelegateInstance;

        private static int _Vbar_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.Foo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Vbar;
            return __ret;
        }

        // int append(int a)
        private static global::VTables.Delegates.Func_int_IntPtr_int _Append_1DelegateInstance;

        private static int _Append_1DelegateHook(global::System.IntPtr instance, int a)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.Foo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Append(a);
            return __ret;
        }

        // int append()
        private static global::VTables.Delegates.Func_int_IntPtr _Append_0DelegateInstance;

        private static int _Append_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.Foo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Append();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[4];
                _vfoo_0DelegateInstance += _vfoo_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_vfoo_0DelegateInstance).ToPointer();
                _Vbar_0DelegateInstance += _Vbar_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Vbar_0DelegateInstance).ToPointer();
                _Append_1DelegateInstance += _Append_1DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Append_1DelegateInstance).ToPointer();
                _Append_0DelegateInstance += _Append_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_Append_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
                *(void**) (vfptr0 + 12) = _Thunks[3];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class BaseClassVirtual : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BaseClassVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BaseClassVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?virtualCallRetInt@BaseClassVirtual@@SAHPAV1@@Z")]
            internal static extern int VirtualCallRetInt_0(global::System.IntPtr @base);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getBase@BaseClassVirtual@@SA?AV1@XZ")]
            internal static extern void GetBase_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getBasePtr@BaseClassVirtual@@SAPAV1@XZ")]
            internal static extern global::System.IntPtr GetBasePtr_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.BaseClassVirtual> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::VTables.BaseClassVirtual>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::VTables.BaseClassVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new BaseClassVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::VTables.BaseClassVirtual __CreateInstance(global::VTables.BaseClassVirtual.__Internal native, bool skipVTables = false)
        {
            return new BaseClassVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::VTables.BaseClassVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VTables.BaseClassVirtual.__Internal));
            global::VTables.BaseClassVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private BaseClassVirtual(global::VTables.BaseClassVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BaseClassVirtual(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public BaseClassVirtual()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.BaseClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "VTables.BaseClassVirtual");
        }

        public BaseClassVirtual(global::VTables.BaseClassVirtual other)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.BaseClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "VTables.BaseClassVirtual");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::VTables.BaseClassVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::VTables.BaseClassVirtual.__Internal*) __Instance)->vfptr_BaseClassVirtual = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual int RetInt()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___RetInt_0Delegate = (global::VTables.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::VTables.Delegates.Func_int_IntPtr));
            var __ret = ___RetInt_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }

        public static int VirtualCallRetInt(global::VTables.BaseClassVirtual @base)
        {
            var __arg0 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
            var __ret = __Internal.VirtualCallRetInt_0(__arg0);
            return __ret;
        }

        public static global::VTables.BaseClassVirtual Base
        {
            get
            {
                var __ret = new global::VTables.BaseClassVirtual.__Internal();
                __Internal.GetBase_0(new IntPtr(&__ret));
                return global::VTables.BaseClassVirtual.__CreateInstance(__ret);
            }
        }

        public static global::VTables.BaseClassVirtual BasePtr
        {
            get
            {
                var __ret = __Internal.GetBasePtr_0();
                global::VTables.BaseClassVirtual __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::VTables.BaseClassVirtual.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::VTables.BaseClassVirtual) global::VTables.BaseClassVirtual.NativeToManagedMap[__ret];
                else __result0 = global::VTables.BaseClassVirtual.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // int retInt()
        private static global::VTables.Delegates.Func_int_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.BaseClassVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RetInt();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class DerivedClassVirtual : global::VTables.BaseClassVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("VTables.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::VTables.DerivedClassVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedClassVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::VTables.DerivedClassVirtual __CreateInstance(global::VTables.DerivedClassVirtual.__Internal native, bool skipVTables = false)
        {
            return new DerivedClassVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::VTables.DerivedClassVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::VTables.DerivedClassVirtual.__Internal));
            global::VTables.DerivedClassVirtual.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DerivedClassVirtual(global::VTables.DerivedClassVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivedClassVirtual(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public DerivedClassVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.DerivedClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "VTables.DerivedClassVirtual");
        }

        public DerivedClassVirtual(global::VTables.DerivedClassVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::VTables.DerivedClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "VTables.DerivedClassVirtual");
        }

        public override int RetInt()
        {
            return base.RetInt();
        }

        #region Virtual table interop

        // int retInt() override
        private static global::VTables.Delegates.Func_int_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::VTables.DerivedClassVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.RetInt();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr_int(global::System.IntPtr instance, int arg1);
    }
}
