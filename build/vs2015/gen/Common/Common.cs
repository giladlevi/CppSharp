// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CommonTest
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void DelegateInAnotherUnit();

    namespace DelegateNamespace
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void __AnonymousDelegate0();

        public unsafe partial class AnotherUnit
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?f4@DelegateNamespace@@YAXP6AXXZ@Z")]
                internal static extern void F4_0(global::System.IntPtr _0);
            }

            public static void F4(global::CommonTest.DelegateNamespace.__AnonymousDelegate0 _0)
            {
                var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
                __Internal.F4_0(__arg0);
            }
        }

        namespace Nested
        {
            [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            public unsafe delegate void __AnonymousDelegate0();

            public unsafe partial class AnotherUnit
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?f3@Nested@DelegateNamespace@@YAXP6AXXZ@Z")]
                    internal static extern void F3_0(global::System.IntPtr _0);
                }

                public static void F3(global::CommonTest.DelegateNamespace.Nested.__AnonymousDelegate0 _0)
                {
                    var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
                    __Internal.F3_0(__arg0);
                }
            }
        }
    }

    namespace AnotherUnit
    {
        public unsafe partial class AnotherUnit
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?f@AnotherUnit@@YAXXZ")]
                internal static extern void F_0();
            }

            public static void F()
            {
                __Internal.F_0();
            }
        }
    }

    public enum Enum
    {
        A = 0,
        B = 2,
        C = 5,
        E = 1,
        F = -9
    }

    public enum MyEnum
    {
        A = 0,
        B = 1,
        C = 2
    }

    public enum EmptyEnumsWithSameMemberPrefix
    {
        EmptyEnumsWithSameMemberPrefix1 = 0,
        EmptyEnumsWithSameMemberPrefix2 = 1
    }

    public enum EmptyEnumsWithSameMemberPrefix_
    {
        EmptyEnumsWithSameMemberPrefix3 = 0,
        EmptyEnumsWithSameMemberPrefix4 = 1
    }

    public enum EmptyEnumsWithSameMemberPrefixAndUnderscore
    {
        EmptyEnumsWithSameMemberPrefixAndUnderscore1 = 0,
        EmptyEnumsWithSameMemberPrefixAndUnderscore2 = 1
    }

    public enum EmptyEnumsWithSameMemberPrefixAndUnderscore_
    {
        EmptyEnumsWithSameMemberPrefixAndUnderscore_3 = 0,
        EmptyEnumsWithSameMemberPrefixAndUnderscore_4 = 1
    }

    public enum EmptyEnum
    {
    }

    public enum EnumWithUnderscores
    {
        lOWER_BEFORE_CAPITAL = 0,
        CAPITALS_More = 1,
        UnderscoreAtEnd = 2,
        UsesDigits1_0 = 3
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int DelegateInGlobalNamespace(int _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.StdCall)]
    public unsafe delegate int DelegateStdCall(int _0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int DelegateCDecl(int n);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void DelegateNullCheck();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void VoidPtrRetFunctionTypedef();

    namespace Base
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    namespace TemplateWithVirtual
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_TemplateWithVirtual;
        }
    }

    namespace SpecialisesVoid
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_SpecialisesVoid__I
        {
            [FieldOffset(0)]
            public int t;
        }

        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_SpecialisesVoid__L
        {
            [FieldOffset(0)]
            public int t;
        }

        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_SpecialisesVoid__i
        {
            [FieldOffset(0)]
            public uint t;
        }
    }

    namespace Aligned
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    public unsafe partial class IgnoredType
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int i;
        }

        public unsafe partial class IgnoredNested
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int i;
            }
        }
    }

    public unsafe partial class Foo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [FieldOffset(8)]
            internal global::CommonTest.IgnoredType.__Internal ignoredType;

            [FieldOffset(12)]
            public fixed int fixedArray[3];

            [FieldOffset(24)]
            public fixed sbyte fixedCharArray[3];

            [FieldOffset(28)]
            public global::System.IntPtr ptr;

            [FieldOffset(32)]
            public fixed float nested_array[4];

            [FieldOffset(48)]
            public global::System.IntPtr SomePointer;

            [FieldOffset(52)]
            public global::System.IntPtr SomePointerPointer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TakesTypedefedPtr@Foo@@QAEXPAV1@@Z")]
            internal static extern void TakesTypedefedPtr_0(global::System.IntPtr instance, global::System.IntPtr date);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TakesRef@Foo@@QAEHABV1@@Z")]
            internal static extern int TakesRef_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8Foo@@QBE_NABV0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetANSI@Foo@@QAEPBDXZ")]
            internal static extern global::System.IntPtr GetANSI_0(global::System.IntPtr instance);
        }

        internal enum Private
        {
            Value1 = 0,
            Value2 = 1
        }

        public enum RenamedEmptyEnum
        {
            EmptyEnum1 = 0,
            EmptyEnum2 = 1
        }

        public class FooPtr { }

        public unsafe abstract partial class NestedAbstract : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr_NestedAbstract;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedAbstract@Foo@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedAbstract@Foo@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Foo.NestedAbstract> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Foo.NestedAbstract>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CommonTest.Foo.NestedAbstract __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new NestedAbstractInternal(native.ToPointer(), skipVTables);
            }

            internal static global::CommonTest.Foo.NestedAbstract __CreateInstance(global::CommonTest.Foo.NestedAbstract.__Internal native, bool skipVTables = false)
            {
                return new NestedAbstractInternal(native, skipVTables);
            }

            protected NestedAbstract(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            protected NestedAbstract()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.NestedAbstract.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "CommonTest.Foo.NestedAbstract");
            }

            protected NestedAbstract(global::CommonTest.Foo.NestedAbstract _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.NestedAbstract.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "CommonTest.Foo.NestedAbstract");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CommonTest.Foo.NestedAbstract __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::CommonTest.Foo.NestedAbstract.__Internal*) __Instance)->vfptr_NestedAbstract = new global::System.IntPtr(__OriginalVTables[0]);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public abstract int* AbstractFunctionInNestedClass
            {
                get;
            }

            #region Virtual table interop

            // int* abstractFunctionInNestedClass() = 0
            private static global::CommonTest.Delegates.Func_intPtr_IntPtr _AbstractFunctionInNestedClass_0DelegateInstance;

            private static int* _AbstractFunctionInNestedClass_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::CommonTest.Foo.NestedAbstract) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                var __ret = __target.AbstractFunctionInNestedClass;
                return __ret;
            }

            private static void*[] __ManagedVTables;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (destructorOnly)
                    return;
                if (_Thunks == null)
                {
                    _Thunks = new void*[1];
                    _AbstractFunctionInNestedClass_0DelegateInstance += _AbstractFunctionInNestedClass_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AbstractFunctionInNestedClass_0DelegateInstance).ToPointer();
                }

                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }

            #endregion
        }

        public unsafe partial class NestedAbstractInternal : global::CommonTest.Foo.NestedAbstract, IDisposable
        {
            private static void* __CopyValue(global::CommonTest.Foo.NestedAbstract.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.NestedAbstract.__Internal));
                *(global::CommonTest.Foo.NestedAbstract.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal NestedAbstractInternal(global::CommonTest.Foo.NestedAbstract.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal NestedAbstractInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            public override int* AbstractFunctionInNestedClass
            {
                get
                {
                    var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                    var ___AbstractFunctionInNestedClass_0Delegate = (global::CommonTest.Delegates.Func_intPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_intPtr_IntPtr));
                    var __ret = ___AbstractFunctionInNestedClass_0Delegate((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Foo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Foo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.Foo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Foo(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Foo __CreateInstance(global::CommonTest.Foo.__Internal native, bool skipVTables = false)
        {
            return new Foo(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Foo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.__Internal));
            *(global::CommonTest.Foo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Foo(global::CommonTest.Foo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Foo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Foo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Foo(global::CommonTest.Foo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.Foo.__Internal*) __Instance) = *((global::CommonTest.Foo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void TakesTypedefedPtr(global::CommonTest.Foo date)
        {
            var __arg0 = ReferenceEquals(date, null) ? global::System.IntPtr.Zero : date.__Instance;
            __Internal.TakesTypedefedPtr_0((__Instance + __PointerAdjustment), __arg0);
        }

        public int TakesRef(global::CommonTest.Foo other)
        {
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            var __ret = __Internal.TakesRef_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static bool operator !=(global::CommonTest.Foo __op, global::CommonTest.Foo other)
        {
            return !(__op == other);
        }

        public static bool operator ==(global::CommonTest.Foo __op, global::CommonTest.Foo other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual_0(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as Foo;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::CommonTest.Foo.__Internal*) __Instance).GetHashCode();
        }

        public static int Unsafe
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?unsafe@Foo@@2HB");
                return *__ptr;
            }
        }

        public static string CharArray
        {
            get
            {
                var __ptr = CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?charArray@Foo@@2QBDB");
                return Marshal.PtrToStringAnsi(__ptr);
            }
        }

        public static int ReadWrite
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?readWrite@Foo@@2HA");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?readWrite@Foo@@2HA");
                *__ptr = value;
            }
        }

        public int A
        {
            get
            {
                return ((global::CommonTest.Foo.__Internal*) __Instance)->A;
            }

            set
            {
                ((global::CommonTest.Foo.__Internal*) __Instance)->A = value;
            }
        }

        public float B
        {
            get
            {
                return ((global::CommonTest.Foo.__Internal*) __Instance)->B;
            }

            set
            {
                ((global::CommonTest.Foo.__Internal*) __Instance)->B = value;
            }
        }

        public int[] FixedArray
        {
            get
            {
                int[] __value = null;
                if (((global::CommonTest.Foo.__Internal*) __Instance)->fixedArray != null)
                {
                    __value = new int[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::CommonTest.Foo.__Internal*) __Instance)->fixedArray[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::CommonTest.Foo.__Internal*) __Instance)->fixedArray[i] = value[i];
                }
            }
        }

        public char[] FixedCharArray
        {
            get
            {
                char[] __value = null;
                if (((global::CommonTest.Foo.__Internal*) __Instance)->fixedCharArray != null)
                {
                    __value = new char[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = global::System.Convert.ToChar(((global::CommonTest.Foo.__Internal*) __Instance)->fixedCharArray[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::CommonTest.Foo.__Internal*) __Instance)->fixedCharArray[i] = global::System.Convert.ToSByte(value[i]);
                }
            }
        }

        public global::System.IntPtr Ptr
        {
            get
            {
                return ((global::CommonTest.Foo.__Internal*) __Instance)->ptr;
            }

            set
            {
                ((global::CommonTest.Foo.__Internal*) __Instance)->ptr = (global::System.IntPtr) value;
            }
        }

        public int* SomePointer
        {
            get
            {
                return (int*) ((global::CommonTest.Foo.__Internal*) __Instance)->SomePointer;
            }

            set
            {
                ((global::CommonTest.Foo.__Internal*) __Instance)->SomePointer = (global::System.IntPtr) value;
            }
        }

        public int** SomePointerPointer
        {
            get
            {
                return (int**) ((global::CommonTest.Foo.__Internal*) __Instance)->SomePointerPointer;
            }

            set
            {
                ((global::CommonTest.Foo.__Internal*) __Instance)->SomePointerPointer = (global::System.IntPtr) value;
            }
        }

        public string ANSI
        {
            get
            {
                var __ret = __Internal.GetANSI_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringAnsi(__ret);
            }
        }
    }

    public unsafe partial struct Bar
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [FieldOffset(8)]
            public fixed int fixedEnumArray[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@VFoo@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::CommonTest.Foo.__Internal foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RetItem1@Bar@@QBE?AW4Item@1@XZ")]
            internal static extern global::CommonTest.Bar.Item RetItem1_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?returnPointerToValueType@Bar@@QAEPAU1@XZ")]
            internal static extern global::System.IntPtr ReturnPointerToValueType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8Bar@@QBE_NABU0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr arg1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8@YA_NW4Item@Bar@@ABU1@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_1(global::CommonTest.Bar.Item item, global::System.IntPtr bar);
        }

        public enum Item
        {
            Item1 = 0,
            Item2 = 1
        }

        private Bar.__Internal __instance;
        internal Bar.__Internal __Instance { get { return __instance; } }

        internal static global::CommonTest.Bar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Bar(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Bar __CreateInstance(global::CommonTest.Bar.__Internal native, bool skipVTables = false)
        {
            return new Bar(native, skipVTables);
        }

        private Bar(global::CommonTest.Bar.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Bar(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CommonTest.Bar.__Internal*) native;
        }

        public Bar(global::CommonTest.Foo foo)
            : this()
        {
            var __arg0 = ReferenceEquals(foo, null) ? new global::CommonTest.Foo.__Internal() : *(global::CommonTest.Foo.__Internal*) foo.__Instance;
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public Bar(global::CommonTest.Bar _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_3(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public global::CommonTest.Bar.Item RetItem1()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var __ret = __Internal.RetItem1_0(new global::System.IntPtr(__instancePtr));
                return __ret;
            }
        }

        public global::CommonTest.Bar ReturnPointerToValueType()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var __ret = __Internal.ReturnPointerToValueType_0(new global::System.IntPtr(__instancePtr));
                global::CommonTest.Bar __result0;
                if (__ret == IntPtr.Zero) __result0 = new global::CommonTest.Bar();
                else __result0 = global::CommonTest.Bar.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static bool operator !=(global::CommonTest.Bar __op, global::CommonTest.Bar arg1)
        {
            return !(__op == arg1);
        }

        public static bool operator ==(global::CommonTest.Bar __op, global::CommonTest.Bar arg1)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool arg1Null = ReferenceEquals(arg1, null);
            if (__opNull || arg1Null)
                return __opNull && arg1Null;
            var ____arg0 = __op.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var ____arg1 = arg1.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __instancePtr = &__op.__instance;
            var __ret = __Internal.OperatorEqualEqual_0(new global::System.IntPtr(__instancePtr), __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            if (!(obj is Bar)) return false;
            return this == (Bar) obj;
        }

        public override int GetHashCode()
        {
            return __Instance.GetHashCode();
        }

        public static bool operator !=(global::CommonTest.Bar.Item item, global::CommonTest.Bar bar)
        {
            return !(item == bar);
        }

        public static implicit operator global::CommonTest.Bar(global::CommonTest.Foo foo)
        {
            return new global::CommonTest.Bar(foo);
        }

        public static bool operator ==(global::CommonTest.Bar.Item item, global::CommonTest.Bar bar)
        {
            bool itemNull = ReferenceEquals(item, null);
            bool barNull = ReferenceEquals(bar, null);
            if (itemNull || barNull)
                return itemNull && barNull;
            var ____arg1 = bar.__Instance;
            var __arg1 = new global::System.IntPtr(&____arg1);
            var __ret = __Internal.OperatorEqualEqual_1(item, __arg1);
            return __ret;
        }

        public int A
        {
            get
            {
                return __instance.A;
            }

            set
            {
                __instance.A = value;
            }
        }

        public float B
        {
            get
            {
                return __instance.B;
            }

            set
            {
                __instance.B = value;
            }
        }
    }

    public unsafe partial class Foo2 : global::CommonTest.Foo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 84)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [FieldOffset(8)]
            internal global::CommonTest.IgnoredType.__Internal ignoredType;

            [FieldOffset(12)]
            public fixed int fixedArray[3];

            [FieldOffset(24)]
            public fixed sbyte fixedCharArray[3];

            [FieldOffset(28)]
            public global::System.IntPtr ptr;

            [FieldOffset(32)]
            public fixed float nested_array[4];

            [FieldOffset(48)]
            public global::System.IntPtr SomePointer;

            [FieldOffset(52)]
            public global::System.IntPtr SomePointerPointer;

            [FieldOffset(56)]
            public global::System.IntPtr copy;

            [FieldOffset(60)]
            public int C;

            [FieldOffset(64)]
            public global::CommonTest.Bar.__Internal valueTypeField;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo2@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo2@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??6Foo2@@QAE?AV0@H@Z")]
            internal static extern void OperatorLessLess_0(global::System.IntPtr instance, global::System.IntPtr @return, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?testCharMarshalling@Foo2@@QAEDD@Z")]
            internal static extern sbyte TestCharMarshalling_0(global::System.IntPtr instance, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?testKeywordParam@Foo2@@QAEXPAXW4Item@Bar@@H@Z")]
            internal static extern void TestKeywordParam_0(global::System.IntPtr instance, global::System.IntPtr @where, global::CommonTest.Bar.Item @event, int @ref);
        }

        public unsafe partial class Copy
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::CommonTest.Foo.__Internal A;
            }
        }

        internal static new global::CommonTest.Foo2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Foo2(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Foo2 __CreateInstance(global::CommonTest.Foo2.__Internal native, bool skipVTables = false)
        {
            return new Foo2(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Foo2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo2.__Internal));
            *(global::CommonTest.Foo2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Foo2(global::CommonTest.Foo2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Foo2(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Foo2()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Foo2(global::CommonTest.Foo2 _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Foo2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.Foo2.__Internal*) __Instance) = *((global::CommonTest.Foo2.__Internal*) _0.__Instance);
        }

        public static global::CommonTest.Foo2 operator <<(global::CommonTest.Foo2 __op, int i)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::CommonTest.Foo2.__Internal();
            __Internal.OperatorLessLess_0(__arg0, new IntPtr(&__ret), i);
            return global::CommonTest.Foo2.__CreateInstance(__ret);
        }

        public char TestCharMarshalling(char c)
        {
            var __arg0 = global::System.Convert.ToSByte(c);
            var __ret = __Internal.TestCharMarshalling_0((__Instance + __PointerAdjustment), __arg0);
            return global::System.Convert.ToChar(__ret);
        }

        public void TestKeywordParam(global::System.IntPtr @where, global::CommonTest.Bar.Item @event, int @ref)
        {
            __Internal.TestKeywordParam_0((__Instance + __PointerAdjustment), @where, @event, @ref);
        }

        public int C
        {
            get
            {
                return ((global::CommonTest.Foo2.__Internal*) __Instance)->C;
            }

            set
            {
                ((global::CommonTest.Foo2.__Internal*) __Instance)->C = value;
            }
        }

        public global::CommonTest.Bar ValueTypeField
        {
            get
            {
                return global::CommonTest.Bar.__CreateInstance(((global::CommonTest.Foo2.__Internal*) __Instance)->valueTypeField);
            }

            set
            {
                ((global::CommonTest.Foo2.__Internal*) __Instance)->valueTypeField = value.__Instance;
            }
        }
    }

    public unsafe partial struct Bar2
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [FieldOffset(8)]
            public fixed int fixedEnumArray[3];

            [FieldOffset(20)]
            public int C;

            [FieldOffset(24)]
            public global::System.IntPtr pointerToStruct;

            [FieldOffset(28)]
            public global::System.IntPtr pointerToPrimitive;

            [FieldOffset(32)]
            public global::System.IntPtr pointerToClass;

            [FieldOffset(36)]
            public global::CommonTest.Bar.__Internal valueStruct;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RetItem1@Bar@@QBE?AW4Item@1@XZ")]
            internal static extern global::CommonTest.Bar.Item RetItem1_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?returnPointerToValueType@Bar@@QAEPAU1@XZ")]
            internal static extern global::System.IntPtr ReturnPointerToValueType_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8Bar@@QBE_NABU0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr arg1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??8@YA_NW4Item@Bar@@ABU1@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_1(global::CommonTest.Bar.Item item, global::System.IntPtr bar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar2@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar2@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??BBar2@@QBEHXZ")]
            internal static extern int OperatorConversion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??BBar2@@QAE?AVFoo2@@XZ")]
            internal static extern void OperatorConversion_1(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?needFixedInstance@Bar2@@QBE?AVFoo2@@XZ")]
            internal static extern void NeedFixedInstance_0(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public unsafe partial class Nested : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0Nested@Bar2@@QAE@ABU01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??BNested@Bar2@@QBEHXZ")]
                internal static extern int OperatorConversion_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Bar2.Nested> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Bar2.Nested>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CommonTest.Bar2.Nested __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new Nested(native.ToPointer(), skipVTables);
            }

            internal static global::CommonTest.Bar2.Nested __CreateInstance(global::CommonTest.Bar2.Nested.__Internal native, bool skipVTables = false)
            {
                return new Nested(native, skipVTables);
            }

            private static void* __CopyValue(global::CommonTest.Bar2.Nested.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Bar2.Nested.__Internal));
                *(global::CommonTest.Bar2.Nested.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Nested(global::CommonTest.Bar2.Nested.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Nested(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public Nested()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Bar2.Nested.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Nested(global::CommonTest.Bar2.Nested _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Bar2.Nested.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CommonTest.Bar2.Nested.__Internal*) __Instance) = *((global::CommonTest.Bar2.Nested.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CommonTest.Bar2.Nested __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static implicit operator int(global::CommonTest.Bar2.Nested __op)
            {
                if (ReferenceEquals(__op, null))
                    throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = __op.__Instance;
                var __ret = __Internal.OperatorConversion_0(__arg0);
                return __ret;
            }
        }

        private Bar2.__Internal __instance;
        internal Bar2.__Internal __Instance { get { return __instance; } }

        internal static global::CommonTest.Bar2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Bar2(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Bar2 __CreateInstance(global::CommonTest.Bar2.__Internal native, bool skipVTables = false)
        {
            return new Bar2(native, skipVTables);
        }

        private Bar2(global::CommonTest.Bar2.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Bar2(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CommonTest.Bar2.__Internal*) native;
        }

        public Bar2(global::CommonTest.Bar2 _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public global::CommonTest.Bar.Item RetItem1()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var __ret = __Internal.RetItem1_0(new global::System.IntPtr(__instancePtr));
                return __ret;
            }
        }

        public global::CommonTest.Bar ReturnPointerToValueType()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                var __ret = __Internal.ReturnPointerToValueType_0(new global::System.IntPtr(__instancePtr));
                global::CommonTest.Bar __result0;
                if (__ret == IntPtr.Zero) __result0 = new global::CommonTest.Bar();
                else __result0 = global::CommonTest.Bar.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static implicit operator int(global::CommonTest.Bar2 __op)
        {
            var ____arg0 = __op.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __instancePtr = &__op.__instance;
            var __ret = __Internal.OperatorConversion_0(new global::System.IntPtr(__instancePtr));
            return __ret;
        }

        public static implicit operator global::CommonTest.Foo2(global::CommonTest.Bar2 __op)
        {
            var ____arg0 = __op.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __ret = new global::CommonTest.Foo2.__Internal();
            var __instancePtr = &__op.__instance;
            __Internal.OperatorConversion_1(new global::System.IntPtr(__instancePtr), new IntPtr(&__ret));
            return global::CommonTest.Foo2.__CreateInstance(__ret);
        }

        public int A
        {
            get
            {
                return __instance.A;
            }

            set
            {
                __instance.A = value;
            }
        }

        public float B
        {
            get
            {
                return __instance.B;
            }

            set
            {
                __instance.B = value;
            }
        }

        public int C
        {
            get
            {
                return __instance.C;
            }

            set
            {
                __instance.C = value;
            }
        }

        public global::CommonTest.Bar PointerToStruct;

        public int* PointerToPrimitive
        {
            get
            {
                return (int*) __instance.pointerToPrimitive;
            }

            set
            {
                __instance.pointerToPrimitive = (global::System.IntPtr) value;
            }
        }

        public global::CommonTest.Foo2 PointerToClass
        {
            get
            {
                global::CommonTest.Foo2 __result0;
                if (__instance.pointerToClass == IntPtr.Zero) __result0 = null;
                else if (global::CommonTest.Foo2.NativeToManagedMap.ContainsKey(__instance.pointerToClass))
                    __result0 = (global::CommonTest.Foo2) global::CommonTest.Foo2.NativeToManagedMap[__instance.pointerToClass];
                else __result0 = global::CommonTest.Foo2.__CreateInstance(__instance.pointerToClass);
                return __result0;
            }

            set
            {
                __instance.pointerToClass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::CommonTest.Bar ValueStruct;

        public global::CommonTest.Foo2 NeedFixedInstance
        {
            get
            {
                var __ret = new global::CommonTest.Foo2.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.NeedFixedInstance_0(new global::System.IntPtr(__instancePtr), new IntPtr(&__ret));
                    return global::CommonTest.Foo2.__CreateInstance(__ret);
                }
            }
        }
    }

    public unsafe partial class Hello : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Hello@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Hello@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr hello);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?PrintHello@Hello@@QAEXPBD@Z")]
            internal static extern void PrintHello_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?test1@Hello@@QAE_NHM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Test1_0(global::System.IntPtr instance, int i, float f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?add@Hello@@QAEHHH@Z")]
            internal static extern int Add_0(global::System.IntPtr instance, int a, int b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddFoo@Hello@@QAEHVFoo@@@Z")]
            internal static extern int AddFoo_0(global::System.IntPtr instance, global::CommonTest.Foo.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddFooRef@Hello@@QAEHAAVFoo@@@Z")]
            internal static extern int AddFooRef_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddFooPtr@Hello@@QAEHPAVFoo@@@Z")]
            internal static extern int AddFooPtr_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddFooPtrRef@Hello@@QAEHAAPAVFoo@@@Z")]
            internal static extern int AddFooPtrRef_0(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RetFoo@Hello@@QAE?AVFoo@@HM@Z")]
            internal static extern void RetFoo_0(global::System.IntPtr instance, global::System.IntPtr @return, int a, float b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddFoo2@Hello@@QAEHVFoo2@@@Z")]
            internal static extern int AddFoo2_0(global::System.IntPtr instance, global::CommonTest.Foo2.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddBar@Hello@@QAEHUBar@@@Z")]
            internal static extern int AddBar_0(global::System.IntPtr instance, global::CommonTest.Bar.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?AddBar2@Hello@@QAEHUBar2@@@Z")]
            internal static extern int AddBar2_0(global::System.IntPtr instance, global::CommonTest.Bar2.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RetEnum@Hello@@QAEHW4Enum@@@Z")]
            internal static extern int RetEnum_0(global::System.IntPtr instance, global::CommonTest.Enum _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?RetNull@Hello@@QAEPAV1@XZ")]
            internal static extern global::System.IntPtr RetNull_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestPrimitiveOut@Hello@@QAE_NPAM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TestPrimitiveOut_0(global::System.IntPtr instance, float* f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestPrimitiveOutRef@Hello@@QAE_NAAM@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TestPrimitiveOutRef_0(global::System.IntPtr instance, float* f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestPrimitiveInOut@Hello@@QAE_NPAH@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TestPrimitiveInOut_0(global::System.IntPtr instance, int* i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestPrimitiveInOutRef@Hello@@QAE_NAAH@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TestPrimitiveInOutRef_0(global::System.IntPtr instance, int* i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnumOut@Hello@@QAEXHPAW4Enum@@@Z")]
            internal static extern void EnumOut_0(global::System.IntPtr instance, int value, global::CommonTest.Enum* e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnumOutRef@Hello@@QAEXHAAW4Enum@@@Z")]
            internal static extern void EnumOutRef_0(global::System.IntPtr instance, int value, global::CommonTest.Enum* e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnumInOut@Hello@@QAEXPAW4Enum@@@Z")]
            internal static extern void EnumInOut_0(global::System.IntPtr instance, global::CommonTest.Enum* e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?EnumInOutRef@Hello@@QAEXAAW4Enum@@@Z")]
            internal static extern void EnumInOutRef_0(global::System.IntPtr instance, global::CommonTest.Enum* e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StringOut@Hello@@QAEXPAPBD@Z")]
            internal static extern void StringOut_0(global::System.IntPtr instance, global::System.IntPtr* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StringOutRef@Hello@@QAEXAAPBD@Z")]
            internal static extern void StringOutRef_0(global::System.IntPtr instance, global::System.IntPtr* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StringInOut@Hello@@QAEXPAPBD@Z")]
            internal static extern void StringInOut_0(global::System.IntPtr instance, global::System.IntPtr* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StringInOutRef@Hello@@QAEXAAPBD@Z")]
            internal static extern void StringInOutRef_0(global::System.IntPtr instance, global::System.IntPtr* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StringTypedef@Hello@@QAEXPBD@Z")]
            internal static extern void StringTypedef_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string str);
        }

        public unsafe partial struct NestedPrivate
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int i;

                [FieldOffset(0)]
                public float f;
            }
        }

        public unsafe partial struct NestedPublic
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int j;

                [FieldOffset(0)]
                public float g;

                [FieldOffset(0)]
                public int l;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedPublic@Hello@@QAE@ABT01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private NestedPublic.__Internal __instance;
            internal NestedPublic.__Internal __Instance { get { return __instance; } }

            internal static global::CommonTest.Hello.NestedPublic __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new NestedPublic(native.ToPointer(), skipVTables);
            }

            internal static global::CommonTest.Hello.NestedPublic __CreateInstance(global::CommonTest.Hello.NestedPublic.__Internal native, bool skipVTables = false)
            {
                return new NestedPublic(native, skipVTables);
            }

            private NestedPublic(global::CommonTest.Hello.NestedPublic.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private NestedPublic(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::CommonTest.Hello.NestedPublic.__Internal*) native;
            }

            public NestedPublic(global::CommonTest.Hello.NestedPublic _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public int J
            {
                get
                {
                    return __instance.j;
                }

                set
                {
                    __instance.j = value;
                }
            }

            public float G
            {
                get
                {
                    return __instance.g;
                }

                set
                {
                    __instance.g = value;
                }
            }

            public int L
            {
                get
                {
                    return __instance.l;
                }

                set
                {
                    __instance.l = value;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Hello> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Hello>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.Hello __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Hello(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Hello __CreateInstance(global::CommonTest.Hello.__Internal native, bool skipVTables = false)
        {
            return new Hello(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Hello.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Hello.__Internal));
            global::CommonTest.Hello.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Hello(global::CommonTest.Hello.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Hello(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Hello()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Hello.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Hello(global::CommonTest.Hello hello)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Hello.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(hello, null))
                throw new global::System.ArgumentNullException("hello", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = hello.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.Hello __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void PrintHello(string s)
        {
            __Internal.PrintHello_0((__Instance + __PointerAdjustment), s);
        }

        public bool Test1(int i, float f)
        {
            var __ret = __Internal.Test1_0((__Instance + __PointerAdjustment), i, f);
            return __ret;
        }

        public int Add(int a, int b)
        {
            var __ret = __Internal.Add_0((__Instance + __PointerAdjustment), a, b);
            return __ret;
        }

        public int AddFoo(global::CommonTest.Foo _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? new global::CommonTest.Foo.__Internal() : *(global::CommonTest.Foo.__Internal*) _0.__Instance;
            var __ret = __Internal.AddFoo_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int AddFooRef(global::CommonTest.Foo _0)
        {
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            var __ret = __Internal.AddFooRef_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int AddFooPtr(global::CommonTest.Foo _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.AddFooPtr_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int AddFooPtrRef(global::CommonTest.Foo _0)
        {
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            var __ret = __Internal.AddFooPtrRef_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public global::CommonTest.Foo RetFoo(int a, float b)
        {
            var __ret = new global::CommonTest.Foo.__Internal();
            __Internal.RetFoo_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), a, b);
            return global::CommonTest.Foo.__CreateInstance(__ret);
        }

        public int AddFoo2(global::CommonTest.Foo2 _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? new global::CommonTest.Foo2.__Internal() : *(global::CommonTest.Foo2.__Internal*) _0.__Instance;
            var __ret = __Internal.AddFoo2_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int AddBar(global::CommonTest.Bar _0)
        {
            var __arg0 = _0.__Instance;
            var __ret = __Internal.AddBar_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int AddBar2(global::CommonTest.Bar2 _0)
        {
            var __arg0 = _0.__Instance;
            var __ret = __Internal.AddBar2_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int RetEnum(global::CommonTest.Enum _0)
        {
            var __ret = __Internal.RetEnum_0((__Instance + __PointerAdjustment), _0);
            return __ret;
        }

        public global::CommonTest.Hello RetNull()
        {
            var __ret = __Internal.RetNull_0((__Instance + __PointerAdjustment));
            global::CommonTest.Hello __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Hello.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CommonTest.Hello) global::CommonTest.Hello.NativeToManagedMap[__ret];
            else __result0 = global::CommonTest.Hello.__CreateInstance(__ret);
            return __result0;
        }

        public bool TestPrimitiveOut(out float f)
        {
            fixed (float* __refParamPtr0 = &f)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.TestPrimitiveOut_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public bool TestPrimitiveOutRef(out float f)
        {
            fixed (float* __refParamPtr0 = &f)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.TestPrimitiveOutRef_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public bool TestPrimitiveInOut(ref int i)
        {
            fixed (int* __refParamPtr0 = &i)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.TestPrimitiveInOut_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public bool TestPrimitiveInOutRef(ref int i)
        {
            fixed (int* __refParamPtr0 = &i)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.TestPrimitiveInOutRef_0((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public void EnumOut(int value, out global::CommonTest.Enum e)
        {
            global::CommonTest.Enum _e;
            var __arg1 = &_e;
            __Internal.EnumOut_0((__Instance + __PointerAdjustment), value, __arg1);
            e = _e;
        }

        public void EnumOutRef(int value, out global::CommonTest.Enum e)
        {
            global::CommonTest.Enum _e;
            var __arg1 = &_e;
            __Internal.EnumOutRef_0((__Instance + __PointerAdjustment), value, __arg1);
            e = _e;
        }

        public void EnumInOut(ref global::CommonTest.Enum e)
        {
            global::CommonTest.Enum _e = e;
            var __arg0 = &_e;
            __Internal.EnumInOut_0((__Instance + __PointerAdjustment), __arg0);
            e = _e;
        }

        public void EnumInOutRef(ref global::CommonTest.Enum e)
        {
            global::CommonTest.Enum _e = e;
            var __arg0 = &_e;
            __Internal.EnumInOutRef_0((__Instance + __PointerAdjustment), __arg0);
            e = _e;
        }

        public void StringOut(out string str)
        {
            var __arg0 = IntPtr.Zero;
            __Internal.StringOut_0((__Instance + __PointerAdjustment), &__arg0);
            str = Marshal.PtrToStringAnsi(__arg0);
        }

        public void StringOutRef(out string str)
        {
            var __arg0 = IntPtr.Zero;
            __Internal.StringOutRef_0((__Instance + __PointerAdjustment), &__arg0);
            str = Marshal.PtrToStringAnsi(__arg0);
        }

        public void StringInOut(ref string str)
        {
            var __arg0 = Marshal.StringToHGlobalAnsi(str);
            __Internal.StringInOut_0((__Instance + __PointerAdjustment), &__arg0);
            str = Marshal.PtrToStringAnsi(__arg0);
        }

        public void StringInOutRef(ref string str)
        {
            var __arg0 = Marshal.StringToHGlobalAnsi(str);
            __Internal.StringInOutRef_0((__Instance + __PointerAdjustment), &__arg0);
            str = Marshal.PtrToStringAnsi(__arg0);
        }

        public void StringTypedef(string str)
        {
            __Internal.StringTypedef_0((__Instance + __PointerAdjustment), str);
        }
    }

    public unsafe abstract partial class AbstractFoo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractFoo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractFoo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractFoo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.AbstractFoo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.AbstractFoo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.AbstractFoo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractFooInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.AbstractFoo __CreateInstance(global::CommonTest.AbstractFoo.__Internal native, bool skipVTables = false)
        {
            return new AbstractFooInternal(native, skipVTables);
        }

        protected AbstractFoo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected AbstractFoo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.AbstractFoo");
        }

        protected AbstractFoo(global::CommonTest.AbstractFoo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.AbstractFoo");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.AbstractFoo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.AbstractFoo.__Internal*) __Instance)->vfptr_AbstractFoo = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract int PureFunction(int i = 0);

        public abstract int PureFunction2(ref bool ok);

        public abstract int PureFunction2();

        public abstract int PureFunction1
        {
            get;
        }

        #region Virtual table interop

        // int pureFunction(int i = 0) = 0
        private static global::CommonTest.Delegates.Func_int_IntPtr_int _PureFunction_0DelegateInstance;

        private static int _PureFunction_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.AbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction(i);
            return __ret;
        }

        // int pureFunction1() = 0
        private static global::CommonTest.Delegates.Func_int_IntPtr _PureFunction1_0DelegateInstance;

        private static int _PureFunction1_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.AbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction1;
            return __ret;
        }

        // int pureFunction2(bool* ok = 0) = 0
        private static global::CommonTest.Delegates.Func_int_IntPtr_boolPtr _PureFunction2_0DelegateInstance;

        private static int _PureFunction2_0DelegateHook(global::System.IntPtr instance, bool* ok)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.AbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction2(ref *ok);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _PureFunction_0DelegateInstance += _PureFunction_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PureFunction_0DelegateInstance).ToPointer();
                _PureFunction1_0DelegateInstance += _PureFunction1_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PureFunction1_0DelegateInstance).ToPointer();
                _PureFunction2_0DelegateInstance += _PureFunction2_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_PureFunction2_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ImplementsAbstractFoo : global::CommonTest.AbstractFoo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractFoo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ImplementsAbstractFoo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ImplementsAbstractFoo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.ImplementsAbstractFoo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ImplementsAbstractFoo(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ImplementsAbstractFoo __CreateInstance(global::CommonTest.ImplementsAbstractFoo.__Internal native, bool skipVTables = false)
        {
            return new ImplementsAbstractFoo(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ImplementsAbstractFoo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ImplementsAbstractFoo.__Internal));
            global::CommonTest.ImplementsAbstractFoo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ImplementsAbstractFoo(global::CommonTest.ImplementsAbstractFoo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImplementsAbstractFoo(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ImplementsAbstractFoo()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ImplementsAbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.ImplementsAbstractFoo");
        }

        public ImplementsAbstractFoo(global::CommonTest.ImplementsAbstractFoo _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ImplementsAbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.ImplementsAbstractFoo");
        }

        public override int PureFunction(int i = 0)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___PureFunction_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_int));
            var __ret = ___PureFunction_0Delegate((__Instance + __PointerAdjustment), i);
            return __ret;
        }

        public override int PureFunction2(ref bool ok)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___PureFunction2_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_boolPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_boolPtr));
            fixed (bool* __refParamPtr0 = &ok)
            {
                var __arg0 = __refParamPtr0;
                var __ret = ___PureFunction2_0Delegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public override int PureFunction2()
        {
            bool param0 = false;
            return PureFunction2(ref param0);
        }

        public override int PureFunction1
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___PureFunction1_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr));
                var __ret = ___PureFunction1_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // int pureFunction(typedefInOverride i = 0)
        private static global::CommonTest.Delegates.Func_int_IntPtr_int _PureFunction_0DelegateInstance;

        private static int _PureFunction_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.ImplementsAbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction(i);
            return __ret;
        }

        // int pureFunction1()
        private static global::CommonTest.Delegates.Func_int_IntPtr _PureFunction1_0DelegateInstance;

        private static int _PureFunction1_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.ImplementsAbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction1;
            return __ret;
        }

        // int pureFunction2(bool* ok = 0)
        private static global::CommonTest.Delegates.Func_int_IntPtr_boolPtr _PureFunction2_0DelegateInstance;

        private static int _PureFunction2_0DelegateHook(global::System.IntPtr instance, bool* ok)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.ImplementsAbstractFoo) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.PureFunction2(ref *ok);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _PureFunction_0DelegateInstance += _PureFunction_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PureFunction_0DelegateInstance).ToPointer();
                _PureFunction1_0DelegateInstance += _PureFunction1_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PureFunction1_0DelegateInstance).ToPointer();
                _PureFunction2_0DelegateInstance += _PureFunction2_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_PureFunction2_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ReturnsAbstractFoo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::CommonTest.ImplementsAbstractFoo.__Internal i;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ReturnsAbstractFoo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ReturnsAbstractFoo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getFoo@ReturnsAbstractFoo@@QAEABVAbstractFoo@@XZ")]
            internal static extern global::System.IntPtr GetFoo_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ReturnsAbstractFoo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ReturnsAbstractFoo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ReturnsAbstractFoo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ReturnsAbstractFoo(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ReturnsAbstractFoo __CreateInstance(global::CommonTest.ReturnsAbstractFoo.__Internal native, bool skipVTables = false)
        {
            return new ReturnsAbstractFoo(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ReturnsAbstractFoo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsAbstractFoo.__Internal));
            global::CommonTest.ReturnsAbstractFoo.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ReturnsAbstractFoo(global::CommonTest.ReturnsAbstractFoo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ReturnsAbstractFoo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ReturnsAbstractFoo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsAbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public ReturnsAbstractFoo(global::CommonTest.ReturnsAbstractFoo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsAbstractFoo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ReturnsAbstractFoo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CommonTest.AbstractFoo Foo
        {
            get
            {
                var __ret = __Internal.GetFoo_0((__Instance + __PointerAdjustment));
                global::CommonTest.AbstractFoo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CommonTest.AbstractFoo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CommonTest.AbstractFoo) global::CommonTest.AbstractFoo.NativeToManagedMap[__ret];
                else __result0 = global::CommonTest.AbstractFoo.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public unsafe abstract partial class Exception : global::CommonTest.Foo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 60)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Exception;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public float B;

            [FieldOffset(12)]
            internal global::CommonTest.IgnoredType.__Internal ignoredType;

            [FieldOffset(16)]
            public fixed int fixedArray[3];

            [FieldOffset(28)]
            public fixed sbyte fixedCharArray[3];

            [FieldOffset(32)]
            public global::System.IntPtr ptr;

            [FieldOffset(36)]
            public fixed float nested_array[4];

            [FieldOffset(52)]
            public global::System.IntPtr SomePointer;

            [FieldOffset(56)]
            public global::System.IntPtr SomePointerPointer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Exception@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Exception@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.Exception __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ExceptionInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Exception __CreateInstance(global::CommonTest.Exception.__Internal native, bool skipVTables = false)
        {
            return new ExceptionInternal(native, skipVTables);
        }

        protected Exception(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected Exception()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Exception.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CommonTest.Exception");
        }

        protected Exception(global::CommonTest.Exception _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Exception.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.Exception");
        }

        public override void Dispose(bool disposing)
        {
            global::CommonTest.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.Exception.__Internal*) __Instance)->vfptr_Exception = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract global::CommonTest.Exception Clone();

        #region Virtual table interop

        // Ex1* clone() = 0
        private static global::CommonTest.Delegates.Func_IntPtr_IntPtr _Clone_0DelegateInstance;

        private static global::System.IntPtr _Clone_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.Exception) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Clone();
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Clone_0DelegateInstance += _Clone_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Clone_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class DerivedException : global::CommonTest.Exception, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 60)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Exception;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public float B;

            [FieldOffset(12)]
            internal global::CommonTest.IgnoredType.__Internal ignoredType;

            [FieldOffset(16)]
            public fixed int fixedArray[3];

            [FieldOffset(28)]
            public fixed sbyte fixedCharArray[3];

            [FieldOffset(32)]
            public global::System.IntPtr ptr;

            [FieldOffset(36)]
            public fixed float nested_array[4];

            [FieldOffset(52)]
            public global::System.IntPtr SomePointer;

            [FieldOffset(56)]
            public global::System.IntPtr SomePointerPointer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedException@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedException@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.DerivedException __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedException(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DerivedException __CreateInstance(global::CommonTest.DerivedException.__Internal native, bool skipVTables = false)
        {
            return new DerivedException(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DerivedException.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedException.__Internal));
            global::CommonTest.DerivedException.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DerivedException(global::CommonTest.DerivedException.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivedException(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public DerivedException()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedException.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.DerivedException");
        }

        public DerivedException(global::CommonTest.DerivedException _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedException.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.DerivedException");
        }

        public override global::CommonTest.Exception Clone()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___Clone_0Delegate = (global::CommonTest.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_IntPtr_IntPtr));
            var __ret = ___Clone_0Delegate((__Instance + __PointerAdjustment));
            global::CommonTest.Exception __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Exception.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CommonTest.Exception) global::CommonTest.Exception.NativeToManagedMap[__ret];
            else __result0 = global::CommonTest.Exception.__CreateInstance(__ret);
            return __result0;
        }

        #region Virtual table interop

        // Ex2* clone() override
        private static global::CommonTest.Delegates.Func_IntPtr_IntPtr _Clone_0DelegateInstance;

        private static global::System.IntPtr _Clone_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.DerivedException) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Clone();
            return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Clone_0DelegateInstance += _Clone_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Clone_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class DefaultParameters : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DefaultParameters@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Foo@DefaultParameters@@QAEXHH@Z")]
            internal static extern void Foo_0(global::System.IntPtr instance, int a, int b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Bar@DefaultParameters@@QAEXXZ")]
            internal static extern void Bar_1(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DefaultParameters> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DefaultParameters>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.DefaultParameters __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DefaultParameters(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DefaultParameters __CreateInstance(global::CommonTest.DefaultParameters.__Internal native, bool skipVTables = false)
        {
            return new DefaultParameters(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DefaultParameters.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DefaultParameters.__Internal));
            *(global::CommonTest.DefaultParameters.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DefaultParameters(global::CommonTest.DefaultParameters.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DefaultParameters(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DefaultParameters()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DefaultParameters.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DefaultParameters(global::CommonTest.DefaultParameters _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DefaultParameters.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.DefaultParameters.__Internal*) __Instance) = *((global::CommonTest.DefaultParameters.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.DefaultParameters __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Foo(int a, int b = 0)
        {
            __Internal.Foo_0((__Instance + __PointerAdjustment), a, b);
        }

        public void Bar()
        {
            __Internal.Bar_1((__Instance + __PointerAdjustment));
        }
    }

    public unsafe partial class Derived : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Derived@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Derived> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Derived>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.Derived __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Derived(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Derived __CreateInstance(global::CommonTest.Derived.__Internal native, bool skipVTables = false)
        {
            return new Derived(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Derived.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Derived.__Internal));
            *(global::CommonTest.Derived.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Derived(global::CommonTest.Derived.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Derived(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Derived()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Derived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Derived(global::CommonTest.Derived _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Derived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.Derived.__Internal*) __Instance) = *((global::CommonTest.Derived.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.Derived __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class Common : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0common@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?unsafeFunction@@YAHABUBar@@PADP6AXH@Z@Z")]
            internal static extern int UnsafeFunction_0(global::System.IntPtr ret, sbyte* testForString, global::System.IntPtr foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?test@@YAHAAVcommon@@@Z")]
            internal static extern int Test_0(global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?funcTryRefTypePtrOut@@YAXPAVRefTypeClassPassTry@@@Z")]
            internal static extern void FuncTryRefTypePtrOut_0(global::System.IntPtr classTry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?funcTryRefTypeOut@@YAXVRefTypeClassPassTry@@@Z")]
            internal static extern void FuncTryRefTypeOut_0(global::CommonTest.RefTypeClassPassTry.__Internal classTry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?funcTryValTypePtrOut@@YAXPAVValueTypeClassPassTry@@@Z")]
            internal static extern void FuncTryValTypePtrOut_0(global::System.IntPtr classTry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?funcTryValTypeOut@@YAXVValueTypeClassPassTry@@@Z")]
            internal static extern void FuncTryValTypeOut_0(global::CommonTest.ValueTypeClassPassTry.__Internal classTry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?func_union@@YAHTunion_t@@@Z")]
            internal static extern int FuncUnion_0(global::CommonTest.UnionT.__Internal u);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?FuncWithTypeAlias@@YAXH@Z")]
            internal static extern void FuncWithTypeAlias_0(int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?hasPointerParam@@YAXPAVFoo@@H@Z")]
            internal static extern void HasPointerParam_0(global::System.IntPtr foo, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?hasPointerParam@@YAXABVFoo@@@Z")]
            internal static extern void HasPointerParam_1(global::System.IntPtr foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?sMallFollowedByCapital@@YAXXZ")]
            internal static extern void SMallFollowedByCapital_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?indirectReturn@@YA?AUBar@@XZ")]
            internal static extern void IndirectReturn_0(global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Function@@YAHXZ")]
            internal static extern int Function_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TestDecltype@@YAHXZ")]
            internal static extern int TestDecltype_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?TestNullPtrTypeRet@@YA$$TXZ")]
            internal static extern void* TestNullPtrTypeRet_0();
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void __AnonymousDelegate0(int _0);

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Common> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Common>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.Common __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Common(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Common __CreateInstance(global::CommonTest.Common.__Internal native, bool skipVTables = false)
        {
            return new Common(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Common.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Common.__Internal));
            *(global::CommonTest.Common.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Common(global::CommonTest.Common.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Common(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Common()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Common.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Common(global::CommonTest.Common _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Common.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.Common.__Internal*) __Instance) = *((global::CommonTest.Common.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.Common __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static int UnsafeFunction(global::CommonTest.Bar ret, char* testForString, global::CommonTest.Common.__AnonymousDelegate0 foo)
        {
            var ____arg0 = ret.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            var __arg1 = (sbyte*) testForString;
            var __arg2 = foo == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(foo);
            var __ret = __Internal.UnsafeFunction_0(__arg0, __arg1, __arg2);
            return __ret;
        }

        public static int Test(global::CommonTest.Common s)
        {
            if (ReferenceEquals(s, null))
                throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = s.__Instance;
            var __ret = __Internal.Test_0(__arg0);
            return __ret;
        }

        public static void FuncTryRefTypePtrOut(out global::CommonTest.RefTypeClassPassTry classTry)
        {
            classTry = new global::CommonTest.RefTypeClassPassTry();
            var __arg0 = ReferenceEquals(classTry, null) ? global::System.IntPtr.Zero : classTry.__Instance;
            __Internal.FuncTryRefTypePtrOut_0(__arg0);
            global::CommonTest.RefTypeClassPassTry __result0;
            if (__arg0 == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.RefTypeClassPassTry.NativeToManagedMap.ContainsKey(__arg0))
                __result0 = (global::CommonTest.RefTypeClassPassTry) global::CommonTest.RefTypeClassPassTry.NativeToManagedMap[__arg0];
            else __result0 = global::CommonTest.RefTypeClassPassTry.__CreateInstance(__arg0);
            classTry = __result0;
        }

        public static void FuncTryRefTypeOut(out global::CommonTest.RefTypeClassPassTry classTry)
        {
            classTry = new global::CommonTest.RefTypeClassPassTry();
            var __arg0 = ReferenceEquals(classTry, null) ? new global::CommonTest.RefTypeClassPassTry.__Internal() : *(global::CommonTest.RefTypeClassPassTry.__Internal*) classTry.__Instance;
            __Internal.FuncTryRefTypeOut_0(__arg0);
            classTry = global::CommonTest.RefTypeClassPassTry.__CreateInstance(__arg0);
        }

        public static void FuncTryValTypePtrOut(out global::CommonTest.ValueTypeClassPassTry classTry)
        {
            classTry = new global::CommonTest.ValueTypeClassPassTry();
            var ____arg0 = new global::CommonTest.ValueTypeClassPassTry.__Internal();
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.FuncTryValTypePtrOut_0(__arg0);
            global::CommonTest.ValueTypeClassPassTry __result0;
            if (__arg0 == IntPtr.Zero) __result0 = new global::CommonTest.ValueTypeClassPassTry();
            else __result0 = global::CommonTest.ValueTypeClassPassTry.__CreateInstance(__arg0);
            classTry = __result0;
        }

        public static void FuncTryValTypeOut(out global::CommonTest.ValueTypeClassPassTry classTry)
        {
            classTry = new global::CommonTest.ValueTypeClassPassTry();
            var __arg0 = classTry.__Instance;
            __Internal.FuncTryValTypeOut_0(__arg0);
            classTry = global::CommonTest.ValueTypeClassPassTry.__CreateInstance(__arg0);
        }

        public static int FuncUnion(global::CommonTest.UnionT u)
        {
            var __arg0 = u.__Instance;
            var __ret = __Internal.FuncUnion_0(__arg0);
            return __ret;
        }

        public static void FuncWithTypeAlias(int i)
        {
            __Internal.FuncWithTypeAlias_0(i);
        }

        public static void HasPointerParam(global::CommonTest.Foo foo, int i)
        {
            var __arg0 = ReferenceEquals(foo, null) ? global::System.IntPtr.Zero : foo.__Instance;
            __Internal.HasPointerParam_0(__arg0, i);
        }

        public static void HasPointerParam(global::CommonTest.Foo foo)
        {
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            __Internal.HasPointerParam_1(__arg0);
        }

        public static void SMallFollowedByCapital()
        {
            __Internal.SMallFollowedByCapital_0();
        }

        public static global::CommonTest.Bar IndirectReturn
        {
            get
            {
                var __ret = new global::CommonTest.Bar.__Internal();
                __Internal.IndirectReturn_0(new IntPtr(&__ret));
                return global::CommonTest.Bar.__CreateInstance(__ret);
            }
        }

        public static int Function
        {
            get
            {
                var __ret = __Internal.Function_0();
                return __ret;
            }
        }

        public static int TestDecltype
        {
            get
            {
                var __ret = __Internal.TestDecltype_0();
                return __ret;
            }
        }

        public static void* TestNullPtrTypeRet
        {
            get
            {
                var __ret = __Internal.TestNullPtrTypeRet_0();
                return __ret;
            }
        }
    }

    public unsafe partial class TestMoveOperatorToClass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public int B;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestMoveOperatorToClass@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestMoveOperatorToClass@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??D@YAHUTestMoveOperatorToClass@@H@Z")]
            internal static extern int OperatorStar_0(global::CommonTest.TestMoveOperatorToClass.__Internal klass, int b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??G@YA?AUTestMoveOperatorToClass@@ABU0@@Z")]
            internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??H@YA?AUTestMoveOperatorToClass@@ABU0@0@Z")]
            internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr b1, global::System.IntPtr b2);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestMoveOperatorToClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestMoveOperatorToClass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestMoveOperatorToClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestMoveOperatorToClass(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestMoveOperatorToClass __CreateInstance(global::CommonTest.TestMoveOperatorToClass.__Internal native, bool skipVTables = false)
        {
            return new TestMoveOperatorToClass(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestMoveOperatorToClass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMoveOperatorToClass.__Internal));
            *(global::CommonTest.TestMoveOperatorToClass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestMoveOperatorToClass(global::CommonTest.TestMoveOperatorToClass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestMoveOperatorToClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestMoveOperatorToClass()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMoveOperatorToClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestMoveOperatorToClass(global::CommonTest.TestMoveOperatorToClass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMoveOperatorToClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestMoveOperatorToClass.__Internal*) __Instance) = *((global::CommonTest.TestMoveOperatorToClass.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestMoveOperatorToClass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static int operator *(global::CommonTest.TestMoveOperatorToClass klass, int b)
        {
            var __arg0 = ReferenceEquals(klass, null) ? new global::CommonTest.TestMoveOperatorToClass.__Internal() : *(global::CommonTest.TestMoveOperatorToClass.__Internal*) klass.__Instance;
            var __ret = __Internal.OperatorStar_0(__arg0, b);
            return __ret;
        }

        public static global::CommonTest.TestMoveOperatorToClass operator -(global::CommonTest.TestMoveOperatorToClass b)
        {
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = b.__Instance;
            var __ret = new global::CommonTest.TestMoveOperatorToClass.__Internal();
            __Internal.OperatorMinus_0(new IntPtr(&__ret), __arg0);
            return global::CommonTest.TestMoveOperatorToClass.__CreateInstance(__ret);
        }

        public static global::CommonTest.TestMoveOperatorToClass operator +(global::CommonTest.TestMoveOperatorToClass b1, global::CommonTest.TestMoveOperatorToClass b2)
        {
            if (ReferenceEquals(b1, null))
                throw new global::System.ArgumentNullException("b1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = b1.__Instance;
            if (ReferenceEquals(b2, null))
                throw new global::System.ArgumentNullException("b2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b2.__Instance;
            var __ret = new global::CommonTest.TestMoveOperatorToClass.__Internal();
            __Internal.OperatorPlus_0(new IntPtr(&__ret), __arg0, __arg1);
            return global::CommonTest.TestMoveOperatorToClass.__CreateInstance(__ret);
        }

        public int A
        {
            get
            {
                return ((global::CommonTest.TestMoveOperatorToClass.__Internal*) __Instance)->A;
            }

            set
            {
                ((global::CommonTest.TestMoveOperatorToClass.__Internal*) __Instance)->A = value;
            }
        }

        public int B
        {
            get
            {
                return ((global::CommonTest.TestMoveOperatorToClass.__Internal*) __Instance)->B;
            }

            set
            {
                ((global::CommonTest.TestMoveOperatorToClass.__Internal*) __Instance)->B = value;
            }
        }
    }

    public unsafe partial class TestDelegates : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr A;

            [FieldOffset(4)]
            public global::System.IntPtr B;

            [FieldOffset(8)]
            public global::System.IntPtr C;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestDelegates@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestDelegates@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Double@TestDelegates@@SAHH@Z")]
            internal static extern int Double_0(int N);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Triple@TestDelegates@@QAEHH@Z")]
            internal static extern int Triple_0(global::System.IntPtr instance, int N);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?StdCall@TestDelegates@@QAEHP6GHH@Z@Z")]
            internal static extern int StdCall_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?CDecl@TestDelegates@@QAEHP6AHH@Z@Z")]
            internal static extern int CDecl_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalUnattributedDelegate@TestDelegates@@QAEXP6AHH@Z@Z")]
            internal static extern void MarshalUnattributedDelegate_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalAnonymousDelegate@TestDelegates@@QAEHP6AHH@Z@Z")]
            internal static extern int MarshalAnonymousDelegate_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalAnonymousDelegate2@TestDelegates@@QAEXP6AHH@Z@Z")]
            internal static extern void MarshalAnonymousDelegate2_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalAnonymousDelegate3@TestDelegates@@QAEXP6AMM@Z@Z")]
            internal static extern void MarshalAnonymousDelegate3_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalDelegateInAnotherUnit@TestDelegates@@QAEXP6AXXZ@Z")]
            internal static extern void MarshalDelegateInAnotherUnit_0(global::System.IntPtr instance, global::System.IntPtr del);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalAnonymousDelegate4@TestDelegates@@QAEP6AHH@ZXZ")]
            internal static extern global::System.IntPtr MarshalAnonymousDelegate4_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?MarshalNullDelegate@TestDelegates@@QAEP6AXXZXZ")]
            internal static extern global::System.IntPtr MarshalNullDelegate_0(global::System.IntPtr instance);
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int DelegateInClass(int _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate int __AnonymousDelegate0(int _0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate float __AnonymousDelegate1(float _0);

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestDelegates> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestDelegates>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestDelegates __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestDelegates(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestDelegates __CreateInstance(global::CommonTest.TestDelegates.__Internal native, bool skipVTables = false)
        {
            return new TestDelegates(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestDelegates.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestDelegates.__Internal));
            *(global::CommonTest.TestDelegates.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestDelegates(global::CommonTest.TestDelegates.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestDelegates(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestDelegates()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestDelegates.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestDelegates(global::CommonTest.TestDelegates _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestDelegates.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestDelegates.__Internal*) __Instance) = *((global::CommonTest.TestDelegates.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestDelegates __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Triple(int N)
        {
            var __ret = __Internal.Triple_0((__Instance + __PointerAdjustment), N);
            return __ret;
        }

        public int StdCall(global::CommonTest.DelegateStdCall del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            var __ret = __Internal.StdCall_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public int CDecl(global::CommonTest.DelegateCDecl del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            var __ret = __Internal.CDecl_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void MarshalUnattributedDelegate(global::CommonTest.DelegateInGlobalNamespace del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            __Internal.MarshalUnattributedDelegate_0((__Instance + __PointerAdjustment), __arg0);
        }

        public int MarshalAnonymousDelegate(global::CommonTest.TestDelegates.__AnonymousDelegate0 del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            var __ret = __Internal.MarshalAnonymousDelegate_0((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public void MarshalAnonymousDelegate2(global::CommonTest.TestDelegates.__AnonymousDelegate0 del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            __Internal.MarshalAnonymousDelegate2_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void MarshalAnonymousDelegate3(global::CommonTest.TestDelegates.__AnonymousDelegate1 del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            __Internal.MarshalAnonymousDelegate3_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void MarshalDelegateInAnotherUnit(global::CommonTest.DelegateInAnotherUnit del)
        {
            var __arg0 = del == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(del);
            __Internal.MarshalDelegateInAnotherUnit_0((__Instance + __PointerAdjustment), __arg0);
        }

        public static int Double(int N)
        {
            var __ret = __Internal.Double_0(N);
            return __ret;
        }

        public global::CommonTest.TestDelegates.DelegateInClass A
        {
            get
            {
                var __ptr0 = ((global::CommonTest.TestDelegates.__Internal*) __Instance)->A;
                return __ptr0 == IntPtr.Zero? null : (global::CommonTest.TestDelegates.DelegateInClass)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::CommonTest.TestDelegates.DelegateInClass));
            }

            set
            {
                ((global::CommonTest.TestDelegates.__Internal*) __Instance)->A = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::CommonTest.DelegateInGlobalNamespace B
        {
            get
            {
                var __ptr0 = ((global::CommonTest.TestDelegates.__Internal*) __Instance)->B;
                return __ptr0 == IntPtr.Zero? null : (global::CommonTest.DelegateInGlobalNamespace)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::CommonTest.DelegateInGlobalNamespace));
            }

            set
            {
                ((global::CommonTest.TestDelegates.__Internal*) __Instance)->B = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::CommonTest.TestDelegates.__AnonymousDelegate0 MarshalAnonymousDelegate4
        {
            get
            {
                var __ret = __Internal.MarshalAnonymousDelegate4_0((__Instance + __PointerAdjustment));
                var __ptr0 = __ret;
                return __ptr0 == IntPtr.Zero? null : (global::CommonTest.TestDelegates.__AnonymousDelegate0)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::CommonTest.TestDelegates.__AnonymousDelegate0));
            }
        }

        public global::CommonTest.DelegateNullCheck MarshalNullDelegate
        {
            get
            {
                var __ret = __Internal.MarshalNullDelegate_0((__Instance + __PointerAdjustment));
                var __ptr0 = __ret;
                return __ptr0 == IntPtr.Zero? null : (global::CommonTest.DelegateNullCheck)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::CommonTest.DelegateNullCheck));
            }
        }
    }

    public unsafe partial class TestMemoryLeaks : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestMemoryLeaks@@QAE@PBD@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestMemoryLeaks@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestMemoryLeaks> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestMemoryLeaks>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestMemoryLeaks __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestMemoryLeaks(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestMemoryLeaks __CreateInstance(global::CommonTest.TestMemoryLeaks.__Internal native, bool skipVTables = false)
        {
            return new TestMemoryLeaks(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestMemoryLeaks.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMemoryLeaks.__Internal));
            *(global::CommonTest.TestMemoryLeaks.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestMemoryLeaks(global::CommonTest.TestMemoryLeaks.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestMemoryLeaks(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestMemoryLeaks(string name)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMemoryLeaks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), name);
        }

        public TestMemoryLeaks(global::CommonTest.TestMemoryLeaks _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestMemoryLeaks.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestMemoryLeaks.__Internal*) __Instance) = *((global::CommonTest.TestMemoryLeaks.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestMemoryLeaks __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.TestMemoryLeaks(string name)
        {
            return new global::CommonTest.TestMemoryLeaks(name);
        }
    }

    public unsafe partial class TestFinalizers : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestFinalizers@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestFinalizers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestFinalizers>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestFinalizers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestFinalizers(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestFinalizers __CreateInstance(global::CommonTest.TestFinalizers.__Internal native, bool skipVTables = false)
        {
            return new TestFinalizers(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestFinalizers.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFinalizers.__Internal));
            *(global::CommonTest.TestFinalizers.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestFinalizers(global::CommonTest.TestFinalizers.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestFinalizers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestFinalizers()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFinalizers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestFinalizers(global::CommonTest.TestFinalizers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFinalizers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestFinalizers.__Internal*) __Instance) = *((global::CommonTest.TestFinalizers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestFinalizers __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe static partial class TestStaticClass
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Add@TestStaticClass@@SAHHH@Z")]
            internal static extern int Add_0(int a, int b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?GetOneTwoThree@TestStaticClass@@SAHXZ")]
            internal static extern int GetOneTwoThree_0();
        }

        public static int Add(int a, int b)
        {
            var __ret = __Internal.Add_0(a, b);
            return __ret;
        }

        public static int OneTwoThree
        {
            get
            {
                var __ret = __Internal.GetOneTwoThree_0();
                return __ret;
            }
        }
    }

    public unsafe static partial class TestStaticClassDerived
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public new partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?Foo@TestStaticClassDerived@@SAHXZ")]
            internal static extern int Foo_0();
        }

        public static int Foo
        {
            get
            {
                var __ret = __Internal.Foo_0();
                return __ret;
            }
        }
    }

    public unsafe partial class TestNotStaticClass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestNotStaticClass@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?StaticFunction@TestNotStaticClass@@SA?AV1@XZ")]
            internal static extern void StaticFunction_0(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNotStaticClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNotStaticClass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestNotStaticClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestNotStaticClass(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestNotStaticClass __CreateInstance(global::CommonTest.TestNotStaticClass.__Internal native, bool skipVTables = false)
        {
            return new TestNotStaticClass(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestNotStaticClass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNotStaticClass.__Internal));
            *(global::CommonTest.TestNotStaticClass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestNotStaticClass(global::CommonTest.TestNotStaticClass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestNotStaticClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestNotStaticClass(global::CommonTest.TestNotStaticClass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNotStaticClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestNotStaticClass.__Internal*) __Instance) = *((global::CommonTest.TestNotStaticClass.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestNotStaticClass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static global::CommonTest.TestNotStaticClass StaticFunction
        {
            get
            {
                var __ret = new global::CommonTest.TestNotStaticClass.__Internal();
                __Internal.StaticFunction_0(new IntPtr(&__ret));
                return global::CommonTest.TestNotStaticClass.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class HasIgnoredField : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CommonTest.Base.__Internal fieldOfIgnoredType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasIgnoredField@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasIgnoredField> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasIgnoredField>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasIgnoredField __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasIgnoredField(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasIgnoredField __CreateInstance(global::CommonTest.HasIgnoredField.__Internal native, bool skipVTables = false)
        {
            return new HasIgnoredField(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasIgnoredField.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasIgnoredField.__Internal));
            *(global::CommonTest.HasIgnoredField.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasIgnoredField(global::CommonTest.HasIgnoredField.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasIgnoredField(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasIgnoredField()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasIgnoredField.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HasIgnoredField(global::CommonTest.HasIgnoredField _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasIgnoredField.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasIgnoredField.__Internal*) __Instance) = *((global::CommonTest.HasIgnoredField.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasIgnoredField __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class TestCopyConstructorRef : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestCopyConstructorRef@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestCopyConstructorRef@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestCopyConstructorRef> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestCopyConstructorRef>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestCopyConstructorRef __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestCopyConstructorRef(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestCopyConstructorRef __CreateInstance(global::CommonTest.TestCopyConstructorRef.__Internal native, bool skipVTables = false)
        {
            return new TestCopyConstructorRef(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestCopyConstructorRef.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestCopyConstructorRef.__Internal));
            global::CommonTest.TestCopyConstructorRef.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private TestCopyConstructorRef(global::CommonTest.TestCopyConstructorRef.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestCopyConstructorRef(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestCopyConstructorRef()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestCopyConstructorRef.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestCopyConstructorRef(global::CommonTest.TestCopyConstructorRef other)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestCopyConstructorRef.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestCopyConstructorRef __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int A
        {
            get
            {
                return ((global::CommonTest.TestCopyConstructorRef.__Internal*) __Instance)->A;
            }

            set
            {
                ((global::CommonTest.TestCopyConstructorRef.__Internal*) __Instance)->A = value;
            }
        }

        public float B
        {
            get
            {
                return ((global::CommonTest.TestCopyConstructorRef.__Internal*) __Instance)->B;
            }

            set
            {
                ((global::CommonTest.TestCopyConstructorRef.__Internal*) __Instance)->B = value;
            }
        }
    }

    public unsafe partial class SomeStruct : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint p;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SomeStruct@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SomeStruct@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.SomeStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.SomeStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.SomeStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SomeStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.SomeStruct __CreateInstance(global::CommonTest.SomeStruct.__Internal native, bool skipVTables = false)
        {
            return new SomeStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.SomeStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeStruct.__Internal));
            *(global::CommonTest.SomeStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SomeStruct(global::CommonTest.SomeStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SomeStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SomeStruct()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public SomeStruct(global::CommonTest.SomeStruct _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.SomeStruct.__Internal*) __Instance) = *((global::CommonTest.SomeStruct.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.SomeStruct __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public uint P
        {
            get
            {
                return ((global::CommonTest.SomeStruct.__Internal*) __Instance)->p;
            }

            set
            {
                ((global::CommonTest.SomeStruct.__Internal*) __Instance)->p = value;
            }
        }
    }

    public unsafe partial class SomeClassExtendingTheStruct : global::CommonTest.SomeStruct, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public uint p;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SomeClassExtendingTheStruct@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SomeClassExtendingTheStruct@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.SomeClassExtendingTheStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SomeClassExtendingTheStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.SomeClassExtendingTheStruct __CreateInstance(global::CommonTest.SomeClassExtendingTheStruct.__Internal native, bool skipVTables = false)
        {
            return new SomeClassExtendingTheStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.SomeClassExtendingTheStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeClassExtendingTheStruct.__Internal));
            *(global::CommonTest.SomeClassExtendingTheStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SomeClassExtendingTheStruct(global::CommonTest.SomeClassExtendingTheStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SomeClassExtendingTheStruct(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SomeClassExtendingTheStruct()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeClassExtendingTheStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public SomeClassExtendingTheStruct(global::CommonTest.SomeClassExtendingTheStruct _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeClassExtendingTheStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.SomeClassExtendingTheStruct.__Internal*) __Instance) = *((global::CommonTest.SomeClassExtendingTheStruct.__Internal*) _0.__Instance);
        }
    }

    public unsafe partial class ClassWithOverloadedOperators : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_ClassWithOverloadedOperators;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassWithOverloadedOperators@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassWithOverloadedOperators@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??BClassWithOverloadedOperators@@QAEDXZ")]
            internal static extern sbyte OperatorConversion_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??BClassWithOverloadedOperators@@QAEHXZ")]
            internal static extern int OperatorConversion_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??BClassWithOverloadedOperators@@QAEFXZ")]
            internal static extern short OperatorConversion_2(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??MClassWithOverloadedOperators@@UBE_NABV0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr other);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassWithOverloadedOperators> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassWithOverloadedOperators>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ClassWithOverloadedOperators __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ClassWithOverloadedOperators(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ClassWithOverloadedOperators __CreateInstance(global::CommonTest.ClassWithOverloadedOperators.__Internal native, bool skipVTables = false)
        {
            return new ClassWithOverloadedOperators(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ClassWithOverloadedOperators.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassWithOverloadedOperators.__Internal));
            global::CommonTest.ClassWithOverloadedOperators.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ClassWithOverloadedOperators(global::CommonTest.ClassWithOverloadedOperators.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ClassWithOverloadedOperators(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ClassWithOverloadedOperators()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassWithOverloadedOperators.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public ClassWithOverloadedOperators(global::CommonTest.ClassWithOverloadedOperators _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassWithOverloadedOperators.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ClassWithOverloadedOperators __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator char(global::CommonTest.ClassWithOverloadedOperators __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorConversion_0(__arg0);
            return global::System.Convert.ToChar(__ret);
        }

        public static implicit operator int(global::CommonTest.ClassWithOverloadedOperators __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorConversion_1(__arg0);
            return __ret;
        }

        public static implicit operator short(global::CommonTest.ClassWithOverloadedOperators __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorConversion_2(__arg0);
            return __ret;
        }

        public static bool operator >(global::CommonTest.ClassWithOverloadedOperators __op, global::CommonTest.ClassWithOverloadedOperators other)
        {
            return !(__op < other);
        }

        public static bool operator <(global::CommonTest.ClassWithOverloadedOperators __op, global::CommonTest.ClassWithOverloadedOperators other)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorLess_0(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class TestProperties : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Field;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestProperties@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestProperties@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getFieldValue@TestProperties@@QAEHXZ")]
            internal static extern int FieldValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setFieldValue@TestProperties@@QAEXH@Z")]
            internal static extern void SetFieldValue_0(global::System.IntPtr instance, int Value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestProperties>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestProperties(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestProperties __CreateInstance(global::CommonTest.TestProperties.__Internal native, bool skipVTables = false)
        {
            return new TestProperties(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestProperties.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestProperties.__Internal));
            *(global::CommonTest.TestProperties.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestProperties(global::CommonTest.TestProperties.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestProperties(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestProperties()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestProperties(global::CommonTest.TestProperties _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestProperties.__Internal*) __Instance) = *((global::CommonTest.TestProperties.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestProperties __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Field
        {
            get
            {
                return ((global::CommonTest.TestProperties.__Internal*) __Instance)->Field;
            }

            set
            {
                ((global::CommonTest.TestProperties.__Internal*) __Instance)->Field = value;
            }
        }

        public int FieldValue
        {
            get
            {
                var __ret = __Internal.FieldValue_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetFieldValue_0((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class TypeMappedIndex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TypeMappedIndex@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TypeMappedIndex@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TypeMappedIndex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TypeMappedIndex>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TypeMappedIndex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TypeMappedIndex(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TypeMappedIndex __CreateInstance(global::CommonTest.TypeMappedIndex.__Internal native, bool skipVTables = false)
        {
            return new TypeMappedIndex(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TypeMappedIndex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TypeMappedIndex.__Internal));
            *(global::CommonTest.TypeMappedIndex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TypeMappedIndex(global::CommonTest.TypeMappedIndex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TypeMappedIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TypeMappedIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TypeMappedIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TypeMappedIndex(global::CommonTest.TypeMappedIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TypeMappedIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TypeMappedIndex.__Internal*) __Instance) = *((global::CommonTest.TypeMappedIndex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TypeMappedIndex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class TestIndexedProperties : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint p;

            [FieldOffset(4)]
            public global::CommonTest.TestProperties.__Internal f;

            [FieldOffset(8)]
            public global::CommonTest.Bar.__Internal bar;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestIndexedProperties@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestIndexedProperties@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEAAKH@Z")]
            internal static extern uint* OperatorSubscript_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEPAKM@Z")]
            internal static extern uint* OperatorSubscript_1(global::System.IntPtr instance, float f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEKPBD@Z")]
            internal static extern uint OperatorSubscript_2(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEABKN@Z")]
            internal static extern uint* OperatorSubscript_3(global::System.IntPtr instance, double d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEPAUTestProperties@@E@Z")]
            internal static extern global::System.IntPtr OperatorSubscript_4(global::System.IntPtr instance, byte b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEABUTestProperties@@F@Z")]
            internal static extern global::System.IntPtr OperatorSubscript_5(global::System.IntPtr instance, short b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEKUTestProperties@@@Z")]
            internal static extern uint OperatorSubscript_6(global::System.IntPtr instance, global::CommonTest.TestProperties.__Internal b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEAAUBar@@K@Z")]
            internal static extern global::System.IntPtr OperatorSubscript_7(global::System.IntPtr instance, uint i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEAAUBar@@ABVTypeMappedIndex@@@Z")]
            internal static extern global::System.IntPtr OperatorSubscript_8(global::System.IntPtr instance, global::System.IntPtr key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedProperties@@QAEHD@Z")]
            internal static extern int OperatorSubscript_9(global::System.IntPtr instance, sbyte key);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestIndexedProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestIndexedProperties>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestIndexedProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestIndexedProperties(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestIndexedProperties __CreateInstance(global::CommonTest.TestIndexedProperties.__Internal native, bool skipVTables = false)
        {
            return new TestIndexedProperties(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestIndexedProperties.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedProperties.__Internal));
            *(global::CommonTest.TestIndexedProperties.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestIndexedProperties(global::CommonTest.TestIndexedProperties.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestIndexedProperties(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestIndexedProperties()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestIndexedProperties(global::CommonTest.TestIndexedProperties _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestIndexedProperties.__Internal*) __Instance) = *((global::CommonTest.TestIndexedProperties.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestIndexedProperties __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public uint this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), i);
                return *__ret;
            }

            set
            {
                *__Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), i) = value;
            }
        }

        public uint this[float f]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_1((__Instance + __PointerAdjustment), f);
                return *__ret;
            }

            set
            {
                *__Internal.OperatorSubscript_1((__Instance + __PointerAdjustment), f) = value;
            }
        }

        public uint this[string name]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_2((__Instance + __PointerAdjustment), name);
                return __ret;
            }
        }

        public uint* this[double d]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_3((__Instance + __PointerAdjustment), d);
                return __ret;
            }
        }

        public global::CommonTest.TestProperties this[byte b]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_4((__Instance + __PointerAdjustment), b);
                global::CommonTest.TestProperties __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CommonTest.TestProperties.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CommonTest.TestProperties) global::CommonTest.TestProperties.NativeToManagedMap[__ret];
                else __result0 = global::CommonTest.TestProperties.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(global::CommonTest.TestProperties.__Internal*) __Internal.OperatorSubscript_4((__Instance + __PointerAdjustment), b) = *(global::CommonTest.TestProperties.__Internal*) value.__Instance;
            }
        }

        public global::CommonTest.TestProperties this[short b]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_5((__Instance + __PointerAdjustment), b);
                global::CommonTest.TestProperties __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CommonTest.TestProperties.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CommonTest.TestProperties) global::CommonTest.TestProperties.NativeToManagedMap[__ret];
                else __result0 = global::CommonTest.TestProperties.__CreateInstance(__ret);
                return __result0;
            }
        }

        public uint this[global::CommonTest.TestProperties b]
        {
            get
            {
                var __arg0 = ReferenceEquals(b, null) ? new global::CommonTest.TestProperties.__Internal() : *(global::CommonTest.TestProperties.__Internal*) b.__Instance;
                var __ret = __Internal.OperatorSubscript_6((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public global::CommonTest.Bar this[uint i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_7((__Instance + __PointerAdjustment), i);
                global::CommonTest.Bar __result0;
                if (__ret == IntPtr.Zero) __result0 = new global::CommonTest.Bar();
                else __result0 = global::CommonTest.Bar.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(global::CommonTest.Bar.__Internal*) __Internal.OperatorSubscript_7((__Instance + __PointerAdjustment), i) = value.__Instance;
            }
        }

        public global::CommonTest.Bar this[ushort key]
        {
            get
            {
                var __arg0 = IntPtr.Zero;
                var __ret = __Internal.OperatorSubscript_8((__Instance + __PointerAdjustment), __arg0);
                global::CommonTest.Bar __result0;
                if (__ret == IntPtr.Zero) __result0 = new global::CommonTest.Bar();
                else __result0 = global::CommonTest.Bar.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = IntPtr.Zero;
                *(global::CommonTest.Bar.__Internal*) __Internal.OperatorSubscript_8((__Instance + __PointerAdjustment), IntPtr.Zero) = value.__Instance;
            }
        }

        public int this[char key]
        {
            get
            {
                var __arg0 = global::System.Convert.ToSByte(key);
                var __ret = __Internal.OperatorSubscript_9((__Instance + __PointerAdjustment), __arg0);
                key = global::System.Convert.ToChar(__arg0);
                return __ret;
            }
        }
    }

    public unsafe partial class TestIndexedPropertiesInValueType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestIndexedPropertiesInValueType@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ATestIndexedPropertiesInValueType@@QAEHH@Z")]
            internal static extern int OperatorSubscript_0(global::System.IntPtr instance, int i);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestIndexedPropertiesInValueType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestIndexedPropertiesInValueType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestIndexedPropertiesInValueType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestIndexedPropertiesInValueType(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestIndexedPropertiesInValueType __CreateInstance(global::CommonTest.TestIndexedPropertiesInValueType.__Internal native, bool skipVTables = false)
        {
            return new TestIndexedPropertiesInValueType(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestIndexedPropertiesInValueType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedPropertiesInValueType.__Internal));
            *(global::CommonTest.TestIndexedPropertiesInValueType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestIndexedPropertiesInValueType(global::CommonTest.TestIndexedPropertiesInValueType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestIndexedPropertiesInValueType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestIndexedPropertiesInValueType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedPropertiesInValueType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestIndexedPropertiesInValueType(global::CommonTest.TestIndexedPropertiesInValueType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestIndexedPropertiesInValueType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestIndexedPropertiesInValueType.__Internal*) __Instance) = *((global::CommonTest.TestIndexedPropertiesInValueType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestIndexedPropertiesInValueType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_0((__Instance + __PointerAdjustment), i);
                return __ret;
            }
        }
    }

    public unsafe partial class TestVariables : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestVariables@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?SetValue@TestVariables@@QAEXH@Z")]
            internal static extern void SetValue_0(global::System.IntPtr instance, int value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestVariables> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestVariables>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestVariables __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestVariables(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestVariables __CreateInstance(global::CommonTest.TestVariables.__Internal native, bool skipVTables = false)
        {
            return new TestVariables(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestVariables.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestVariables.__Internal));
            *(global::CommonTest.TestVariables.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestVariables(global::CommonTest.TestVariables.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestVariables(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestVariables()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestVariables.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestVariables(global::CommonTest.TestVariables _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestVariables.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestVariables.__Internal*) __Instance) = *((global::CommonTest.TestVariables.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestVariables __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void SetValue(int value)
        {
            __Internal.SetValue_0((__Instance + __PointerAdjustment), value);
        }

        public void SetValue()
        {
            SetValue((int) global::CommonTest.TestVariables.VALUE);
        }

        public static int VALUE
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?VALUE@TestVariables@@2HA");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?VALUE@TestVariables@@2HA");
                *__ptr = value;
            }
        }
    }

    public unsafe partial class TestWideStrings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestWideStrings@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetWidePointer@TestWideStrings@@QAEPB_WXZ")]
            internal static extern global::System.IntPtr GetWidePointer_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?GetWideNullPointer@TestWideStrings@@QAEPB_WXZ")]
            internal static extern global::System.IntPtr GetWideNullPointer_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestWideStrings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestWideStrings>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestWideStrings __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestWideStrings(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestWideStrings __CreateInstance(global::CommonTest.TestWideStrings.__Internal native, bool skipVTables = false)
        {
            return new TestWideStrings(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestWideStrings.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestWideStrings.__Internal));
            *(global::CommonTest.TestWideStrings.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestWideStrings(global::CommonTest.TestWideStrings.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestWideStrings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestWideStrings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestWideStrings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestWideStrings(global::CommonTest.TestWideStrings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestWideStrings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestWideStrings.__Internal*) __Instance) = *((global::CommonTest.TestWideStrings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestWideStrings __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public string WidePointer
        {
            get
            {
                var __ret = __Internal.GetWidePointer_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringUni(__ret);
            }
        }

        public string WideNullPointer
        {
            get
            {
                var __ret = __Internal.GetWideNullPointer_0((__Instance + __PointerAdjustment));
                return Marshal.PtrToStringUni(__ret);
            }
        }
    }

    public unsafe partial class TestFixedArrays : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public fixed int Array[10];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestFixedArrays@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestFixedArrays@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestFixedArrays> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestFixedArrays>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestFixedArrays __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestFixedArrays(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestFixedArrays __CreateInstance(global::CommonTest.TestFixedArrays.__Internal native, bool skipVTables = false)
        {
            return new TestFixedArrays(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestFixedArrays.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFixedArrays.__Internal));
            *(global::CommonTest.TestFixedArrays.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestFixedArrays(global::CommonTest.TestFixedArrays.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestFixedArrays(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestFixedArrays()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFixedArrays.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestFixedArrays(global::CommonTest.TestFixedArrays _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestFixedArrays.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestFixedArrays.__Internal*) __Instance) = *((global::CommonTest.TestFixedArrays.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestFixedArrays __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class TestArraysPointers : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::CommonTest.MyEnum Value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestArraysPointers@@QAE@PAW4MyEnum@@H@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::CommonTest.MyEnum* values, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestArraysPointers@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestArraysPointers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestArraysPointers>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestArraysPointers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestArraysPointers(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestArraysPointers __CreateInstance(global::CommonTest.TestArraysPointers.__Internal native, bool skipVTables = false)
        {
            return new TestArraysPointers(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestArraysPointers.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestArraysPointers.__Internal));
            *(global::CommonTest.TestArraysPointers.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestArraysPointers(global::CommonTest.TestArraysPointers.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestArraysPointers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestArraysPointers(global::CommonTest.MyEnum* values, int count)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestArraysPointers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), values, count);
        }

        public TestArraysPointers(global::CommonTest.TestArraysPointers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestArraysPointers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestArraysPointers.__Internal*) __Instance) = *((global::CommonTest.TestArraysPointers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestArraysPointers __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CommonTest.MyEnum Value
        {
            get
            {
                return ((global::CommonTest.TestArraysPointers.__Internal*) __Instance)->Value;
            }

            set
            {
                ((global::CommonTest.TestArraysPointers.__Internal*) __Instance)->Value = value;
            }
        }
    }

    public unsafe partial class TestGetterSetterToProperties : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestGetterSetterToProperties@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getWidth@TestGetterSetterToProperties@@QAEHXZ")]
            internal static extern int GetWidth_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getHeight@TestGetterSetterToProperties@@QAEHXZ")]
            internal static extern int GetHeight_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestGetterSetterToProperties> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestGetterSetterToProperties>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestGetterSetterToProperties __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestGetterSetterToProperties(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestGetterSetterToProperties __CreateInstance(global::CommonTest.TestGetterSetterToProperties.__Internal native, bool skipVTables = false)
        {
            return new TestGetterSetterToProperties(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestGetterSetterToProperties.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestGetterSetterToProperties.__Internal));
            *(global::CommonTest.TestGetterSetterToProperties.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestGetterSetterToProperties(global::CommonTest.TestGetterSetterToProperties.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestGetterSetterToProperties(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestGetterSetterToProperties()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestGetterSetterToProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestGetterSetterToProperties(global::CommonTest.TestGetterSetterToProperties _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestGetterSetterToProperties.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestGetterSetterToProperties.__Internal*) __Instance) = *((global::CommonTest.TestGetterSetterToProperties.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestGetterSetterToProperties __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Width
        {
            get
            {
                var __ret = __Internal.GetWidth_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public int Height
        {
            get
            {
                var __ret = __Internal.GetHeight_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ClassA : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassA@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassA@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassA> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassA>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ClassA __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ClassA(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ClassA __CreateInstance(global::CommonTest.ClassA.__Internal native, bool skipVTables = false)
        {
            return new ClassA(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ClassA.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassA.__Internal));
            *(global::CommonTest.ClassA.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClassA(global::CommonTest.ClassA.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ClassA(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ClassA(int value)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), value);
        }

        public ClassA(global::CommonTest.ClassA _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassA.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.ClassA.__Internal*) __Instance) = *((global::CommonTest.ClassA.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ClassA __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.ClassA(int value)
        {
            return new global::CommonTest.ClassA(value);
        }

        public int Value
        {
            get
            {
                return ((global::CommonTest.ClassA.__Internal*) __Instance)->Value;
            }

            set
            {
                ((global::CommonTest.ClassA.__Internal*) __Instance)->Value = value;
            }
        }
    }

    public unsafe partial class ClassB : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassB@@QAE@ABVClassA@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassB@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassB> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassB>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ClassB __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ClassB(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ClassB __CreateInstance(global::CommonTest.ClassB.__Internal native, bool skipVTables = false)
        {
            return new ClassB(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ClassB.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassB.__Internal));
            *(global::CommonTest.ClassB.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClassB(global::CommonTest.ClassB.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ClassB(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ClassB(global::CommonTest.ClassA x)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(x, null))
                throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = x.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public ClassB(global::CommonTest.ClassB _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassB.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.ClassB.__Internal*) __Instance) = *((global::CommonTest.ClassB.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ClassB __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.ClassB(global::CommonTest.ClassA x)
        {
            return new global::CommonTest.ClassB(x);
        }

        public int Value
        {
            get
            {
                return ((global::CommonTest.ClassB.__Internal*) __Instance)->Value;
            }

            set
            {
                ((global::CommonTest.ClassB.__Internal*) __Instance)->Value = value;
            }
        }
    }

    public unsafe partial class ClassC : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassC@@QAE@PBVClassA@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassC@@QAE@ABVClassB@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassC@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassC> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ClassC>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ClassC __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ClassC(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ClassC __CreateInstance(global::CommonTest.ClassC.__Internal native, bool skipVTables = false)
        {
            return new ClassC(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ClassC.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassC.__Internal));
            *(global::CommonTest.ClassC.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClassC(global::CommonTest.ClassC.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ClassC(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ClassC(global::CommonTest.ClassA x)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassC.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(x, null) ? global::System.IntPtr.Zero : x.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public ClassC(global::CommonTest.ClassB x)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassC.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(x, null))
                throw new global::System.ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = x.__Instance;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public ClassC(global::CommonTest.ClassC _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ClassC.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.ClassC.__Internal*) __Instance) = *((global::CommonTest.ClassC.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ClassC __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.ClassC(global::CommonTest.ClassA x)
        {
            return new global::CommonTest.ClassC(x);
        }

        public static explicit operator global::CommonTest.ClassC(global::CommonTest.ClassB x)
        {
            return new global::CommonTest.ClassC(x);
        }

        public int Value
        {
            get
            {
                return ((global::CommonTest.ClassC.__Internal*) __Instance)->Value;
            }

            set
            {
                ((global::CommonTest.ClassC.__Internal*) __Instance)->Value = value;
            }
        }
    }

    public unsafe abstract partial class PureDtor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_PureDtor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0PureDtor@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0PureDtor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.PureDtor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.PureDtor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.PureDtor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new PureDtorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.PureDtor __CreateInstance(global::CommonTest.PureDtor.__Internal native, bool skipVTables = false)
        {
            return new PureDtorInternal(native, skipVTables);
        }

        protected PureDtor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected PureDtor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.PureDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.PureDtor");
        }

        protected PureDtor(global::CommonTest.PureDtor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.PureDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.PureDtor");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.PureDtor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.PureDtor.__Internal*) __Instance)->vfptr_PureDtor = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        #region Virtual table interop

        // virtual ~PureDtor() = 0
        private static global::CommonTest.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.PureDtor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class TestNestedTypes : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CommonTest.TestNestedTypes._.__Internal _;

            [FieldOffset(1)]
            internal global::CommonTest.TestNestedTypes._.__Internal _1;

            [FieldOffset(2)]
            internal global::CommonTest.TestNestedTypes._.__Internal _2;

            [FieldOffset(3)]
            internal global::CommonTest.TestNestedTypes._.__Internal _3;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestNestedTypes@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial class _
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::CommonTest.TestNestedTypes._.__.__Internal __;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }
            }
        }

        public unsafe partial struct AsTypes
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int as_int;

                [FieldOffset(0)]
                public global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal as_uchar;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0as_types@TestNestedTypes@@QAE@ABT01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public unsafe partial class Uchars : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    public byte blue;

                    [FieldOffset(1)]
                    public byte green;

                    [FieldOffset(2)]
                    public byte red;

                    [FieldOffset(3)]
                    public byte alpha;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0uchars@as_types@TestNestedTypes@@QAE@ABU012@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNestedTypes.AsTypes.Uchars> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNestedTypes.AsTypes.Uchars>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CommonTest.TestNestedTypes.AsTypes.Uchars __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Uchars(native.ToPointer(), skipVTables);
                }

                internal static global::CommonTest.TestNestedTypes.AsTypes.Uchars __CreateInstance(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal native, bool skipVTables = false)
                {
                    return new Uchars(native, skipVTables);
                }

                private static void* __CopyValue(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal));
                    *(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Uchars(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Uchars(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Uchars()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Uchars(global::CommonTest.TestNestedTypes.AsTypes.Uchars _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance) = *((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    global::CommonTest.TestNestedTypes.AsTypes.Uchars __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public byte Blue
                {
                    get
                    {
                        return ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->blue;
                    }

                    set
                    {
                        ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->blue = value;
                    }
                }

                public byte Green
                {
                    get
                    {
                        return ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->green;
                    }

                    set
                    {
                        ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->green = value;
                    }
                }

                public byte Red
                {
                    get
                    {
                        return ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->red;
                    }

                    set
                    {
                        ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->red = value;
                    }
                }

                public byte Alpha
                {
                    get
                    {
                        return ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->alpha;
                    }

                    set
                    {
                        ((global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) __Instance)->alpha = value;
                    }
                }
            }

            private AsTypes.__Internal __instance;
            internal AsTypes.__Internal __Instance { get { return __instance; } }

            internal static global::CommonTest.TestNestedTypes.AsTypes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new AsTypes(native.ToPointer(), skipVTables);
            }

            internal static global::CommonTest.TestNestedTypes.AsTypes __CreateInstance(global::CommonTest.TestNestedTypes.AsTypes.__Internal native, bool skipVTables = false)
            {
                return new AsTypes(native, skipVTables);
            }

            private AsTypes(global::CommonTest.TestNestedTypes.AsTypes.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private AsTypes(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::CommonTest.TestNestedTypes.AsTypes.__Internal*) native;
            }

            public AsTypes(global::CommonTest.TestNestedTypes.AsTypes _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public int AsInt
            {
                get
                {
                    return __instance.as_int;
                }

                set
                {
                    __instance.as_int = value;
                }
            }

            public global::CommonTest.TestNestedTypes.AsTypes.Uchars AsUchar
            {
                get
                {
                    return global::CommonTest.TestNestedTypes.AsTypes.Uchars.__CreateInstance(__instance.as_uchar);
                }

                set
                {
                    __instance.as_uchar = ReferenceEquals(value, null) ? new global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal() : *(global::CommonTest.TestNestedTypes.AsTypes.Uchars.__Internal*) value.__Instance;
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNestedTypes> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNestedTypes>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestNestedTypes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestNestedTypes(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestNestedTypes __CreateInstance(global::CommonTest.TestNestedTypes.__Internal native, bool skipVTables = false)
        {
            return new TestNestedTypes(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestNestedTypes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.__Internal));
            *(global::CommonTest.TestNestedTypes.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestNestedTypes(global::CommonTest.TestNestedTypes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestNestedTypes(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestNestedTypes()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestNestedTypes(global::CommonTest.TestNestedTypes _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNestedTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestNestedTypes.__Internal*) __Instance) = *((global::CommonTest.TestNestedTypes.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestNestedTypes __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasStdString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::Std.BasicString.__Internal s;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasStdString@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasStdString@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasStdString@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?testStdString@HasStdString@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z")]
            internal static extern global::Std.BasicString.__Internal TestStdString_0(global::System.IntPtr instance, global::Std.BasicString.__Internal s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getStdString@HasStdString@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
            internal static extern global::System.IntPtr GetStdString_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasStdString> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasStdString>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasStdString __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasStdString(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasStdString __CreateInstance(global::CommonTest.HasStdString.__Internal native, bool skipVTables = false)
        {
            return new HasStdString(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasStdString.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasStdString.__Internal));
            global::CommonTest.HasStdString.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasStdString(global::CommonTest.HasStdString.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasStdString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasStdString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasStdString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public HasStdString(global::CommonTest.HasStdString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasStdString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasStdString __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public string TestStdString(string s)
        {
            var __allocator0 = new global::Std.Allocator();
            var __basicString0 = new global::Std.BasicString(s, __allocator0);
            var __arg0 = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
            var __ret = __Internal.TestStdString_0((__Instance + __PointerAdjustment), __arg0);
            __basicString0.Dispose(false);
            __allocator0.Dispose();
            using (var __basicStringRet = global::Std.BasicString.__CreateInstance(__ret))
            {
                return __basicStringRet.CStr;
            }
        }

        public string S
        {
            get
            {
                return global::Std.BasicString.__CreateInstance(((global::CommonTest.HasStdString.__Internal*) __Instance)->s).CStr;
            }

            set
            {
                var __allocator0 = new global::Std.Allocator();
                var __basicString0 = new global::Std.BasicString(value, __allocator0);
                ((global::CommonTest.HasStdString.__Internal*) __Instance)->s = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
            }
        }

        public string StdString
        {
            get
            {
                var __ret = __Internal.GetStdString_0((__Instance + __PointerAdjustment));
                return global::Std.BasicString.__CreateInstance(__ret).CStr;
            }
        }
    }

    public unsafe partial class InternalCtorAmbiguity : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InternalCtorAmbiguity@@QAE@PAX@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr param);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InternalCtorAmbiguity@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.InternalCtorAmbiguity> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.InternalCtorAmbiguity>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.InternalCtorAmbiguity __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new InternalCtorAmbiguity(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.InternalCtorAmbiguity __CreateInstance(global::CommonTest.InternalCtorAmbiguity.__Internal native, bool skipVTables = false)
        {
            return new InternalCtorAmbiguity(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.InternalCtorAmbiguity.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.InternalCtorAmbiguity.__Internal));
            *(global::CommonTest.InternalCtorAmbiguity.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private InternalCtorAmbiguity(global::CommonTest.InternalCtorAmbiguity.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InternalCtorAmbiguity(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public InternalCtorAmbiguity(global::System.IntPtr param)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.InternalCtorAmbiguity.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), param);
        }

        public InternalCtorAmbiguity(global::CommonTest.InternalCtorAmbiguity _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.InternalCtorAmbiguity.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.InternalCtorAmbiguity.__Internal*) __Instance) = *((global::CommonTest.InternalCtorAmbiguity.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.InternalCtorAmbiguity __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.InternalCtorAmbiguity(global::System.IntPtr param)
        {
            return new global::CommonTest.InternalCtorAmbiguity(param);
        }
    }

    public unsafe partial class InvokesInternalCtorAmbiguity : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InvokesInternalCtorAmbiguity@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InvokesInternalCtorAmbiguity@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?InvokeInternalCtor@InvokesInternalCtorAmbiguity@@QAEPAVInternalCtorAmbiguity@@XZ")]
            internal static extern global::System.IntPtr InvokeInternalCtor_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.InvokesInternalCtorAmbiguity> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.InvokesInternalCtorAmbiguity>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.InvokesInternalCtorAmbiguity __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new InvokesInternalCtorAmbiguity(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.InvokesInternalCtorAmbiguity __CreateInstance(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal native, bool skipVTables = false)
        {
            return new InvokesInternalCtorAmbiguity(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal));
            *(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private InvokesInternalCtorAmbiguity(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InvokesInternalCtorAmbiguity(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public InvokesInternalCtorAmbiguity()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public InvokesInternalCtorAmbiguity(global::CommonTest.InvokesInternalCtorAmbiguity _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.InvokesInternalCtorAmbiguity.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.InvokesInternalCtorAmbiguity.__Internal*) __Instance) = *((global::CommonTest.InvokesInternalCtorAmbiguity.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.InvokesInternalCtorAmbiguity __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CommonTest.InternalCtorAmbiguity InvokeInternalCtor()
        {
            var __ret = __Internal.InvokeInternalCtor_0((__Instance + __PointerAdjustment));
            global::CommonTest.InternalCtorAmbiguity __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.InternalCtorAmbiguity.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CommonTest.InternalCtorAmbiguity) global::CommonTest.InternalCtorAmbiguity.NativeToManagedMap[__ret];
            else __result0 = global::CommonTest.InternalCtorAmbiguity.__CreateInstance(__ret);
            return __result0;
        }
    }

    public unsafe partial class HasFriend : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int m;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasFriend@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasFriend@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??H@YA?BVHasFriend@@ABV0@0@Z")]
            internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr f1, global::System.IntPtr f2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??G@YA?BVHasFriend@@ABV0@0@Z")]
            internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr f1, global::System.IntPtr f2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getM@HasFriend@@QAEHXZ")]
            internal static extern int GetM_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasFriend> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasFriend>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasFriend __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasFriend(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasFriend __CreateInstance(global::CommonTest.HasFriend.__Internal native, bool skipVTables = false)
        {
            return new HasFriend(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasFriend.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasFriend.__Internal));
            *(global::CommonTest.HasFriend.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasFriend(global::CommonTest.HasFriend.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasFriend(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasFriend(int m)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasFriend.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), m);
        }

        public HasFriend(global::CommonTest.HasFriend _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasFriend.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasFriend.__Internal*) __Instance) = *((global::CommonTest.HasFriend.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasFriend __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CommonTest.HasFriend(int m)
        {
            return new global::CommonTest.HasFriend(m);
        }

        public static global::CommonTest.HasFriend operator +(global::CommonTest.HasFriend f1, global::CommonTest.HasFriend f2)
        {
            if (ReferenceEquals(f1, null))
                throw new global::System.ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = f1.__Instance;
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = f2.__Instance;
            var __ret = new global::CommonTest.HasFriend.__Internal();
            __Internal.OperatorPlus_0(new IntPtr(&__ret), __arg0, __arg1);
            return global::CommonTest.HasFriend.__CreateInstance(__ret);
        }

        public static global::CommonTest.HasFriend operator -(global::CommonTest.HasFriend f1, global::CommonTest.HasFriend f2)
        {
            if (ReferenceEquals(f1, null))
                throw new global::System.ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = f1.__Instance;
            if (ReferenceEquals(f2, null))
                throw new global::System.ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = f2.__Instance;
            var __ret = new global::CommonTest.HasFriend.__Internal();
            __Internal.OperatorMinus_0(new IntPtr(&__ret), __arg0, __arg1);
            return global::CommonTest.HasFriend.__CreateInstance(__ret);
        }

        public int M
        {
            get
            {
                var __ret = __Internal.GetM_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class DifferentConstOverloads : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int i;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DifferentConstOverloads@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DifferentConstOverloads@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8DifferentConstOverloads@@QAE_NABV0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??9DifferentConstOverloads@@QAE_NABV0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8DifferentConstOverloads@@QBE_NH@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_1(global::System.IntPtr instance, int number);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DifferentConstOverloads> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DifferentConstOverloads>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.DifferentConstOverloads __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DifferentConstOverloads(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DifferentConstOverloads __CreateInstance(global::CommonTest.DifferentConstOverloads.__Internal native, bool skipVTables = false)
        {
            return new DifferentConstOverloads(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DifferentConstOverloads.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DifferentConstOverloads.__Internal));
            *(global::CommonTest.DifferentConstOverloads.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DifferentConstOverloads(global::CommonTest.DifferentConstOverloads.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DifferentConstOverloads(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DifferentConstOverloads()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DifferentConstOverloads.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public DifferentConstOverloads(global::CommonTest.DifferentConstOverloads _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DifferentConstOverloads.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.DifferentConstOverloads.__Internal*) __Instance) = *((global::CommonTest.DifferentConstOverloads.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.DifferentConstOverloads __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static bool operator ==(global::CommonTest.DifferentConstOverloads __op, global::CommonTest.DifferentConstOverloads other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual_0(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as DifferentConstOverloads;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::CommonTest.DifferentConstOverloads.__Internal*) __Instance).GetHashCode();
        }

        public static bool operator !=(global::CommonTest.DifferentConstOverloads __op, global::CommonTest.DifferentConstOverloads other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return !(__opNull && otherNull);
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorExclaimEqual_0(__arg0, __arg1);
            return __ret;
        }

        public static bool operator !=(global::CommonTest.DifferentConstOverloads __op, int number)
        {
            return !(__op == number);
        }

        public static bool operator ==(global::CommonTest.DifferentConstOverloads __op, int number)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool numberNull = ReferenceEquals(number, null);
            if (__opNull || numberNull)
                return __opNull && numberNull;
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorEqualEqual_1(__arg0, number);
            return __ret;
        }
    }

    public unsafe partial class TestNamingAnonymousTypesInUnion : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CommonTest.TestNamingAnonymousTypesInUnion._.__Internal ct;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestNamingAnonymousTypesInUnion@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 1)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::CommonTest.TestNamingAnonymousTypesInUnion._.__.__Internal argb;

                [FieldOffset(0)]
                internal global::CommonTest.TestNamingAnonymousTypesInUnion._.___.__Internal ahsv;

                [FieldOffset(0)]
                internal global::CommonTest.TestNamingAnonymousTypesInUnion._.____.__Internal acmyk;
            }

            public unsafe partial class __
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }
            }

            public unsafe partial class ___
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }
            }

            public unsafe partial class ____
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                }
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNamingAnonymousTypesInUnion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestNamingAnonymousTypesInUnion>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestNamingAnonymousTypesInUnion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestNamingAnonymousTypesInUnion(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestNamingAnonymousTypesInUnion __CreateInstance(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal native, bool skipVTables = false)
        {
            return new TestNamingAnonymousTypesInUnion(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal));
            *(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestNamingAnonymousTypesInUnion(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestNamingAnonymousTypesInUnion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestNamingAnonymousTypesInUnion()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestNamingAnonymousTypesInUnion(global::CommonTest.TestNamingAnonymousTypesInUnion _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal*) __Instance) = *((global::CommonTest.TestNamingAnonymousTypesInUnion.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestNamingAnonymousTypesInUnion __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class RefTypeClassPassTry : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0RefTypeClassPassTry@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.RefTypeClassPassTry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.RefTypeClassPassTry>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.RefTypeClassPassTry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new RefTypeClassPassTry(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.RefTypeClassPassTry __CreateInstance(global::CommonTest.RefTypeClassPassTry.__Internal native, bool skipVTables = false)
        {
            return new RefTypeClassPassTry(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.RefTypeClassPassTry.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.RefTypeClassPassTry.__Internal));
            *(global::CommonTest.RefTypeClassPassTry.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RefTypeClassPassTry(global::CommonTest.RefTypeClassPassTry.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RefTypeClassPassTry(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RefTypeClassPassTry()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.RefTypeClassPassTry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RefTypeClassPassTry(global::CommonTest.RefTypeClassPassTry _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.RefTypeClassPassTry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.RefTypeClassPassTry.__Internal*) __Instance) = *((global::CommonTest.RefTypeClassPassTry.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.RefTypeClassPassTry __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial struct ValueTypeArrays
    {
        [StructLayout(LayoutKind.Explicit, Size = 52)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public fixed float firstValueTypeArrray[5];

            [FieldOffset(20)]
            public fixed int secondValueTypeArray[5];

            [FieldOffset(40)]
            public fixed sbyte thirdValueTypeArray[5];

            [FieldOffset(48)]
            public uint size;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ValueTypeArrays@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private ValueTypeArrays.__Internal __instance;
        internal ValueTypeArrays.__Internal __Instance { get { return __instance; } }

        internal static global::CommonTest.ValueTypeArrays __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ValueTypeArrays(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ValueTypeArrays __CreateInstance(global::CommonTest.ValueTypeArrays.__Internal native, bool skipVTables = false)
        {
            return new ValueTypeArrays(native, skipVTables);
        }

        private ValueTypeArrays(global::CommonTest.ValueTypeArrays.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ValueTypeArrays(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CommonTest.ValueTypeArrays.__Internal*) native;
        }

        public ValueTypeArrays(global::CommonTest.ValueTypeArrays _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public float[] FirstValueTypeArrray
        {
            get
            {
                fixed (float* __arrPtr = __instance.firstValueTypeArrray)
                {
                    float[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new float[5];
                        for (int i = 0; i < 5; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (float* __arrPtr = __instance.firstValueTypeArrray)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 5; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public int[] SecondValueTypeArray
        {
            get
            {
                fixed (int* __arrPtr = __instance.secondValueTypeArray)
                {
                    int[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new int[5];
                        for (int i = 0; i < 5; i++)
                            __value[i] = __arrPtr[i];
                    }
                    return __value;
                }
            }

            set
            {
                fixed (int* __arrPtr = __instance.secondValueTypeArray)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 5; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public char[] ThirdValueTypeArray
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.thirdValueTypeArray)
                {
                    char[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new char[5];
                        for (int i = 0; i < 5; i++)
                            __value[i] = global::System.Convert.ToChar(__arrPtr[i]);
                    }
                    return __value;
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.thirdValueTypeArray)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 5; i++)
                            __arrPtr[i] = global::System.Convert.ToSByte(value[i]);
                    }
                }
            }
        }

        public uint Size
        {
            get
            {
                return __instance.size;
            }

            set
            {
                __instance.size = value;
            }
        }
    }

    public unsafe partial class HasVirtualProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasVirtualProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasVirtualProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasVirtualProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualProperty(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasVirtualProperty __CreateInstance(global::CommonTest.HasVirtualProperty.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualProperty(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasVirtualProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualProperty.__Internal));
            global::CommonTest.HasVirtualProperty.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualProperty(global::CommonTest.HasVirtualProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasVirtualProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.HasVirtualProperty");
        }

        public HasVirtualProperty(global::CommonTest.HasVirtualProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.HasVirtualProperty");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasVirtualProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.HasVirtualProperty.__Internal*) __Instance)->vfptr_HasVirtualProperty = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetProperty_0Delegate = (global::CommonTest.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Action_IntPtr_int));
                ___SetProperty_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // int getProperty()
        private static global::CommonTest.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.HasVirtualProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int target)
        private static global::CommonTest.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int target)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.HasVirtualProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = target;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ChangedAccessOfInheritedProperty : global::CommonTest.HasVirtualProperty, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ChangedAccessOfInheritedProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ChangedAccessOfInheritedProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.ChangedAccessOfInheritedProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ChangedAccessOfInheritedProperty(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ChangedAccessOfInheritedProperty __CreateInstance(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal native, bool skipVTables = false)
        {
            return new ChangedAccessOfInheritedProperty(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal));
            global::CommonTest.ChangedAccessOfInheritedProperty.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ChangedAccessOfInheritedProperty(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ChangedAccessOfInheritedProperty(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ChangedAccessOfInheritedProperty()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.ChangedAccessOfInheritedProperty");
        }

        public ChangedAccessOfInheritedProperty(global::CommonTest.ChangedAccessOfInheritedProperty _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ChangedAccessOfInheritedProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.ChangedAccessOfInheritedProperty");
        }

        public override int Property
        {
            get
            {
                return base.Property;
            }

            set
            {
                base.Property = value;
            }
        }

        #region Virtual table interop

        // int getProperty()
        private static global::CommonTest.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.ChangedAccessOfInheritedProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int value)
        private static global::CommonTest.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.ChangedAccessOfInheritedProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = value;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Empty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Empty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Empty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Empty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.Empty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Empty(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.Empty __CreateInstance(global::CommonTest.Empty.__Internal native, bool skipVTables = false)
        {
            return new Empty(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.Empty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Empty.__Internal));
            *(global::CommonTest.Empty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Empty(global::CommonTest.Empty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Empty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Empty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Empty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Empty(global::CommonTest.Empty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Empty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.Empty.__Internal*) __Instance) = *((global::CommonTest.Empty.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.Empty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class ReturnsEmpty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ReturnsEmpty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getEmpty@ReturnsEmpty@@QAE?AVEmpty@@XZ")]
            internal static extern void GetEmpty_0(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ReturnsEmpty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.ReturnsEmpty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.ReturnsEmpty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ReturnsEmpty(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ReturnsEmpty __CreateInstance(global::CommonTest.ReturnsEmpty.__Internal native, bool skipVTables = false)
        {
            return new ReturnsEmpty(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.ReturnsEmpty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsEmpty.__Internal));
            *(global::CommonTest.ReturnsEmpty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ReturnsEmpty(global::CommonTest.ReturnsEmpty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ReturnsEmpty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ReturnsEmpty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsEmpty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ReturnsEmpty(global::CommonTest.ReturnsEmpty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.ReturnsEmpty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.ReturnsEmpty.__Internal*) __Instance) = *((global::CommonTest.ReturnsEmpty.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.ReturnsEmpty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CommonTest.Empty Empty
        {
            get
            {
                var __ret = new global::CommonTest.Empty.__Internal();
                __Internal.GetEmpty_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::CommonTest.Empty.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial struct ValueTypeClassPassTry
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ValueTypeClassPassTry@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private ValueTypeClassPassTry.__Internal __instance;
        internal ValueTypeClassPassTry.__Internal __Instance { get { return __instance; } }

        internal static global::CommonTest.ValueTypeClassPassTry __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ValueTypeClassPassTry(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.ValueTypeClassPassTry __CreateInstance(global::CommonTest.ValueTypeClassPassTry.__Internal native, bool skipVTables = false)
        {
            return new ValueTypeClassPassTry(native, skipVTables);
        }

        private ValueTypeClassPassTry(global::CommonTest.ValueTypeClassPassTry.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ValueTypeClassPassTry(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CommonTest.ValueTypeClassPassTry.__Internal*) native;
        }

        public ValueTypeClassPassTry(global::CommonTest.ValueTypeClassPassTry _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }
    }

    public unsafe partial class HasProblematicFields : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public byte b;

            [FieldOffset(1)]
            public sbyte c;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProblematicFields@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProblematicFields@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasProblematicFields> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasProblematicFields>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasProblematicFields __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasProblematicFields(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasProblematicFields __CreateInstance(global::CommonTest.HasProblematicFields.__Internal native, bool skipVTables = false)
        {
            return new HasProblematicFields(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasProblematicFields.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProblematicFields.__Internal));
            *(global::CommonTest.HasProblematicFields.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasProblematicFields(global::CommonTest.HasProblematicFields.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasProblematicFields(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasProblematicFields()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProblematicFields.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public HasProblematicFields(global::CommonTest.HasProblematicFields _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProblematicFields.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasProblematicFields.__Internal*) __Instance) = *((global::CommonTest.HasProblematicFields.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasProblematicFields __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public bool B
        {
            get
            {
                return ((global::CommonTest.HasProblematicFields.__Internal*) __Instance)->b != 0;
            }

            set
            {
                ((global::CommonTest.HasProblematicFields.__Internal*) __Instance)->b = (byte) (value ? 1 : 0);
            }
        }

        public char C
        {
            get
            {
                return global::System.Convert.ToChar(((global::CommonTest.HasProblematicFields.__Internal*) __Instance)->c);
            }

            set
            {
                ((global::CommonTest.HasProblematicFields.__Internal*) __Instance)->c = global::System.Convert.ToSByte(value);
            }
        }
    }

    public unsafe partial class HasVirtualReturningHasProblematicFields : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualReturningHasProblematicFields;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualReturningHasProblematicFields@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualReturningHasProblematicFields@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasVirtualReturningHasProblematicFields> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasVirtualReturningHasProblematicFields>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasVirtualReturningHasProblematicFields __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualReturningHasProblematicFields(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasVirtualReturningHasProblematicFields __CreateInstance(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualReturningHasProblematicFields(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal));
            global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualReturningHasProblematicFields(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualReturningHasProblematicFields(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasVirtualReturningHasProblematicFields()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.HasVirtualReturningHasProblematicFields");
        }

        public HasVirtualReturningHasProblematicFields(global::CommonTest.HasVirtualReturningHasProblematicFields _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.HasVirtualReturningHasProblematicFields");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasVirtualReturningHasProblematicFields __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.HasVirtualReturningHasProblematicFields.__Internal*) __Instance)->vfptr_HasVirtualReturningHasProblematicFields = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual global::CommonTest.HasProblematicFields ReturnsProblematicFields
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___ReturnsProblematicFields_0Delegate = (global::CommonTest.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Action_IntPtr_IntPtr));
                var __ret = new global::CommonTest.HasProblematicFields.__Internal();
                ___ReturnsProblematicFields_0Delegate((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::CommonTest.HasProblematicFields.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // HasProblematicFields returnsProblematicFields()
        private static global::CommonTest.Delegates.Action_IntPtr_IntPtr _ReturnsProblematicFields_0DelegateInstance;

        private static void _ReturnsProblematicFields_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.HasVirtualReturningHasProblematicFields) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ReturnsProblematicFields;
            *(global::CommonTest.HasProblematicFields.__Internal*) @return = ReferenceEquals(__ret, null) ? new global::CommonTest.HasProblematicFields.__Internal() : *(global::CommonTest.HasProblematicFields.__Internal*) __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ReturnsProblematicFields_0DelegateInstance += _ReturnsProblematicFields_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ReturnsProblematicFields_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class BaseClassVirtual : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BaseClassVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BaseClassVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getBase@BaseClassVirtual@@SA?AV1@XZ")]
            internal static extern void GetBase_0(global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.BaseClassVirtual> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.BaseClassVirtual>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.BaseClassVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new BaseClassVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.BaseClassVirtual __CreateInstance(global::CommonTest.BaseClassVirtual.__Internal native, bool skipVTables = false)
        {
            return new BaseClassVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.BaseClassVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.BaseClassVirtual.__Internal));
            global::CommonTest.BaseClassVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private BaseClassVirtual(global::CommonTest.BaseClassVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BaseClassVirtual(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public BaseClassVirtual()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.BaseClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.BaseClassVirtual");
        }

        public BaseClassVirtual(global::CommonTest.BaseClassVirtual _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.BaseClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.BaseClassVirtual");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.BaseClassVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.BaseClassVirtual.__Internal*) __Instance)->vfptr_BaseClassVirtual = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual int RetInt(global::CommonTest.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___RetInt_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            var __ret = ___RetInt_0Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        public static global::CommonTest.BaseClassVirtual Base
        {
            get
            {
                var __ret = new global::CommonTest.BaseClassVirtual.__Internal();
                __Internal.GetBase_0(new IntPtr(&__ret));
                return global::CommonTest.BaseClassVirtual.__CreateInstance(__ret);
            }
        }

        #region Virtual table interop

        // int retInt(const Foo1& foo)
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.BaseClassVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class DerivedClassVirtual : global::CommonTest.BaseClassVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.DerivedClassVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedClassVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DerivedClassVirtual __CreateInstance(global::CommonTest.DerivedClassVirtual.__Internal native, bool skipVTables = false)
        {
            return new DerivedClassVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DerivedClassVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassVirtual.__Internal));
            global::CommonTest.DerivedClassVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DerivedClassVirtual(global::CommonTest.DerivedClassVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivedClassVirtual(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public DerivedClassVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassVirtual");
        }

        public DerivedClassVirtual(global::CommonTest.DerivedClassVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassVirtual");
        }

        public override int RetInt(global::CommonTest.Foo foo)
        {
            return base.RetInt(foo);
        }

        #region Virtual table interop

        // int retInt(const Foo2& foo)
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.DerivedClassVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class DerivedClassAbstractVirtual : global::CommonTest.DerivedClassVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassAbstractVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassAbstractVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.DerivedClassAbstractVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedClassAbstractVirtualInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DerivedClassAbstractVirtual __CreateInstance(global::CommonTest.DerivedClassAbstractVirtual.__Internal native, bool skipVTables = false)
        {
            return new DerivedClassAbstractVirtualInternal(native, skipVTables);
        }

        protected DerivedClassAbstractVirtual(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected DerivedClassAbstractVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassAbstractVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassAbstractVirtual");
        }

        protected DerivedClassAbstractVirtual(global::CommonTest.DerivedClassAbstractVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassAbstractVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassAbstractVirtual");
        }

        public override void Dispose(bool disposing)
        {
            global::CommonTest.BaseClassVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.DerivedClassAbstractVirtual.__Internal*) __Instance)->vfptr_BaseClassVirtual = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override abstract int RetInt(global::CommonTest.Foo foo);

        #region Virtual table interop

        // int retInt(const Foo& foo) = 0
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.DerivedClassAbstractVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class DerivedClassOverrideAbstractVirtual : global::CommonTest.DerivedClassAbstractVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassOverrideAbstractVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedClassOverrideAbstractVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.DerivedClassOverrideAbstractVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedClassOverrideAbstractVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DerivedClassOverrideAbstractVirtual __CreateInstance(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal native, bool skipVTables = false)
        {
            return new DerivedClassOverrideAbstractVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal));
            global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DerivedClassOverrideAbstractVirtual(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivedClassOverrideAbstractVirtual(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public DerivedClassOverrideAbstractVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassOverrideAbstractVirtual");
        }

        public DerivedClassOverrideAbstractVirtual(global::CommonTest.DerivedClassOverrideAbstractVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassOverrideAbstractVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.DerivedClassOverrideAbstractVirtual");
        }

        public override int RetInt(global::CommonTest.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___RetInt_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            var __ret = ___RetInt_0Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }

        #region Virtual table interop

        // int retInt(const Foo& foo)
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.DerivedClassOverrideAbstractVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class BufferForVirtualFunction : global::CommonTest.BaseClassVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BufferForVirtualFunction@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0BufferForVirtualFunction@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.BufferForVirtualFunction __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new BufferForVirtualFunction(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.BufferForVirtualFunction __CreateInstance(global::CommonTest.BufferForVirtualFunction.__Internal native, bool skipVTables = false)
        {
            return new BufferForVirtualFunction(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.BufferForVirtualFunction.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.BufferForVirtualFunction.__Internal));
            global::CommonTest.BufferForVirtualFunction.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private BufferForVirtualFunction(global::CommonTest.BufferForVirtualFunction.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BufferForVirtualFunction(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public BufferForVirtualFunction()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.BufferForVirtualFunction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.BufferForVirtualFunction");
        }

        public BufferForVirtualFunction(global::CommonTest.BufferForVirtualFunction _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.BufferForVirtualFunction.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.BufferForVirtualFunction");
        }

        #region Virtual table interop

        // int retInt(const Foo1& foo)
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.BufferForVirtualFunction) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class OverridesNonDirectVirtual : global::CommonTest.BufferForVirtualFunction, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_BaseClassVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridesNonDirectVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridesNonDirectVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CommonTest.OverridesNonDirectVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverridesNonDirectVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.OverridesNonDirectVirtual __CreateInstance(global::CommonTest.OverridesNonDirectVirtual.__Internal native, bool skipVTables = false)
        {
            return new OverridesNonDirectVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.OverridesNonDirectVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.OverridesNonDirectVirtual.__Internal));
            global::CommonTest.OverridesNonDirectVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OverridesNonDirectVirtual(global::CommonTest.OverridesNonDirectVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OverridesNonDirectVirtual(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public OverridesNonDirectVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.OverridesNonDirectVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.OverridesNonDirectVirtual");
        }

        public OverridesNonDirectVirtual(global::CommonTest.OverridesNonDirectVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.OverridesNonDirectVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.OverridesNonDirectVirtual");
        }

        public override int RetInt(global::CommonTest.Foo foo)
        {
            return base.RetInt(foo);
        }

        #region Virtual table interop

        // int retInt(const Foo& foo)
        private static global::CommonTest.Delegates.Func_int_IntPtr_IntPtr _RetInt_0DelegateInstance;

        private static int _RetInt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.OverridesNonDirectVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CommonTest.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CommonTest.Foo) global::CommonTest.Foo.NativeToManagedMap[foo];
            else __result0 = global::CommonTest.Foo.__CreateInstance(foo);
            var __ret = __target.RetInt(__result0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _RetInt_0DelegateInstance += _RetInt_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_RetInt_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class AbstractWithVirtualDtor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractWithVirtualDtor;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractWithVirtualDtor@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractWithVirtualDtor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1AbstractWithVirtualDtor@@UAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.AbstractWithVirtualDtor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.AbstractWithVirtualDtor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.AbstractWithVirtualDtor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractWithVirtualDtorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.AbstractWithVirtualDtor __CreateInstance(global::CommonTest.AbstractWithVirtualDtor.__Internal native, bool skipVTables = false)
        {
            return new AbstractWithVirtualDtorInternal(native, skipVTables);
        }

        protected AbstractWithVirtualDtor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected AbstractWithVirtualDtor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractWithVirtualDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CommonTest.AbstractWithVirtualDtor");
        }

        protected AbstractWithVirtualDtor(global::CommonTest.AbstractWithVirtualDtor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractWithVirtualDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CommonTest.AbstractWithVirtualDtor");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.AbstractWithVirtualDtor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CommonTest.AbstractWithVirtualDtor.__Internal*) __Instance)->vfptr_AbstractWithVirtualDtor = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                if (__slot != null)
                {
                    var ___dtor_0Delegate = (global::CommonTest.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Action_IntPtr_int));
                    ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract void Abstract();

        #region Virtual table interop

        // virtual ~AbstractWithVirtualDtor()
        private static global::CommonTest.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.AbstractWithVirtualDtor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void abstract() = 0
        private static global::CommonTest.Delegates.Action_IntPtr _Abstract_0DelegateInstance;

        private static void _Abstract_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CommonTest.AbstractWithVirtualDtor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Abstract();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Abstract_0DelegateInstance += _Abstract_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Abstract_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class NonTrivialDtorBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0NonTrivialDtorBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0NonTrivialDtorBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1NonTrivialDtorBase@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.NonTrivialDtorBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.NonTrivialDtorBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.NonTrivialDtorBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new NonTrivialDtorBase(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.NonTrivialDtorBase __CreateInstance(global::CommonTest.NonTrivialDtorBase.__Internal native, bool skipVTables = false)
        {
            return new NonTrivialDtorBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.NonTrivialDtorBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtorBase.__Internal));
            *(global::CommonTest.NonTrivialDtorBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private NonTrivialDtorBase(global::CommonTest.NonTrivialDtorBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected NonTrivialDtorBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public NonTrivialDtorBase()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtorBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public NonTrivialDtorBase(global::CommonTest.NonTrivialDtorBase _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtorBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.NonTrivialDtorBase.__Internal*) __Instance) = *((global::CommonTest.NonTrivialDtorBase.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.NonTrivialDtorBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class NonTrivialDtor : global::CommonTest.NonTrivialDtorBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public new partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0NonTrivialDtor@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0NonTrivialDtor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1NonTrivialDtor@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getDtorCalled@NonTrivialDtor@@SA_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool dtorCalled_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?setDtorCalled@NonTrivialDtor@@SAX_N@Z")]
            internal static extern void SetDtorCalled_0(bool value);
        }

        internal static new global::CommonTest.NonTrivialDtor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new NonTrivialDtor(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.NonTrivialDtor __CreateInstance(global::CommonTest.NonTrivialDtor.__Internal native, bool skipVTables = false)
        {
            return new NonTrivialDtor(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.NonTrivialDtor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtor.__Internal));
            *(global::CommonTest.NonTrivialDtor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private NonTrivialDtor(global::CommonTest.NonTrivialDtor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected NonTrivialDtor(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public NonTrivialDtor()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public NonTrivialDtor(global::CommonTest.NonTrivialDtor _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.NonTrivialDtor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.NonTrivialDtor.__Internal*) __Instance) = *((global::CommonTest.NonTrivialDtor.__Internal*) _0.__Instance);
        }

        public override void Dispose(bool disposing)
        {
            global::CommonTest.NonTrivialDtorBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static bool dtorCalled
        {
            get
            {
                var __ret = __Internal.dtorCalled_0();
                return __ret;
            }

            set
            {
                __Internal.SetDtorCalled_0(value);
            }
        }
    }

    public unsafe partial class DerivedFromTemplateInstantiationWithVirtual : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_TemplateWithVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedFromTemplateInstantiationWithVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivedFromTemplateInstantiationWithVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DerivedFromTemplateInstantiationWithVirtual> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.DerivedFromTemplateInstantiationWithVirtual>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.DerivedFromTemplateInstantiationWithVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivedFromTemplateInstantiationWithVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.DerivedFromTemplateInstantiationWithVirtual __CreateInstance(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal native, bool skipVTables = false)
        {
            return new DerivedFromTemplateInstantiationWithVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal));
            global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private DerivedFromTemplateInstantiationWithVirtual(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivedFromTemplateInstantiationWithVirtual(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DerivedFromTemplateInstantiationWithVirtual()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public DerivedFromTemplateInstantiationWithVirtual(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedFromTemplateInstantiationWithVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.DerivedFromTemplateInstantiationWithVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial struct UnionT
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int c;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0union_t@@QAE@ABT0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _1);
        }

        private UnionT.__Internal __instance;
        internal UnionT.__Internal __Instance { get { return __instance; } }

        internal static global::CommonTest.UnionT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new UnionT(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.UnionT __CreateInstance(global::CommonTest.UnionT.__Internal native, bool skipVTables = false)
        {
            return new UnionT(native, skipVTables);
        }

        private UnionT(global::CommonTest.UnionT.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private UnionT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CommonTest.UnionT.__Internal*) native;
        }

        public UnionT(global::CommonTest.UnionT _1)
            : this()
        {
            var ____arg0 = _1.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public int C
        {
            get
            {
                return __instance.c;
            }

            set
            {
                __instance.c = value;
            }
        }
    }

    public unsafe partial class HasProtectedEnum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProtectedEnum@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProtectedEnum@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?function@HasProtectedEnum@@IAEXW4ProtectedEnum@1@@Z")]
            internal static extern void Function_0(global::System.IntPtr instance, global::CommonTest.HasProtectedEnum.ProtectedEnum param);
        }

        protected internal enum ProtectedEnum
        {
            Member1 = 0,
            Member2 = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasProtectedEnum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasProtectedEnum>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasProtectedEnum __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasProtectedEnum(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasProtectedEnum __CreateInstance(global::CommonTest.HasProtectedEnum.__Internal native, bool skipVTables = false)
        {
            return new HasProtectedEnum(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasProtectedEnum.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProtectedEnum.__Internal));
            *(global::CommonTest.HasProtectedEnum.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasProtectedEnum(global::CommonTest.HasProtectedEnum.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasProtectedEnum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasProtectedEnum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProtectedEnum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public HasProtectedEnum(global::CommonTest.HasProtectedEnum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasProtectedEnum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasProtectedEnum.__Internal*) __Instance) = *((global::CommonTest.HasProtectedEnum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasProtectedEnum __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        protected void Function(global::CommonTest.HasProtectedEnum.ProtectedEnum param)
        {
            __Internal.Function_0((__Instance + __PointerAdjustment), param);
        }
    }

    public unsafe partial class TestsTypes : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr FunctionNoProto;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestsTypes@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestsTypes> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.TestsTypes>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.TestsTypes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestsTypes(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.TestsTypes __CreateInstance(global::CommonTest.TestsTypes.__Internal native, bool skipVTables = false)
        {
            return new TestsTypes(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.TestsTypes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestsTypes.__Internal));
            *(global::CommonTest.TestsTypes.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestsTypes(global::CommonTest.TestsTypes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestsTypes(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestsTypes()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestsTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestsTypes(global::CommonTest.TestsTypes _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.TestsTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.TestsTypes.__Internal*) __Instance) = *((global::CommonTest.TestsTypes.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.TestsTypes __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class UsesSpecialisationOfVoid : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr s;

            [FieldOffset(4)]
            public global::System.IntPtr h;

            [FieldOffset(8)]
            internal global::CommonTest.SpecialisesVoid.__Internalc__S_SpecialisesVoid__I i;

            [FieldOffset(12)]
            internal global::CommonTest.SpecialisesVoid.__Internalc__S_SpecialisesVoid__L l;

            [FieldOffset(16)]
            internal global::CommonTest.SpecialisesVoid.__Internalc__S_SpecialisesVoid__i u;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0UsesSpecialisationOfVoid@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.UsesSpecialisationOfVoid> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.UsesSpecialisationOfVoid>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.UsesSpecialisationOfVoid __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new UsesSpecialisationOfVoid(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.UsesSpecialisationOfVoid __CreateInstance(global::CommonTest.UsesSpecialisationOfVoid.__Internal native, bool skipVTables = false)
        {
            return new UsesSpecialisationOfVoid(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.UsesSpecialisationOfVoid.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.UsesSpecialisationOfVoid.__Internal));
            *(global::CommonTest.UsesSpecialisationOfVoid.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UsesSpecialisationOfVoid(global::CommonTest.UsesSpecialisationOfVoid.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UsesSpecialisationOfVoid(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public UsesSpecialisationOfVoid()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.UsesSpecialisationOfVoid.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public UsesSpecialisationOfVoid(global::CommonTest.UsesSpecialisationOfVoid _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.UsesSpecialisationOfVoid.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.UsesSpecialisationOfVoid.__Internal*) __Instance) = *((global::CommonTest.UsesSpecialisationOfVoid.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.UsesSpecialisationOfVoid __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe abstract partial class HasAbstractOperator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasAbstractOperator;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasAbstractOperator@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasAbstractOperator@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasAbstractOperator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasAbstractOperator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasAbstractOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasAbstractOperatorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasAbstractOperator __CreateInstance(global::CommonTest.HasAbstractOperator.__Internal native, bool skipVTables = false)
        {
            return new HasAbstractOperatorInternal(native, skipVTables);
        }

        protected HasAbstractOperator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        protected HasAbstractOperator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasAbstractOperator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        protected HasAbstractOperator(global::CommonTest.HasAbstractOperator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasAbstractOperator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasAbstractOperator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasSystemBase : global::Std.BasicString, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::Std.CompressedPair.__Internalc__N_std_S__Compressed_pair____N_std_S__Wrap_alloc____N_std_S_allocator__C___N_std_S__String_val____N_std_S__Simple_types__C_Vb1 _Mypair;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSystemBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSystemBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasSystemBase@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        internal static new global::CommonTest.HasSystemBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasSystemBase(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasSystemBase __CreateInstance(global::CommonTest.HasSystemBase.__Internal native, bool skipVTables = false)
        {
            return new HasSystemBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasSystemBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasSystemBase.__Internal));
            global::CommonTest.HasSystemBase.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasSystemBase(global::CommonTest.HasSystemBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasSystemBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasSystemBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasSystemBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public override void Dispose(bool disposing)
        {
            global::Std.BasicString __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasLongDoubles : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasLongDoubles@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasLongDoubles> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasLongDoubles>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasLongDoubles __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasLongDoubles(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasLongDoubles __CreateInstance(global::CommonTest.HasLongDoubles.__Internal native, bool skipVTables = false)
        {
            return new HasLongDoubles(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasLongDoubles.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasLongDoubles.__Internal));
            *(global::CommonTest.HasLongDoubles.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasLongDoubles(global::CommonTest.HasLongDoubles.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasLongDoubles(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasLongDoubles()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasLongDoubles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HasLongDoubles(global::CommonTest.HasLongDoubles _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasLongDoubles.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasLongDoubles.__Internal*) __Instance) = *((global::CommonTest.HasLongDoubles.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasLongDoubles __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasOverloadsWithDifferentPointerKindsToSameType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverloadsWithDifferentPointerKindsToSameType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverloadsWithDifferentPointerKindsToSameType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasOverloadsWithDifferentPointerKindsToSameType@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?overload@HasOverloadsWithDifferentPointerKindsToSameType@@QAEXAAH@Z")]
            internal static extern void Overload_0(global::System.IntPtr instance, int* i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?dispose@HasOverloadsWithDifferentPointerKindsToSameType@@QAEXXZ")]
            internal static extern void dispose_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasOverloadsWithDifferentPointerKindsToSameType(native.ToPointer(), skipVTables);
        }

        internal static global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType __CreateInstance(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal native, bool skipVTables = false)
        {
            return new HasOverloadsWithDifferentPointerKindsToSameType(native, skipVTables);
        }

        private static void* __CopyValue(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal));
            *(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasOverloadsWithDifferentPointerKindsToSameType(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasOverloadsWithDifferentPointerKindsToSameType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasOverloadsWithDifferentPointerKindsToSameType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public HasOverloadsWithDifferentPointerKindsToSameType(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal*) __Instance) = *((global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CommonTest.HasOverloadsWithDifferentPointerKindsToSameType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void Overload(ref int i)
        {
            fixed (int* __refParamPtr0 = &i)
            {
                var __arg0 = __refParamPtr0;
                __Internal.Overload_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public void dispose()
        {
            __Internal.dispose_0((__Instance + __PointerAdjustment));
        }
    }

    public unsafe partial class AbstractFooInternal : global::CommonTest.AbstractFoo, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.AbstractFoo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractFoo.__Internal));
            *(global::CommonTest.AbstractFoo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractFooInternal(global::CommonTest.AbstractFoo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractFooInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int PureFunction(int i = 0)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___PureFunction_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_int));
            var __ret = ___PureFunction_0Delegate((__Instance + __PointerAdjustment), i);
            return __ret;
        }

        public override int PureFunction2(ref bool ok)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___PureFunction2_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_boolPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_boolPtr));
            fixed (bool* __refParamPtr0 = &ok)
            {
                var __arg0 = __refParamPtr0;
                var __ret = ___PureFunction2_0Delegate((__Instance + __PointerAdjustment), __arg0);
                return __ret;
            }
        }

        public override int PureFunction2()
        {
            bool param0 = false;
            return PureFunction2(ref param0);
        }

        public override int PureFunction1
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___PureFunction1_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr));
                var __ret = ___PureFunction1_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class ExceptionInternal : global::CommonTest.Exception, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.Exception.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Exception.__Internal));
            *(global::CommonTest.Exception.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal ExceptionInternal(global::CommonTest.Exception.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal ExceptionInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override global::CommonTest.Exception Clone()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___Clone_0Delegate = (global::CommonTest.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_IntPtr_IntPtr));
            var __ret = ___Clone_0Delegate((__Instance + __PointerAdjustment));
            global::CommonTest.Exception __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CommonTest.Exception.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CommonTest.Exception) global::CommonTest.Exception.NativeToManagedMap[__ret];
            else __result0 = global::CommonTest.Exception.__CreateInstance(__ret);
            return __result0;
        }
    }

    public unsafe partial class PureDtorInternal : global::CommonTest.PureDtor, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.PureDtor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.PureDtor.__Internal));
            *(global::CommonTest.PureDtor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal PureDtorInternal(global::CommonTest.PureDtor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal PureDtorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }
    }

    public unsafe partial class DerivedClassAbstractVirtualInternal : global::CommonTest.DerivedClassAbstractVirtual, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.DerivedClassAbstractVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.DerivedClassAbstractVirtual.__Internal));
            *(global::CommonTest.DerivedClassAbstractVirtual.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal DerivedClassAbstractVirtualInternal(global::CommonTest.DerivedClassAbstractVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal DerivedClassAbstractVirtualInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int RetInt(global::CommonTest.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___RetInt_0Delegate = (global::CommonTest.Delegates.Func_int_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Func_int_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            var __ret = ___RetInt_0Delegate((__Instance + __PointerAdjustment), __arg0);
            return __ret;
        }
    }

    public unsafe partial class AbstractWithVirtualDtorInternal : global::CommonTest.AbstractWithVirtualDtor, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.AbstractWithVirtualDtor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.AbstractWithVirtualDtor.__Internal));
            *(global::CommonTest.AbstractWithVirtualDtor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractWithVirtualDtorInternal(global::CommonTest.AbstractWithVirtualDtor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractWithVirtualDtorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Abstract()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___Abstract_0Delegate = (global::CommonTest.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Action_IntPtr));
            ___Abstract_0Delegate((__Instance + __PointerAdjustment));
        }
    }

    public unsafe partial class HasAbstractOperatorInternal : global::CommonTest.HasAbstractOperator, IDisposable
    {
        private static void* __CopyValue(global::CommonTest.HasAbstractOperator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.HasAbstractOperator.__Internal));
            *(global::CommonTest.HasAbstractOperator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal HasAbstractOperatorInternal(global::CommonTest.HasAbstractOperator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal HasAbstractOperatorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }
    }

    public unsafe partial class Common
    {
        public partial struct __Internal
        {
        }

        public static int Expr
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?Expr@@3HA");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("Common.Native.dll", "?Expr@@3HA");
                *__ptr = value;
            }
        }
    }

    namespace DelegateNamespace
    {
        public unsafe partial class Common
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?f2@DelegateNamespace@@YAXP6AXXZ@Z")]
                internal static extern void F2_0(global::System.IntPtr _0);
            }

            public static void F2(global::CommonTest.DelegateNamespace.__AnonymousDelegate0 _0)
            {
                var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
                __Internal.F2_0(__arg0);
            }
        }

        namespace Nested
        {
            public unsafe partial class Common
            {
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?f1@Nested@DelegateNamespace@@YAXP6AXXZ@Z")]
                    internal static extern void F1_0(global::System.IntPtr _0);
                }

                public static void F1(global::CommonTest.DelegateNamespace.Nested.__AnonymousDelegate0 _0)
                {
                    var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
                    __Internal.F1_0(__arg0);
                }
            }
        }
    }

    namespace SomeNamespace
    {
        public unsafe abstract partial class AbstractClass : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr_AbstractClass;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0AbstractClass@SomeNamespace@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0AbstractClass@SomeNamespace@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.SomeNamespace.AbstractClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.SomeNamespace.AbstractClass>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CommonTest.SomeNamespace.AbstractClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new AbstractClassInternal(native.ToPointer(), skipVTables);
            }

            internal static global::CommonTest.SomeNamespace.AbstractClass __CreateInstance(global::CommonTest.SomeNamespace.AbstractClass.__Internal native, bool skipVTables = false)
            {
                return new AbstractClassInternal(native, skipVTables);
            }

            protected AbstractClass(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            protected AbstractClass()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeNamespace.AbstractClass.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
                SetupVTables(GetType().FullName == "CommonTest.SomeNamespace.AbstractClass");
            }

            protected AbstractClass(global::CommonTest.SomeNamespace.AbstractClass _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeNamespace.AbstractClass.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                SetupVTables(GetType().FullName == "CommonTest.SomeNamespace.AbstractClass");
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CommonTest.SomeNamespace.AbstractClass __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                ((global::CommonTest.SomeNamespace.AbstractClass.__Internal*) __Instance)->vfptr_AbstractClass = new global::System.IntPtr(__OriginalVTables[0]);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public abstract void AbstractMethod();

            #region Virtual table interop

            // void AbstractMethod() = 0
            private static global::CommonTest.Delegates.Action_IntPtr _AbstractMethod_0DelegateInstance;

            private static void _AbstractMethod_0DelegateHook(global::System.IntPtr instance)
            {
                if (!NativeToManagedMap.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (global::CommonTest.SomeNamespace.AbstractClass) NativeToManagedMap[instance];
                if (__target.__ownsNativeInstance)
                    __target.SetupVTables();
                __target.AbstractMethod();
            }

            private static void*[] __ManagedVTables;
            private static void*[] _Thunks;

            private void SetupVTables(bool destructorOnly = false)
            {
                if (__OriginalVTables != null)
                    return;
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

                if (destructorOnly)
                    return;
                if (_Thunks == null)
                {
                    _Thunks = new void*[1];
                    _AbstractMethod_0DelegateInstance += _AbstractMethod_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AbstractMethod_0DelegateInstance).ToPointer();
                }

                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }

            #endregion
        }

        public unsafe partial class AbstractClassInternal : global::CommonTest.SomeNamespace.AbstractClass, IDisposable
        {
            private static void* __CopyValue(global::CommonTest.SomeNamespace.AbstractClass.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.SomeNamespace.AbstractClass.__Internal));
                *(global::CommonTest.SomeNamespace.AbstractClass.__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal AbstractClassInternal(global::CommonTest.SomeNamespace.AbstractClass.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal AbstractClassInternal(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                __Instance = new global::System.IntPtr(native);
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            }

            public override void AbstractMethod()
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___AbstractMethod_0Delegate = (global::CommonTest.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CommonTest.Delegates.Action_IntPtr));
                ___AbstractMethod_0Delegate((__Instance + __PointerAdjustment));
            }
        }
    }

    namespace Boost
    {
        namespace IsMemberPointerCv
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public unsafe partial struct __Internal
            {
            }
        }

        namespace MakeTupleTraits
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public unsafe partial struct __Internal
            {
            }
        }

        namespace Detail
        {
            public unsafe partial class SwallowAssign : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct __Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("Common.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0swallow_assign@detail@boost@@QAE@ABU012@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Boost.Detail.SwallowAssign> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CommonTest.Boost.Detail.SwallowAssign>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CommonTest.Boost.Detail.SwallowAssign __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new SwallowAssign(native.ToPointer(), skipVTables);
                }

                internal static global::CommonTest.Boost.Detail.SwallowAssign __CreateInstance(global::CommonTest.Boost.Detail.SwallowAssign.__Internal native, bool skipVTables = false)
                {
                    return new SwallowAssign(native, skipVTables);
                }

                private static void* __CopyValue(global::CommonTest.Boost.Detail.SwallowAssign.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CommonTest.Boost.Detail.SwallowAssign.__Internal));
                    *(global::CommonTest.Boost.Detail.SwallowAssign.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SwallowAssign(global::CommonTest.Boost.Detail.SwallowAssign.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SwallowAssign(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SwallowAssign(global::CommonTest.Boost.Detail.SwallowAssign _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CommonTest.Boost.Detail.SwallowAssign.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CommonTest.Boost.Detail.SwallowAssign.__Internal*) __Instance) = *((global::CommonTest.Boost.Detail.SwallowAssign.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    global::CommonTest.Boost.Detail.SwallowAssign __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int* Func_intPtr_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr_int(global::System.IntPtr instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr_boolPtr(global::System.IntPtr instance, bool* arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate bool Func_bool_IntPtr_IntPtr(global::System.IntPtr instance, global::System.IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr instance, global::System.IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr_IntPtr(global::System.IntPtr instance, global::System.IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr instance);
    }
}
