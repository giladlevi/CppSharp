// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include "Common.h"

using namespace System;
using namespace System::Runtime::InteropServices;

CommonTest::Foo::NestedAbstract::NestedAbstract(::Foo::NestedAbstract* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Foo::NestedAbstract^ CommonTest::Foo::NestedAbstract::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Foo::NestedAbstract((::Foo::NestedAbstract*) native.ToPointer());
}

CommonTest::Foo::NestedAbstract::~NestedAbstract()
{
    delete NativePtr;
}

CommonTest::Foo::NestedAbstract::NestedAbstract()
{
    __ownsNativeInstance = true;
}

CommonTest::Foo::NestedAbstract::NestedAbstract(CommonTest::Foo::NestedAbstract^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::Foo::NestedAbstract::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Foo::NestedAbstract::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Foo::NestedAbstract*)object.ToPointer();
}

int* CommonTest::Foo::NestedAbstract::AbstractFunctionInNestedClass::get()
{
    auto __ret = ((::Foo::NestedAbstract*)NativePtr)->abstractFunctionInNestedClass();
    return __ret;
}

CommonTest::Foo::Foo(::Foo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Foo^ CommonTest::Foo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Foo((::Foo*) native.ToPointer());
}

CommonTest::Foo::~Foo()
{
    delete NativePtr;
}

CommonTest::Foo::Foo()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Foo();
}

void CommonTest::Foo::TakesTypedefedPtr(CommonTest::Foo^ date)
{
    auto __arg0 = (::Foo*)date->NativePtr;
    ((::Foo*)NativePtr)->TakesTypedefedPtr(__arg0);
}

int CommonTest::Foo::TakesRef(CommonTest::Foo^ other)
{
    if (ReferenceEquals(other, nullptr))
        throw gcnew ::System::ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)other->NativePtr;
    auto __ret = ((::Foo*)NativePtr)->TakesRef(__arg0);
    return __ret;
}

bool CommonTest::Foo::operator==(CommonTest::Foo^ __op, CommonTest::Foo^ other)
{
    bool __opNull = ReferenceEquals(__op, nullptr);
    bool otherNull = ReferenceEquals(other, nullptr);
    if (__opNull || otherNull)
        return __opNull && otherNull;
    auto &__arg0 = *(::Foo*)__op->NativePtr;
    auto &__arg1 = *(::Foo*)other->NativePtr;
    auto __ret = __arg0 == __arg1;
    return __ret;
}

bool CommonTest::Foo::Equals(::System::Object^ obj)
{
    return this == safe_cast<CommonTest::Foo^>(obj);
}

CommonTest::Foo::Foo(CommonTest::Foo^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)_0->NativePtr;
    NativePtr = new ::Foo(__arg0);
}

System::IntPtr CommonTest::Foo::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Foo::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Foo*)object.ToPointer();
}

int CommonTest::Foo::A::get()
{
    return ((::Foo*)NativePtr)->A;
}

void CommonTest::Foo::A::set(int value)
{
    ((::Foo*)NativePtr)->A = value;
}

float CommonTest::Foo::B::get()
{
    return ((::Foo*)NativePtr)->B;
}

void CommonTest::Foo::B::set(float value)
{
    ((::Foo*)NativePtr)->B = value;
}

cli::array<int>^ CommonTest::Foo::FixedArray::get()
{
    cli::array<int>^ __array0 = nullptr;
    if (((::Foo*)NativePtr)->fixedArray != 0)
    {
        __array0 = gcnew cli::array<int>(3);
        for (int i = 0; i < 3; i++)
            __array0[i] = ((::Foo*)NativePtr)->fixedArray[i];
    }
    return __array0;
}

void CommonTest::Foo::FixedArray::set(cli::array<int>^ value)
{
    if (value != nullptr)
    {
        for (int i = 0; i < 3; i++)
            ((::Foo*)NativePtr)->fixedArray[i] = value[i];
    }
}

cli::array<System::Char>^ CommonTest::Foo::FixedCharArray::get()
{
    cli::array<System::Char>^ __array0 = nullptr;
    if (((::Foo*)NativePtr)->fixedCharArray != 0)
    {
        __array0 = gcnew cli::array<System::Char>(3);
        for (int i = 0; i < 3; i++)
            __array0[i] = ((::Foo*)NativePtr)->fixedCharArray[i];
    }
    return __array0;
}

void CommonTest::Foo::FixedCharArray::set(cli::array<System::Char>^ value)
{
    if (value != nullptr)
    {
        for (int i = 0; i < 3; i++)
            ((::Foo*)NativePtr)->fixedCharArray[i] = value[i];
    }
}

::System::IntPtr CommonTest::Foo::Ptr::get()
{
    return ::System::IntPtr(((::Foo*)NativePtr)->ptr);
}

void CommonTest::Foo::Ptr::set(::System::IntPtr value)
{
    ((::Foo*)NativePtr)->ptr = (void*)value;
}

int* CommonTest::Foo::SomePointer::get()
{
    return const_cast<int*>(((::Foo*)NativePtr)->SomePointer);
}

void CommonTest::Foo::SomePointer::set(int* value)
{
    ((::Foo*)NativePtr)->SomePointer = (const int*)value;
}

int** CommonTest::Foo::SomePointerPointer::get()
{
    return const_cast<int**>(((::Foo*)NativePtr)->SomePointerPointer);
}

void CommonTest::Foo::SomePointerPointer::set(int** value)
{
    ((::Foo*)NativePtr)->SomePointerPointer = (const int**)value;
}

System::String^ CommonTest::Foo::ANSI::get()
{
    auto __ret = ((::Foo*)NativePtr)->GetANSI();
    if (__ret == nullptr) return nullptr;
    return (__ret == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(__ret));
}

int CommonTest::Foo::Unsafe::get()
{
    return ::Foo::unsafe;
}

System::String^ CommonTest::Foo::CharArray::get()
{
    return (::Foo::charArray == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(::Foo::charArray));
}

int CommonTest::Foo::ReadWrite::get()
{
    return ::Foo::readWrite;
}

void CommonTest::Foo::ReadWrite::set(int value)
{
    ::Foo::readWrite = value;
}

CommonTest::Bar::Bar(::Bar* native)
{
    __A = native->A;
    __B = native->B;
}

CommonTest::Bar^ CommonTest::Bar::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Bar((::Bar*) native.ToPointer());
}

CommonTest::Bar::Bar(CommonTest::Foo^ foo)
{
    ::Bar _native(*(::Foo*)foo->NativePtr);
    this->A = _native.A;
    this->B = _native.B;
}

CommonTest::Bar::Item CommonTest::Bar::RetItem1()
{
    auto _this0 = ::Bar();
    _this0.A = (*this).A;
    _this0.B = (*this).B;
    auto __ret = _this0.RetItem1();
    __A = _this0.A;
    __B = _this0.B;
    return (CommonTest::Bar::Item)__ret;
}

CommonTest::Bar CommonTest::Bar::ReturnPointerToValueType()
{
    auto _this0 = ::Bar();
    _this0.A = (*this).A;
    _this0.B = (*this).B;
    auto __ret = _this0.returnPointerToValueType();
    __A = _this0.A;
    __B = _this0.B;
    return CommonTest::Bar((::Bar*)__ret);
}

bool CommonTest::Bar::operator==(CommonTest::Bar __op, CommonTest::Bar arg1)
{
    bool __opNull = ReferenceEquals(__op, nullptr);
    bool arg1Null = ReferenceEquals(arg1, nullptr);
    if (__opNull || arg1Null)
        return __opNull && arg1Null;
    auto _marshal0 = ::Bar();
    _marshal0.A = __op.A;
    _marshal0.B = __op.B;
    auto __arg0 = _marshal0;
    auto _marshal1 = ::Bar();
    _marshal1.A = arg1.A;
    _marshal1.B = arg1.B;
    auto __arg1 = _marshal1;
    auto __ret = __arg0 == __arg1;
    return __ret;
}

bool CommonTest::Bar::Equals(::System::Object^ obj)
{
    return *this == safe_cast<CommonTest::Bar>(obj);
}

bool CommonTest::Bar::operator==(CommonTest::Bar::Item item, CommonTest::Bar bar)
{
    bool itemNull = ReferenceEquals(item, nullptr);
    bool barNull = ReferenceEquals(bar, nullptr);
    if (itemNull || barNull)
        return itemNull && barNull;
    auto __arg0 = (::Bar::Item)item;
    auto _marshal1 = ::Bar();
    _marshal1.A = bar.A;
    _marshal1.B = bar.B;
    auto __arg1 = _marshal1;
    auto __ret = __arg0 == __arg1;
    return __ret;
}

CommonTest::Bar::operator CommonTest::Bar(CommonTest::Foo^ foo)
{
    auto __arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = (::Bar) __arg0;
    return CommonTest::Bar((::Bar*)&__ret);
}

int CommonTest::Bar::A::get()
{
    return __A;
}

void CommonTest::Bar::A::set(int value)
{
    __A = value;
}

float CommonTest::Bar::B::get()
{
    return __B;
}

void CommonTest::Bar::B::set(float value)
{
    __B = value;
}

CommonTest::Foo2::Foo2(::Foo2* native)
    : CommonTest::Foo((::Foo*)native)
{
}

CommonTest::Foo2^ CommonTest::Foo2::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Foo2((::Foo2*) native.ToPointer());
}

CommonTest::Foo2::~Foo2()
{
}

CommonTest::Foo2::Foo2()
    : CommonTest::Foo((::Foo*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::Foo2();
}

CommonTest::Foo2^ CommonTest::Foo2::operator<<(CommonTest::Foo2^ __op, int i)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo2*)__op->NativePtr;
    auto __ret = __arg0 << i;
    auto ____ret = new ::Foo2(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)____ret);
}

System::Char CommonTest::Foo2::TestCharMarshalling(System::Char c)
{
    if (c < System::Char::MinValue || c > System::SByte::MaxValue)
        throw gcnew System::OverflowException("c must be in the range 0 - 127.");
    auto __ret = ((::Foo2*)NativePtr)->testCharMarshalling(c);
    return __ret;
}

void CommonTest::Foo2::TestKeywordParam(::System::IntPtr where, CommonTest::Bar::Item event, int ref)
{
    auto __arg0 = (void*)where;
    auto __arg1 = (::Bar::Item)event;
    ((::Foo2*)NativePtr)->testKeywordParam(__arg0, __arg1, ref);
}

CommonTest::Foo2::Foo2(CommonTest::Foo2^ _0)
    : CommonTest::Foo((::Foo*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo2*)_0->NativePtr;
    NativePtr = new ::Foo2(__arg0);
}

int CommonTest::Foo2::C::get()
{
    return ((::Foo2*)NativePtr)->C;
}

void CommonTest::Foo2::C::set(int value)
{
    ((::Foo2*)NativePtr)->C = value;
}

CommonTest::Bar CommonTest::Foo2::ValueTypeField::get()
{
    return CommonTest::Bar((::Bar*)&((::Foo2*)NativePtr)->valueTypeField);
}

void CommonTest::Foo2::ValueTypeField::set(CommonTest::Bar value)
{
    auto _marshal0 = ::Bar();
    _marshal0.A = value.A;
    _marshal0.B = value.B;
    ((::Foo2*)NativePtr)->valueTypeField = _marshal0;
}

CommonTest::Bar2::Nested::Nested(::Bar2::Nested* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Bar2::Nested^ CommonTest::Bar2::Nested::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Bar2::Nested((::Bar2::Nested*) native.ToPointer());
}

CommonTest::Bar2::Nested::~Nested()
{
    delete NativePtr;
}

CommonTest::Bar2::Nested::operator int(CommonTest::Bar2::Nested^ __op)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Bar2::Nested*)__op->NativePtr;
    auto __ret = (int) __arg0;
    return __ret;
}

CommonTest::Bar2::Nested::Nested()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Bar2::Nested();
}

CommonTest::Bar2::Nested::Nested(CommonTest::Bar2::Nested^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Bar2::Nested*)_0->NativePtr;
    NativePtr = new ::Bar2::Nested(__arg0);
}

System::IntPtr CommonTest::Bar2::Nested::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Bar2::Nested::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Bar2::Nested*)object.ToPointer();
}
CommonTest::Bar2::Bar2(::Bar2* native)
{
    __A = native->A;
    __B = native->B;
    __C = native->C;
    PointerToStruct = CommonTest::Bar((::Bar*)native->pointerToStruct);
    __pointerToPrimitive = native->pointerToPrimitive;
    __pointerToClass = (native->pointerToClass == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)native->pointerToClass);
    ValueStruct = CommonTest::Bar((::Bar*)&native->valueStruct);
}

CommonTest::Bar2^ CommonTest::Bar2::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Bar2((::Bar2*) native.ToPointer());
}

CommonTest::Bar::Item CommonTest::Bar2::RetItem1()
{
    auto _this0 = ::Bar2();
    _this0.A = (*this).A;
    _this0.B = (*this).B;
    _this0.C = (*this).C;
    auto _this0_marshal0 = ::Bar();
    _this0_marshal0.A = (*this).PointerToStruct.A;
    _this0_marshal0.B = (*this).PointerToStruct.B;
    _this0.pointerToStruct = &_this0_marshal0;
    _this0.pointerToPrimitive = (int*)(*this).PointerToPrimitive;
    if ((*this).PointerToClass != nullptr)
        _this0.pointerToClass = (::Foo2*)(*this).PointerToClass->NativePtr;
    auto _this0_marshal1 = ::Bar();
    _this0_marshal1.A = (*this).ValueStruct.A;
    _this0_marshal1.B = (*this).ValueStruct.B;
    _this0.valueStruct = _this0_marshal1;
    auto __ret = _this0.RetItem1();
    __A = _this0.A;
    __B = _this0.B;
    __C = _this0.C;
    PointerToStruct = CommonTest::Bar((::Bar*)_this0.pointerToStruct);
    __pointerToPrimitive = _this0.pointerToPrimitive;
    __pointerToClass = (_this0.pointerToClass == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)_this0.pointerToClass);
    ValueStruct = CommonTest::Bar((::Bar*)&_this0.valueStruct);
    return (CommonTest::Bar::Item)__ret;
}

CommonTest::Bar CommonTest::Bar2::ReturnPointerToValueType()
{
    auto _this0 = ::Bar2();
    _this0.A = (*this).A;
    _this0.B = (*this).B;
    _this0.C = (*this).C;
    auto _this0_marshal0 = ::Bar();
    _this0_marshal0.A = (*this).PointerToStruct.A;
    _this0_marshal0.B = (*this).PointerToStruct.B;
    _this0.pointerToStruct = &_this0_marshal0;
    _this0.pointerToPrimitive = (int*)(*this).PointerToPrimitive;
    if ((*this).PointerToClass != nullptr)
        _this0.pointerToClass = (::Foo2*)(*this).PointerToClass->NativePtr;
    auto _this0_marshal1 = ::Bar();
    _this0_marshal1.A = (*this).ValueStruct.A;
    _this0_marshal1.B = (*this).ValueStruct.B;
    _this0.valueStruct = _this0_marshal1;
    auto __ret = _this0.returnPointerToValueType();
    __A = _this0.A;
    __B = _this0.B;
    __C = _this0.C;
    PointerToStruct = CommonTest::Bar((::Bar*)_this0.pointerToStruct);
    __pointerToPrimitive = _this0.pointerToPrimitive;
    __pointerToClass = (_this0.pointerToClass == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)_this0.pointerToClass);
    ValueStruct = CommonTest::Bar((::Bar*)&_this0.valueStruct);
    return CommonTest::Bar((::Bar*)__ret);
}

CommonTest::Bar2::operator int(CommonTest::Bar2 __op)
{
    auto _marshal0 = ::Bar2();
    _marshal0.A = __op.A;
    _marshal0.B = __op.B;
    _marshal0.C = __op.C;
    auto _marshal1 = ::Bar();
    _marshal1.A = __op.PointerToStruct.A;
    _marshal1.B = __op.PointerToStruct.B;
    _marshal0.pointerToStruct = &_marshal1;
    _marshal0.pointerToPrimitive = (int*)__op.PointerToPrimitive;
    if (__op.PointerToClass != nullptr)
        _marshal0.pointerToClass = (::Foo2*)__op.PointerToClass->NativePtr;
    auto _marshal2 = ::Bar();
    _marshal2.A = __op.ValueStruct.A;
    _marshal2.B = __op.ValueStruct.B;
    _marshal0.valueStruct = _marshal2;
    auto __arg0 = _marshal0;
    auto __ret = (int) __arg0;
    return __ret;
}

CommonTest::Bar2::operator CommonTest::Foo2^(CommonTest::Bar2 __op)
{
    auto _marshal0 = ::Bar2();
    _marshal0.A = __op.A;
    _marshal0.B = __op.B;
    _marshal0.C = __op.C;
    auto _marshal1 = ::Bar();
    _marshal1.A = __op.PointerToStruct.A;
    _marshal1.B = __op.PointerToStruct.B;
    _marshal0.pointerToStruct = &_marshal1;
    _marshal0.pointerToPrimitive = (int*)__op.PointerToPrimitive;
    if (__op.PointerToClass != nullptr)
        _marshal0.pointerToClass = (::Foo2*)__op.PointerToClass->NativePtr;
    auto _marshal2 = ::Bar();
    _marshal2.A = __op.ValueStruct.A;
    _marshal2.B = __op.ValueStruct.B;
    _marshal0.valueStruct = _marshal2;
    auto __arg0 = _marshal0;
    auto __ret = (::Foo2) __arg0;
    auto ____ret = new ::Foo2(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)____ret);
}

int CommonTest::Bar2::A::get()
{
    return __A;
}

void CommonTest::Bar2::A::set(int value)
{
    __A = value;
}

float CommonTest::Bar2::B::get()
{
    return __B;
}

void CommonTest::Bar2::B::set(float value)
{
    __B = value;
}

int CommonTest::Bar2::C::get()
{
    return __C;
}

void CommonTest::Bar2::C::set(int value)
{
    __C = value;
}

int* CommonTest::Bar2::PointerToPrimitive::get()
{
    return __pointerToPrimitive;
}

void CommonTest::Bar2::PointerToPrimitive::set(int* value)
{
    __pointerToPrimitive = value;
}

CommonTest::Foo2^ CommonTest::Bar2::PointerToClass::get()
{
    return __pointerToClass;
}

void CommonTest::Bar2::PointerToClass::set(CommonTest::Foo2^ value)
{
    __pointerToClass = value;
}

CommonTest::Foo2^ CommonTest::Bar2::NeedFixedInstance::get()
{
    auto _this0 = ::Bar2();
    _this0.A = (*this).A;
    _this0.B = (*this).B;
    _this0.C = (*this).C;
    auto _this0_marshal0 = ::Bar();
    _this0_marshal0.A = (*this).PointerToStruct.A;
    _this0_marshal0.B = (*this).PointerToStruct.B;
    _this0.pointerToStruct = &_this0_marshal0;
    _this0.pointerToPrimitive = (int*)(*this).PointerToPrimitive;
    if ((*this).PointerToClass != nullptr)
        _this0.pointerToClass = (::Foo2*)(*this).PointerToClass->NativePtr;
    auto _this0_marshal1 = ::Bar();
    _this0_marshal1.A = (*this).ValueStruct.A;
    _this0_marshal1.B = (*this).ValueStruct.B;
    _this0.valueStruct = _this0_marshal1;
    auto __ret = _this0.needFixedInstance();
    __A = _this0.A;
    __B = _this0.B;
    __C = _this0.C;
    PointerToStruct = CommonTest::Bar((::Bar*)_this0.pointerToStruct);
    __pointerToPrimitive = _this0.pointerToPrimitive;
    __pointerToClass = (_this0.pointerToClass == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)_this0.pointerToClass);
    ValueStruct = CommonTest::Bar((::Bar*)&_this0.valueStruct);
    auto ____ret = new ::Foo2(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::Foo2((::Foo2*)____ret);
}

CommonTest::Hello::NestedPublic::NestedPublic(::Hello::NestedPublic* native)
{
    __j = native->j;
    __g = native->g;
    __l = native->l;
}

CommonTest::Hello::NestedPublic^ CommonTest::Hello::NestedPublic::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Hello::NestedPublic((::Hello::NestedPublic*) native.ToPointer());
}

int CommonTest::Hello::NestedPublic::J::get()
{
    return __j;
}

void CommonTest::Hello::NestedPublic::J::set(int value)
{
    __j = value;
}

float CommonTest::Hello::NestedPublic::G::get()
{
    return __g;
}

void CommonTest::Hello::NestedPublic::G::set(float value)
{
    __g = value;
}

long CommonTest::Hello::NestedPublic::L::get()
{
    return __l;
}

void CommonTest::Hello::NestedPublic::L::set(long value)
{
    __l = value;
}

CommonTest::Hello::Hello(::Hello* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Hello^ CommonTest::Hello::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Hello((::Hello*) native.ToPointer());
}

CommonTest::Hello::~Hello()
{
    delete NativePtr;
}

CommonTest::Hello::Hello()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Hello();
}

CommonTest::Hello::Hello(CommonTest::Hello^ hello)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(hello, nullptr))
        throw gcnew ::System::ArgumentNullException("hello", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Hello*)hello->NativePtr;
    NativePtr = new ::Hello(__arg0);
}

void CommonTest::Hello::PrintHello(System::String^ s)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(s);
    auto __arg0 = ___arg0.c_str();
    ((::Hello*)NativePtr)->PrintHello(__arg0);
}

bool CommonTest::Hello::Test1(int i, float f)
{
    auto __ret = ((::Hello*)NativePtr)->test1(i, f);
    return __ret;
}

int CommonTest::Hello::Add(int a, int b)
{
    auto __ret = ((::Hello*)NativePtr)->add(a, b);
    return __ret;
}

int CommonTest::Hello::AddFoo(CommonTest::Foo^ _0)
{
    auto __arg0 = *(::Foo*)_0->NativePtr;
    auto __ret = ((::Hello*)NativePtr)->AddFoo(__arg0);
    return __ret;
}

int CommonTest::Hello::AddFooRef(CommonTest::Foo^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)_0->NativePtr;
    auto __ret = ((::Hello*)NativePtr)->AddFooRef(__arg0);
    return __ret;
}

int CommonTest::Hello::AddFooPtr(CommonTest::Foo^ _0)
{
    auto __arg0 = (::Foo*)_0->NativePtr;
    auto __ret = ((::Hello*)NativePtr)->AddFooPtr(__arg0);
    return __ret;
}

int CommonTest::Hello::AddFooPtrRef(CommonTest::Foo^ _0)
{
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto __arg0 = (::Foo*)_0->NativePtr;
    auto __ret = ((::Hello*)NativePtr)->AddFooPtrRef(__arg0);
    return __ret;
}

CommonTest::Foo^ CommonTest::Hello::RetFoo(int a, float b)
{
    auto __ret = ((::Hello*)NativePtr)->RetFoo(a, b);
    auto ____ret = new ::Foo(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::Foo((::Foo*)____ret);
}

int CommonTest::Hello::AddFoo2(CommonTest::Foo2^ _0)
{
    auto __arg0 = *(::Foo2*)_0->NativePtr;
    auto __ret = ((::Hello*)NativePtr)->AddFoo2(__arg0);
    return __ret;
}

int CommonTest::Hello::AddBar(CommonTest::Bar _0)
{
    auto _marshal0 = ::Bar();
    _marshal0.A = _0.A;
    _marshal0.B = _0.B;
    auto __arg0 = _marshal0;
    auto __ret = ((::Hello*)NativePtr)->AddBar(__arg0);
    return __ret;
}

int CommonTest::Hello::AddBar2(CommonTest::Bar2 _0)
{
    auto _marshal0 = ::Bar2();
    _marshal0.A = _0.A;
    _marshal0.B = _0.B;
    _marshal0.C = _0.C;
    auto _marshal1 = ::Bar();
    _marshal1.A = _0.PointerToStruct.A;
    _marshal1.B = _0.PointerToStruct.B;
    _marshal0.pointerToStruct = &_marshal1;
    _marshal0.pointerToPrimitive = (int*)_0.PointerToPrimitive;
    if (_0.PointerToClass != nullptr)
        _marshal0.pointerToClass = (::Foo2*)_0.PointerToClass->NativePtr;
    auto _marshal2 = ::Bar();
    _marshal2.A = _0.ValueStruct.A;
    _marshal2.B = _0.ValueStruct.B;
    _marshal0.valueStruct = _marshal2;
    auto __arg0 = _marshal0;
    auto __ret = ((::Hello*)NativePtr)->AddBar2(__arg0);
    return __ret;
}

int CommonTest::Hello::RetEnum(CommonTest::Enum _0)
{
    auto __arg0 = (::Enum)_0;
    auto __ret = ((::Hello*)NativePtr)->RetEnum(__arg0);
    return __ret;
}

CommonTest::Hello^ CommonTest::Hello::RetNull()
{
    auto __ret = ((::Hello*)NativePtr)->RetNull();
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew CommonTest::Hello((::Hello*)__ret);
}

bool CommonTest::Hello::TestPrimitiveOut([System::Runtime::InteropServices::Out] float% f)
{
    float __arg0;
    auto __ret = ((::Hello*)NativePtr)->TestPrimitiveOut(&__arg0);
    f = __arg0;
    return __ret;
}

bool CommonTest::Hello::TestPrimitiveOutRef([System::Runtime::InteropServices::Out] float% f)
{
    float __arg0;
    auto __ret = ((::Hello*)NativePtr)->TestPrimitiveOutRef(__arg0);
    f = __arg0;
    return __ret;
}

bool CommonTest::Hello::TestPrimitiveInOut([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] int% i)
{
    int __arg0 = i;
    auto __ret = ((::Hello*)NativePtr)->TestPrimitiveInOut(&__arg0);
    i = __arg0;
    return __ret;
}

bool CommonTest::Hello::TestPrimitiveInOutRef([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] int% i)
{
    int __arg0 = i;
    auto __ret = ((::Hello*)NativePtr)->TestPrimitiveInOutRef(__arg0);
    i = __arg0;
    return __ret;
}

void CommonTest::Hello::EnumOut(int value, [System::Runtime::InteropServices::Out] Enum% e)
{
    ::Enum __arg1;
    ((::Hello*)NativePtr)->EnumOut(value, &__arg1);
    e = (CommonTest::Enum)__arg1;
}

void CommonTest::Hello::EnumOutRef(int value, [System::Runtime::InteropServices::Out] Enum% e)
{
    ::Enum __arg1;
    ((::Hello*)NativePtr)->EnumOutRef(value, __arg1);
    e = (CommonTest::Enum)__arg1;
}

void CommonTest::Hello::EnumInOut([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] Enum% e)
{
    ::Enum __arg0 = (::Enum)e;
    ((::Hello*)NativePtr)->EnumInOut(&__arg0);
    e = (CommonTest::Enum)__arg0;
}

void CommonTest::Hello::EnumInOutRef([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] Enum% e)
{
    ::Enum __arg0 = (::Enum)e;
    ((::Hello*)NativePtr)->EnumInOutRef(__arg0);
    e = (CommonTest::Enum)__arg0;
}

void CommonTest::Hello::StringOut([System::Runtime::InteropServices::Out] System::String^% str)
{
    const char* __arg0;
    ((::Hello*)NativePtr)->StringOut(&__arg0);
    str = (__arg0 == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(__arg0));
}

void CommonTest::Hello::StringOutRef([System::Runtime::InteropServices::Out] System::String^% str)
{
    const char* __arg0;
    ((::Hello*)NativePtr)->StringOutRef(__arg0);
    str = (__arg0 == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(__arg0));
}

void CommonTest::Hello::StringInOut([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] System::String^% str)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    const char* __arg0 = ___arg0.c_str();
    ((::Hello*)NativePtr)->StringInOut(&__arg0);
    str = (__arg0 == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(__arg0));
}

void CommonTest::Hello::StringInOutRef([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] System::String^% str)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    const char* __arg0 = ___arg0.c_str();
    ((::Hello*)NativePtr)->StringInOutRef(__arg0);
    str = (__arg0 == 0 ? nullptr : clix::marshalString<clix::E_UTF8>(__arg0));
}

void CommonTest::Hello::StringTypedef(System::String^ str)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(str);
    auto __arg0 = ___arg0.c_str();
    ((::Hello*)NativePtr)->StringTypedef(__arg0);
}

System::IntPtr CommonTest::Hello::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Hello::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Hello*)object.ToPointer();
}
CommonTest::AbstractFoo::AbstractFoo(::AbstractFoo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::AbstractFoo^ CommonTest::AbstractFoo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::AbstractFoo((::AbstractFoo*) native.ToPointer());
}

CommonTest::AbstractFoo::~AbstractFoo()
{
    delete NativePtr;
}

int CommonTest::AbstractFoo::PureFunction(int i)
{
    auto __ret = ((::AbstractFoo*)NativePtr)->pureFunction(i);
    return __ret;
}

int CommonTest::AbstractFoo::PureFunction2([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] bool% ok)
{
    bool __arg0 = ok;
    auto __ret = ((::AbstractFoo*)NativePtr)->pureFunction2(&__arg0);
    ok = __arg0;
    return __ret;
}

CommonTest::AbstractFoo::AbstractFoo()
{
    __ownsNativeInstance = true;
}

CommonTest::AbstractFoo::AbstractFoo(CommonTest::AbstractFoo^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::AbstractFoo::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::AbstractFoo::__Instance::set(System::IntPtr object)
{
    NativePtr = (::AbstractFoo*)object.ToPointer();
}

int CommonTest::AbstractFoo::PureFunction1::get()
{
    auto __ret = ((::AbstractFoo*)NativePtr)->pureFunction1();
    return __ret;
}

CommonTest::ImplementsAbstractFoo::ImplementsAbstractFoo(::ImplementsAbstractFoo* native)
    : CommonTest::AbstractFoo((::AbstractFoo*)native)
{
}

CommonTest::ImplementsAbstractFoo^ CommonTest::ImplementsAbstractFoo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ImplementsAbstractFoo((::ImplementsAbstractFoo*) native.ToPointer());
}

CommonTest::ImplementsAbstractFoo::~ImplementsAbstractFoo()
{
}

int CommonTest::ImplementsAbstractFoo::PureFunction(int i)
{
    auto __arg0 = (::ImplementsAbstractFoo::typedefInOverride)i;
    auto __ret = ((::ImplementsAbstractFoo*)NativePtr)->pureFunction(__arg0);
    return __ret;
}

int CommonTest::ImplementsAbstractFoo::PureFunction2([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] bool% ok)
{
    bool __arg0 = ok;
    auto __ret = ((::ImplementsAbstractFoo*)NativePtr)->pureFunction2(&__arg0);
    ok = __arg0;
    return __ret;
}

CommonTest::ImplementsAbstractFoo::ImplementsAbstractFoo()
    : CommonTest::AbstractFoo((::AbstractFoo*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::ImplementsAbstractFoo();
}

CommonTest::ImplementsAbstractFoo::ImplementsAbstractFoo(CommonTest::ImplementsAbstractFoo^ _0)
    : CommonTest::AbstractFoo((::AbstractFoo*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ImplementsAbstractFoo*)_0->NativePtr;
    NativePtr = new ::ImplementsAbstractFoo(__arg0);
}

int CommonTest::ImplementsAbstractFoo::PureFunction1::get()
{
    auto __ret = ((::ImplementsAbstractFoo*)NativePtr)->pureFunction1();
    return __ret;
}

CommonTest::ReturnsAbstractFoo::ReturnsAbstractFoo(::ReturnsAbstractFoo* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ReturnsAbstractFoo^ CommonTest::ReturnsAbstractFoo::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ReturnsAbstractFoo((::ReturnsAbstractFoo*) native.ToPointer());
}

CommonTest::ReturnsAbstractFoo::~ReturnsAbstractFoo()
{
    delete NativePtr;
}

CommonTest::ReturnsAbstractFoo::ReturnsAbstractFoo()
{
    __ownsNativeInstance = true;
    NativePtr = new ::ReturnsAbstractFoo();
}

CommonTest::ReturnsAbstractFoo::ReturnsAbstractFoo(CommonTest::ReturnsAbstractFoo^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ReturnsAbstractFoo*)_0->NativePtr;
    NativePtr = new ::ReturnsAbstractFoo(__arg0);
}

System::IntPtr CommonTest::ReturnsAbstractFoo::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ReturnsAbstractFoo::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ReturnsAbstractFoo*)object.ToPointer();
}

CommonTest::AbstractFoo^ CommonTest::ReturnsAbstractFoo::Foo::get()
{
    auto &__ret = ((::ReturnsAbstractFoo*)NativePtr)->getFoo();
    return (CommonTest::AbstractFoo^)((&__ret == nullptr) ? nullptr : gcnew CommonTest::AbstractFoo((::AbstractFoo*)&__ret));
}

CommonTest::Exception::Exception(::Exception* native)
    : CommonTest::Foo((::Foo*)native)
{
}

CommonTest::Exception^ CommonTest::Exception::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Exception((::Exception*) native.ToPointer());
}

CommonTest::Exception::~Exception()
{
}

CommonTest::Exception^ CommonTest::Exception::Clone()
{
    auto __ret = ((::Exception*)NativePtr)->clone();
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew CommonTest::Exception((::Exception*)__ret);
}

CommonTest::Exception::Exception()
    : CommonTest::Foo((::Foo*)nullptr)
{
    __ownsNativeInstance = true;
}

CommonTest::Exception::Exception(CommonTest::Exception^ _0)
    : CommonTest::Foo((::Foo*)nullptr)
{
    __ownsNativeInstance = true;
}

CommonTest::DerivedException::DerivedException(::DerivedException* native)
    : CommonTest::Exception((::Exception*)native)
{
}

CommonTest::DerivedException^ CommonTest::DerivedException::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DerivedException((::DerivedException*) native.ToPointer());
}

CommonTest::DerivedException::~DerivedException()
{
}

CommonTest::Exception^ CommonTest::DerivedException::Clone()
{
    auto __ret = ((::DerivedException*)NativePtr)->clone();
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew CommonTest::Exception((::Exception*)__ret);
}

CommonTest::DerivedException::DerivedException()
    : CommonTest::Exception((::Exception*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::DerivedException();
}

CommonTest::DerivedException::DerivedException(CommonTest::DerivedException^ _0)
    : CommonTest::Exception((::Exception*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DerivedException*)_0->NativePtr;
    NativePtr = new ::DerivedException(__arg0);
}

CommonTest::DefaultParameters::DefaultParameters(::DefaultParameters* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::DefaultParameters^ CommonTest::DefaultParameters::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DefaultParameters((::DefaultParameters*) native.ToPointer());
}

CommonTest::DefaultParameters::~DefaultParameters()
{
    delete NativePtr;
}

void CommonTest::DefaultParameters::Foo(int a, int b)
{
    ((::DefaultParameters*)NativePtr)->Foo(a, b);
}

void CommonTest::DefaultParameters::Bar()
{
    ((::DefaultParameters*)NativePtr)->Bar();
}

CommonTest::DefaultParameters::DefaultParameters()
{
    __ownsNativeInstance = true;
    NativePtr = new ::DefaultParameters();
}

CommonTest::DefaultParameters::DefaultParameters(CommonTest::DefaultParameters^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DefaultParameters*)_0->NativePtr;
    NativePtr = new ::DefaultParameters(__arg0);
}

System::IntPtr CommonTest::DefaultParameters::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::DefaultParameters::__Instance::set(System::IntPtr object)
{
    NativePtr = (::DefaultParameters*)object.ToPointer();
}
CommonTest::Derived::Derived(::Derived* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Derived^ CommonTest::Derived::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Derived((::Derived*) native.ToPointer());
}

CommonTest::Derived::~Derived()
{
    delete NativePtr;
}

CommonTest::Derived::Derived()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Derived();
}

CommonTest::Derived::Derived(CommonTest::Derived^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Derived*)_0->NativePtr;
    NativePtr = new ::Derived(__arg0);
}

System::IntPtr CommonTest::Derived::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Derived::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Derived*)object.ToPointer();
}
CommonTest::Common::Common(::common* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Common^ CommonTest::Common::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Common((::common*) native.ToPointer());
}

CommonTest::Common::~Common()
{
    delete NativePtr;
}

CommonTest::Common::Common()
{
    __ownsNativeInstance = true;
    NativePtr = new ::common();
}

CommonTest::Common::Common(CommonTest::Common^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::common*)_0->NativePtr;
    NativePtr = new ::common(__arg0);
}

int CommonTest::Common::UnsafeFunction(CommonTest::Bar ret, System::Char* testForString, CommonTest::Common::__AnonymousDelegate0^ foo)
{
    auto _marshal0 = ::Bar();
    _marshal0.A = ret.A;
    _marshal0.B = ret.B;
    auto __arg0 = _marshal0;
    auto __arg1 = (char*)testForString;
    auto __arg2 = static_cast<void (*)(int)>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(foo).ToPointer());
    auto __ret = ::unsafeFunction(__arg0, __arg1, __arg2);
    return __ret;
}

int CommonTest::Common::Test(CommonTest::Common^ s)
{
    if (ReferenceEquals(s, nullptr))
        throw gcnew ::System::ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::common*)s->NativePtr;
    auto __ret = ::test(__arg0);
    return __ret;
}

void CommonTest::Common::FuncTryRefTypePtrOut([System::Runtime::InteropServices::Out] CommonTest::RefTypeClassPassTry^% classTry)
{
    ::RefTypeClassPassTry __arg0;
    ::funcTryRefTypePtrOut(&__arg0);
    auto ____arg0 = new ::RefTypeClassPassTry(__arg0);
    classTry = (____arg0 == nullptr) ? nullptr : gcnew CommonTest::RefTypeClassPassTry((::RefTypeClassPassTry*)____arg0);
}

void CommonTest::Common::FuncTryRefTypeOut([System::Runtime::InteropServices::Out] CommonTest::RefTypeClassPassTry^% classTry)
{
    ::RefTypeClassPassTry __arg0;
    ::funcTryRefTypeOut(__arg0);
    auto ____arg0 = new ::RefTypeClassPassTry(__arg0);
    classTry = (____arg0 == nullptr) ? nullptr : gcnew CommonTest::RefTypeClassPassTry((::RefTypeClassPassTry*)____arg0);
}

void CommonTest::Common::FuncTryValTypePtrOut([System::Runtime::InteropServices::Out] CommonTest::ValueTypeClassPassTry% classTry)
{
    ::ValueTypeClassPassTry __arg0;
    ::funcTryValTypePtrOut(&__arg0);
    classTry = CommonTest::ValueTypeClassPassTry((::ValueTypeClassPassTry*)&__arg0);
}

void CommonTest::Common::FuncTryValTypeOut([System::Runtime::InteropServices::Out] CommonTest::ValueTypeClassPassTry% classTry)
{
    ::ValueTypeClassPassTry __arg0;
    ::funcTryValTypeOut(__arg0);
    classTry = CommonTest::ValueTypeClassPassTry((::ValueTypeClassPassTry*)&__arg0);
}

int CommonTest::Common::FuncUnion(CommonTest::UnionT u)
{
    auto _marshal0 = ::union_t();
    _marshal0.c = u.C;
    auto __arg0 = _marshal0;
    auto __ret = ::func_union(__arg0);
    return __ret;
}

void CommonTest::Common::FuncWithTypeAlias(int i)
{
    auto __arg0 = (::custom_int_t)i;
    ::FuncWithTypeAlias(__arg0);
}

void CommonTest::Common::HasPointerParam(CommonTest::Foo^ foo, int i)
{
    auto __arg0 = (::Foo*)foo->NativePtr;
    ::hasPointerParam(__arg0, i);
}

void CommonTest::Common::HasPointerParam(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    ::hasPointerParam(__arg0);
}

void CommonTest::Common::SMallFollowedByCapital()
{
    ::sMallFollowedByCapital();
}

System::IntPtr CommonTest::Common::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Common::__Instance::set(System::IntPtr object)
{
    NativePtr = (::common*)object.ToPointer();
}

CommonTest::Bar CommonTest::Common::IndirectReturn::get()
{
    auto __ret = ::indirectReturn();
    return CommonTest::Bar((::Bar*)&__ret);
}

int CommonTest::Common::Function::get()
{
    auto __ret = ::Function();
    return __ret;
}

int CommonTest::Common::TestDecltype::get()
{
    auto __ret = ::TestDecltype();
    return __ret;
}

void* CommonTest::Common::TestNullPtrTypeRet::get()
{
    auto __ret = ::TestNullPtrTypeRet();
    return __ret;
}

CommonTest::TestMoveOperatorToClass::TestMoveOperatorToClass(::TestMoveOperatorToClass* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestMoveOperatorToClass^ CommonTest::TestMoveOperatorToClass::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestMoveOperatorToClass((::TestMoveOperatorToClass*) native.ToPointer());
}

CommonTest::TestMoveOperatorToClass::~TestMoveOperatorToClass()
{
    delete NativePtr;
}

CommonTest::TestMoveOperatorToClass::TestMoveOperatorToClass()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestMoveOperatorToClass();
}

CommonTest::TestMoveOperatorToClass::TestMoveOperatorToClass(CommonTest::TestMoveOperatorToClass^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestMoveOperatorToClass*)_0->NativePtr;
    NativePtr = new ::TestMoveOperatorToClass(__arg0);
}

int CommonTest::TestMoveOperatorToClass::operator*(CommonTest::TestMoveOperatorToClass^ klass, int b)
{
    auto __arg0 = *(::TestMoveOperatorToClass*)klass->NativePtr;
    auto __ret = __arg0 * b;
    return __ret;
}

CommonTest::TestMoveOperatorToClass^ CommonTest::TestMoveOperatorToClass::operator-(CommonTest::TestMoveOperatorToClass^ b)
{
    if (ReferenceEquals(b, nullptr))
        throw gcnew ::System::ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestMoveOperatorToClass*)b->NativePtr;
    auto __ret = - __arg0;
    auto ____ret = new ::TestMoveOperatorToClass(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::TestMoveOperatorToClass((::TestMoveOperatorToClass*)____ret);
}

CommonTest::TestMoveOperatorToClass^ CommonTest::TestMoveOperatorToClass::operator+(CommonTest::TestMoveOperatorToClass^ b1, CommonTest::TestMoveOperatorToClass^ b2)
{
    if (ReferenceEquals(b1, nullptr))
        throw gcnew ::System::ArgumentNullException("b1", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestMoveOperatorToClass*)b1->NativePtr;
    if (ReferenceEquals(b2, nullptr))
        throw gcnew ::System::ArgumentNullException("b2", "Cannot be null because it is a C++ reference (&).");
    auto &__arg1 = *(::TestMoveOperatorToClass*)b2->NativePtr;
    auto __ret = __arg0 + __arg1;
    auto ____ret = new ::TestMoveOperatorToClass(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::TestMoveOperatorToClass((::TestMoveOperatorToClass*)____ret);
}

System::IntPtr CommonTest::TestMoveOperatorToClass::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestMoveOperatorToClass::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestMoveOperatorToClass*)object.ToPointer();
}

int CommonTest::TestMoveOperatorToClass::A::get()
{
    return ((::TestMoveOperatorToClass*)NativePtr)->A;
}

void CommonTest::TestMoveOperatorToClass::A::set(int value)
{
    ((::TestMoveOperatorToClass*)NativePtr)->A = value;
}

int CommonTest::TestMoveOperatorToClass::B::get()
{
    return ((::TestMoveOperatorToClass*)NativePtr)->B;
}

void CommonTest::TestMoveOperatorToClass::B::set(int value)
{
    ((::TestMoveOperatorToClass*)NativePtr)->B = value;
}

CommonTest::TestDelegates::TestDelegates(::TestDelegates* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestDelegates^ CommonTest::TestDelegates::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestDelegates((::TestDelegates*) native.ToPointer());
}

CommonTest::TestDelegates::~TestDelegates()
{
    delete NativePtr;
}

CommonTest::TestDelegates::TestDelegates()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestDelegates();
}

int CommonTest::TestDelegates::Double(int N)
{
    auto __ret = ::TestDelegates::Double(N);
    return __ret;
}

int CommonTest::TestDelegates::Triple(int N)
{
    auto __ret = ((::TestDelegates*)NativePtr)->Triple(N);
    return __ret;
}

int CommonTest::TestDelegates::StdCall(CommonTest::DelegateStdCall^ del)
{
    auto __arg0 = static_cast<::DelegateStdCall>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    auto __ret = ((::TestDelegates*)NativePtr)->StdCall(__arg0);
    return __ret;
}

int CommonTest::TestDelegates::CDecl(CommonTest::DelegateCDecl^ del)
{
    auto __arg0 = static_cast<::DelegateCDecl>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    auto __ret = ((::TestDelegates*)NativePtr)->CDecl(__arg0);
    return __ret;
}

void CommonTest::TestDelegates::MarshalUnattributedDelegate(CommonTest::DelegateInGlobalNamespace^ del)
{
    auto __arg0 = static_cast<::DelegateInGlobalNamespace>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    ((::TestDelegates*)NativePtr)->MarshalUnattributedDelegate(__arg0);
}

int CommonTest::TestDelegates::MarshalAnonymousDelegate(CommonTest::TestDelegates::__AnonymousDelegate0^ del)
{
    auto __arg0 = static_cast<int (*)(int)>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    auto __ret = ((::TestDelegates*)NativePtr)->MarshalAnonymousDelegate(__arg0);
    return __ret;
}

void CommonTest::TestDelegates::MarshalAnonymousDelegate2(CommonTest::TestDelegates::__AnonymousDelegate0^ del)
{
    auto __arg0 = static_cast<int (*)(int)>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    ((::TestDelegates*)NativePtr)->MarshalAnonymousDelegate2(__arg0);
}

void CommonTest::TestDelegates::MarshalAnonymousDelegate3(CommonTest::TestDelegates::__AnonymousDelegate1^ del)
{
    auto __arg0 = static_cast<float (*)(float)>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    ((::TestDelegates*)NativePtr)->MarshalAnonymousDelegate3(__arg0);
}

void CommonTest::TestDelegates::MarshalDelegateInAnotherUnit(CommonTest::DelegateInAnotherUnit^ del)
{
    auto __arg0 = static_cast<::DelegateInAnotherUnit>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(del).ToPointer());
    ((::TestDelegates*)NativePtr)->MarshalDelegateInAnotherUnit(__arg0);
}

CommonTest::TestDelegates::TestDelegates(CommonTest::TestDelegates^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestDelegates*)_0->NativePtr;
    NativePtr = new ::TestDelegates(__arg0);
}

System::IntPtr CommonTest::TestDelegates::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestDelegates::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestDelegates*)object.ToPointer();
}

CommonTest::TestDelegates::DelegateInClass^ CommonTest::TestDelegates::A::get()
{
    return ((::TestDelegates*)NativePtr)->A == nullptr ? nullptr : safe_cast<CommonTest::TestDelegates::DelegateInClass^>(System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(IntPtr(((::TestDelegates*)NativePtr)->A), CommonTest::TestDelegates::DelegateInClass::typeid));
}

void CommonTest::TestDelegates::A::set(CommonTest::TestDelegates::DelegateInClass^ value)
{
    ((::TestDelegates*)NativePtr)->A = static_cast<::TestDelegates::DelegateInClass>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

CommonTest::DelegateInGlobalNamespace^ CommonTest::TestDelegates::B::get()
{
    return ((::TestDelegates*)NativePtr)->B == nullptr ? nullptr : safe_cast<CommonTest::DelegateInGlobalNamespace^>(System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(IntPtr(((::TestDelegates*)NativePtr)->B), CommonTest::DelegateInGlobalNamespace::typeid));
}

void CommonTest::TestDelegates::B::set(CommonTest::DelegateInGlobalNamespace^ value)
{
    ((::TestDelegates*)NativePtr)->B = static_cast<::DelegateInGlobalNamespace>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(value).ToPointer());
}

CommonTest::TestDelegates::__AnonymousDelegate0^ CommonTest::TestDelegates::MarshalAnonymousDelegate4::get()
{
    auto __ret = ((::TestDelegates*)NativePtr)->MarshalAnonymousDelegate4();
    return __ret == nullptr ? nullptr : safe_cast<CommonTest::TestDelegates::__AnonymousDelegate0^>(System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(IntPtr(__ret), CommonTest::TestDelegates::__AnonymousDelegate0::typeid));
}

CommonTest::DelegateNullCheck^ CommonTest::TestDelegates::MarshalNullDelegate::get()
{
    auto __ret = ((::TestDelegates*)NativePtr)->MarshalNullDelegate();
    return __ret == nullptr ? nullptr : safe_cast<CommonTest::DelegateNullCheck^>(System::Runtime::InteropServices::Marshal::GetDelegateForFunctionPointer(IntPtr(__ret), CommonTest::DelegateNullCheck::typeid));
}

CommonTest::TestMemoryLeaks::TestMemoryLeaks(::TestMemoryLeaks* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestMemoryLeaks^ CommonTest::TestMemoryLeaks::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestMemoryLeaks((::TestMemoryLeaks*) native.ToPointer());
}

CommonTest::TestMemoryLeaks::~TestMemoryLeaks()
{
    delete NativePtr;
}

CommonTest::TestMemoryLeaks::TestMemoryLeaks(System::String^ name)
{
    __ownsNativeInstance = true;
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg0 = ___arg0.c_str();
    NativePtr = new ::TestMemoryLeaks(__arg0);
}

CommonTest::TestMemoryLeaks::TestMemoryLeaks(CommonTest::TestMemoryLeaks^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestMemoryLeaks*)_0->NativePtr;
    NativePtr = new ::TestMemoryLeaks(__arg0);
}

System::IntPtr CommonTest::TestMemoryLeaks::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestMemoryLeaks::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestMemoryLeaks*)object.ToPointer();
}
CommonTest::TestFinalizers::TestFinalizers(::TestFinalizers* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestFinalizers^ CommonTest::TestFinalizers::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestFinalizers((::TestFinalizers*) native.ToPointer());
}

CommonTest::TestFinalizers::~TestFinalizers()
{
    delete NativePtr;
}

CommonTest::TestFinalizers::TestFinalizers()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestFinalizers();
}

CommonTest::TestFinalizers::TestFinalizers(CommonTest::TestFinalizers^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestFinalizers*)_0->NativePtr;
    NativePtr = new ::TestFinalizers(__arg0);
}

System::IntPtr CommonTest::TestFinalizers::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestFinalizers::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestFinalizers*)object.ToPointer();
}
int CommonTest::TestStaticClass::Add(int a, int b)
{
    auto __ret = ::TestStaticClass::Add(a, b);
    return __ret;
}

int CommonTest::TestStaticClass::OneTwoThree::get()
{
    auto __ret = ::TestStaticClass::GetOneTwoThree();
    return __ret;
}

int CommonTest::TestStaticClassDerived::Foo::get()
{
    auto __ret = ::TestStaticClassDerived::Foo();
    return __ret;
}

CommonTest::TestNotStaticClass::TestNotStaticClass(::TestNotStaticClass* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestNotStaticClass^ CommonTest::TestNotStaticClass::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestNotStaticClass((::TestNotStaticClass*) native.ToPointer());
}

CommonTest::TestNotStaticClass::~TestNotStaticClass()
{
    delete NativePtr;
}

CommonTest::TestNotStaticClass::TestNotStaticClass(CommonTest::TestNotStaticClass^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestNotStaticClass*)_0->NativePtr;
    NativePtr = new ::TestNotStaticClass(__arg0);
}

System::IntPtr CommonTest::TestNotStaticClass::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestNotStaticClass::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestNotStaticClass*)object.ToPointer();
}

CommonTest::TestNotStaticClass^ CommonTest::TestNotStaticClass::StaticFunction::get()
{
    auto __ret = ::TestNotStaticClass::StaticFunction();
    auto ____ret = new ::TestNotStaticClass(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::TestNotStaticClass((::TestNotStaticClass*)____ret);
}

CommonTest::HasIgnoredField::HasIgnoredField(::HasIgnoredField* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasIgnoredField^ CommonTest::HasIgnoredField::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasIgnoredField((::HasIgnoredField*) native.ToPointer());
}

CommonTest::HasIgnoredField::~HasIgnoredField()
{
    delete NativePtr;
}

CommonTest::HasIgnoredField::HasIgnoredField()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasIgnoredField();
}

CommonTest::HasIgnoredField::HasIgnoredField(CommonTest::HasIgnoredField^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasIgnoredField*)_0->NativePtr;
    NativePtr = new ::HasIgnoredField(__arg0);
}

System::IntPtr CommonTest::HasIgnoredField::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasIgnoredField::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasIgnoredField*)object.ToPointer();
}
CommonTest::TestCopyConstructorRef::TestCopyConstructorRef(::TestCopyConstructorRef* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestCopyConstructorRef^ CommonTest::TestCopyConstructorRef::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestCopyConstructorRef((::TestCopyConstructorRef*) native.ToPointer());
}

CommonTest::TestCopyConstructorRef::~TestCopyConstructorRef()
{
    delete NativePtr;
}

CommonTest::TestCopyConstructorRef::TestCopyConstructorRef()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestCopyConstructorRef();
}

CommonTest::TestCopyConstructorRef::TestCopyConstructorRef(CommonTest::TestCopyConstructorRef^ other)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(other, nullptr))
        throw gcnew ::System::ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestCopyConstructorRef*)other->NativePtr;
    NativePtr = new ::TestCopyConstructorRef(__arg0);
}

System::IntPtr CommonTest::TestCopyConstructorRef::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestCopyConstructorRef::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestCopyConstructorRef*)object.ToPointer();
}

int CommonTest::TestCopyConstructorRef::A::get()
{
    return ((::TestCopyConstructorRef*)NativePtr)->A;
}

void CommonTest::TestCopyConstructorRef::A::set(int value)
{
    ((::TestCopyConstructorRef*)NativePtr)->A = value;
}

float CommonTest::TestCopyConstructorRef::B::get()
{
    return ((::TestCopyConstructorRef*)NativePtr)->B;
}

void CommonTest::TestCopyConstructorRef::B::set(float value)
{
    ((::TestCopyConstructorRef*)NativePtr)->B = value;
}

CommonTest::SomeStruct::SomeStruct(::SomeStruct* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::SomeStruct^ CommonTest::SomeStruct::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::SomeStruct((::SomeStruct*) native.ToPointer());
}

CommonTest::SomeStruct::~SomeStruct()
{
    delete NativePtr;
}

CommonTest::SomeStruct::SomeStruct()
{
    __ownsNativeInstance = true;
    NativePtr = new ::SomeStruct();
}

CommonTest::SomeStruct::SomeStruct(CommonTest::SomeStruct^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::SomeStruct*)_0->NativePtr;
    NativePtr = new ::SomeStruct(__arg0);
}

System::IntPtr CommonTest::SomeStruct::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::SomeStruct::__Instance::set(System::IntPtr object)
{
    NativePtr = (::SomeStruct*)object.ToPointer();
}

unsigned long CommonTest::SomeStruct::P::get()
{
    return ((::SomeStruct*)NativePtr)->p;
}

void CommonTest::SomeStruct::P::set(unsigned long value)
{
    ((::SomeStruct*)NativePtr)->p = (::foo_t)value;
}

CommonTest::SomeClassExtendingTheStruct::SomeClassExtendingTheStruct(::SomeClassExtendingTheStruct* native)
    : CommonTest::SomeStruct((::SomeStruct*)native)
{
}

CommonTest::SomeClassExtendingTheStruct^ CommonTest::SomeClassExtendingTheStruct::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::SomeClassExtendingTheStruct((::SomeClassExtendingTheStruct*) native.ToPointer());
}

CommonTest::SomeClassExtendingTheStruct::~SomeClassExtendingTheStruct()
{
}

CommonTest::SomeClassExtendingTheStruct::SomeClassExtendingTheStruct()
    : CommonTest::SomeStruct((::SomeStruct*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::SomeClassExtendingTheStruct();
}

CommonTest::SomeClassExtendingTheStruct::SomeClassExtendingTheStruct(CommonTest::SomeClassExtendingTheStruct^ _0)
    : CommonTest::SomeStruct((::SomeStruct*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::SomeClassExtendingTheStruct*)_0->NativePtr;
    NativePtr = new ::SomeClassExtendingTheStruct(__arg0);
}

CommonTest::ClassWithOverloadedOperators::ClassWithOverloadedOperators(::ClassWithOverloadedOperators* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ClassWithOverloadedOperators^ CommonTest::ClassWithOverloadedOperators::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ClassWithOverloadedOperators((::ClassWithOverloadedOperators*) native.ToPointer());
}

CommonTest::ClassWithOverloadedOperators::~ClassWithOverloadedOperators()
{
    delete NativePtr;
}

CommonTest::ClassWithOverloadedOperators::ClassWithOverloadedOperators()
{
    __ownsNativeInstance = true;
    NativePtr = new ::ClassWithOverloadedOperators();
}

CommonTest::ClassWithOverloadedOperators::operator System::Char(CommonTest::ClassWithOverloadedOperators^ __op)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassWithOverloadedOperators*)__op->NativePtr;
    auto __ret = (char) __arg0;
    return __ret;
}

CommonTest::ClassWithOverloadedOperators::operator int(CommonTest::ClassWithOverloadedOperators^ __op)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassWithOverloadedOperators*)__op->NativePtr;
    auto __ret = (int) __arg0;
    return __ret;
}

CommonTest::ClassWithOverloadedOperators::operator short(CommonTest::ClassWithOverloadedOperators^ __op)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassWithOverloadedOperators*)__op->NativePtr;
    auto __ret = (short) __arg0;
    return __ret;
}

bool CommonTest::ClassWithOverloadedOperators::operator<(CommonTest::ClassWithOverloadedOperators^ __op, CommonTest::ClassWithOverloadedOperators^ other)
{
    if (ReferenceEquals(__op, nullptr))
        throw gcnew ::System::ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassWithOverloadedOperators*)__op->NativePtr;
    if (ReferenceEquals(other, nullptr))
        throw gcnew ::System::ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
    auto &__arg1 = *(::ClassWithOverloadedOperators*)other->NativePtr;
    auto __ret = __arg0 < __arg1;
    return __ret;
}

CommonTest::ClassWithOverloadedOperators::ClassWithOverloadedOperators(CommonTest::ClassWithOverloadedOperators^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassWithOverloadedOperators*)_0->NativePtr;
    NativePtr = new ::ClassWithOverloadedOperators(__arg0);
}

System::IntPtr CommonTest::ClassWithOverloadedOperators::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ClassWithOverloadedOperators::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ClassWithOverloadedOperators*)object.ToPointer();
}
CommonTest::TestProperties::TestProperties(::TestProperties* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestProperties^ CommonTest::TestProperties::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestProperties((::TestProperties*) native.ToPointer());
}

CommonTest::TestProperties::~TestProperties()
{
    delete NativePtr;
}

CommonTest::TestProperties::TestProperties()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestProperties();
}

CommonTest::TestProperties::TestProperties(CommonTest::TestProperties^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestProperties*)_0->NativePtr;
    NativePtr = new ::TestProperties(__arg0);
}

System::IntPtr CommonTest::TestProperties::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestProperties::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestProperties*)object.ToPointer();
}

int CommonTest::TestProperties::Field::get()
{
    return ((::TestProperties*)NativePtr)->Field;
}

void CommonTest::TestProperties::Field::set(int value)
{
    ((::TestProperties*)NativePtr)->Field = value;
}

int CommonTest::TestProperties::FieldValue::get()
{
    auto __ret = ((::TestProperties*)NativePtr)->getFieldValue();
    return __ret;
}

void CommonTest::TestProperties::FieldValue::set(int Value)
{
    ((::TestProperties*)NativePtr)->setFieldValue(Value);
}

CommonTest::TypeMappedIndex::TypeMappedIndex(::TypeMappedIndex* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TypeMappedIndex^ CommonTest::TypeMappedIndex::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TypeMappedIndex((::TypeMappedIndex*) native.ToPointer());
}

CommonTest::TypeMappedIndex::~TypeMappedIndex()
{
    delete NativePtr;
}

CommonTest::TypeMappedIndex::TypeMappedIndex()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TypeMappedIndex();
}

CommonTest::TypeMappedIndex::TypeMappedIndex(unsigned short _0)
{
    __ownsNativeInstance = true;
    auto __arg0 = ::TypeMappedIndex();
    NativePtr = new ::TypeMappedIndex(__arg0);
}

System::IntPtr CommonTest::TypeMappedIndex::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TypeMappedIndex::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TypeMappedIndex*)object.ToPointer();
}
CommonTest::TestIndexedProperties::TestIndexedProperties(::TestIndexedProperties* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestIndexedProperties^ CommonTest::TestIndexedProperties::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestIndexedProperties((::TestIndexedProperties*) native.ToPointer());
}

CommonTest::TestIndexedProperties::~TestIndexedProperties()
{
    delete NativePtr;
}

CommonTest::TestIndexedProperties::TestIndexedProperties()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestIndexedProperties();
}

CommonTest::TestIndexedProperties::TestIndexedProperties(CommonTest::TestIndexedProperties^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestIndexedProperties*)_0->NativePtr;
    NativePtr = new ::TestIndexedProperties(__arg0);
}

System::IntPtr CommonTest::TestIndexedProperties::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestIndexedProperties::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestIndexedProperties*)object.ToPointer();
}

unsigned long CommonTest::TestIndexedProperties::default::get(int i)
{
    auto &__ret = ((::TestIndexedProperties*)NativePtr)->operator[](i);
    return reinterpret_cast<unsigned long&>(__ret);
}

void CommonTest::TestIndexedProperties::default::set(int i, unsigned long value)
{
    ((::TestIndexedProperties*)NativePtr)->operator[](i) = (::foo_t)value;
}

unsigned long CommonTest::TestIndexedProperties::default::get(float f)
{
    auto __ret = ((::TestIndexedProperties*)NativePtr)->operator[](f);
    return *(reinterpret_cast<unsigned long*>(__ret));
}

void CommonTest::TestIndexedProperties::default::set(float f, unsigned long value)
{
    *(((::TestIndexedProperties*)NativePtr)->operator[](f)) = (::foo_t)value;
}

unsigned long CommonTest::TestIndexedProperties::default::get(System::String^ name)
{
    auto ___arg0 = clix::marshalString<clix::E_UTF8>(name);
    auto __arg0 = ___arg0.c_str();
    auto __ret = ((::TestIndexedProperties*)NativePtr)->operator[](__arg0);
    return __ret;
}

unsigned long* CommonTest::TestIndexedProperties::default::get(double d)
{
    auto &__ret = ((::TestIndexedProperties*)NativePtr)->operator[](d);
    return (unsigned long*)(reinterpret_cast<unsigned long&>(const_cast<foo_t&>(__ret)));
}

CommonTest::TestProperties^ CommonTest::TestIndexedProperties::default::get(unsigned char b)
{
    auto __ret = ((::TestIndexedProperties*)NativePtr)->operator[](b);
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew CommonTest::TestProperties((::TestProperties*)__ret);
}

void CommonTest::TestIndexedProperties::default::set(unsigned char b, CommonTest::TestProperties^ value)
{
    *(((::TestIndexedProperties*)NativePtr)->operator[](b)) = *(::TestProperties*)value->NativePtr;
}

CommonTest::TestProperties^ CommonTest::TestIndexedProperties::default::get(short b)
{
    auto &__ret = ((::TestIndexedProperties*)NativePtr)->operator[](b);
    return (CommonTest::TestProperties^)((&__ret == nullptr) ? nullptr : gcnew CommonTest::TestProperties((::TestProperties*)&__ret));
}

unsigned long CommonTest::TestIndexedProperties::default::get(CommonTest::TestProperties^ b)
{
    auto __arg0 = *(::TestProperties*)b->NativePtr;
    auto __ret = ((::TestIndexedProperties*)NativePtr)->operator[](__arg0);
    return __ret;
}

CommonTest::Bar CommonTest::TestIndexedProperties::default::get(unsigned long i)
{
    auto &__ret = ((::TestIndexedProperties*)NativePtr)->operator[](i);
    return CommonTest::Bar((::Bar*)&__ret);
}

void CommonTest::TestIndexedProperties::default::set(unsigned long i, CommonTest::Bar value)
{
    auto _marshal0 = ::Bar();
    _marshal0.A = value.A;
    _marshal0.B = value.B;
    ((::TestIndexedProperties*)NativePtr)->operator[](i) = _marshal0;
}

CommonTest::Bar CommonTest::TestIndexedProperties::default::get(unsigned short key)
{
    auto __arg0 = ::TypeMappedIndex();
    auto &__ret = ((::TestIndexedProperties*)NativePtr)->operator[](__arg0);
    return CommonTest::Bar((::Bar*)&__ret);
}

void CommonTest::TestIndexedProperties::default::set(unsigned short key, CommonTest::Bar value)
{
    auto _marshal0 = ::Bar();
    _marshal0.A = value.A;
    _marshal0.B = value.B;
    ((::TestIndexedProperties*)NativePtr)->operator[](::TypeMappedIndex()) = _marshal0;
}

int CommonTest::TestIndexedProperties::default::get(System::Char key)
{
    if (key < System::Char::MinValue || key > System::SByte::MaxValue)
        throw gcnew System::OverflowException("key must be in the range 0 - 127.");
    auto __ret = ((::TestIndexedProperties*)NativePtr)->operator[](key);
    key = key;
    return __ret;
}

CommonTest::TestIndexedPropertiesInValueType::TestIndexedPropertiesInValueType(::TestIndexedPropertiesInValueType* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestIndexedPropertiesInValueType^ CommonTest::TestIndexedPropertiesInValueType::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestIndexedPropertiesInValueType((::TestIndexedPropertiesInValueType*) native.ToPointer());
}

CommonTest::TestIndexedPropertiesInValueType::~TestIndexedPropertiesInValueType()
{
    delete NativePtr;
}

CommonTest::TestIndexedPropertiesInValueType::TestIndexedPropertiesInValueType()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestIndexedPropertiesInValueType();
}

CommonTest::TestIndexedPropertiesInValueType::TestIndexedPropertiesInValueType(CommonTest::TestIndexedPropertiesInValueType^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestIndexedPropertiesInValueType*)_0->NativePtr;
    NativePtr = new ::TestIndexedPropertiesInValueType(__arg0);
}

System::IntPtr CommonTest::TestIndexedPropertiesInValueType::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestIndexedPropertiesInValueType::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestIndexedPropertiesInValueType*)object.ToPointer();
}

int CommonTest::TestIndexedPropertiesInValueType::default::get(int i)
{
    auto __ret = ((::TestIndexedPropertiesInValueType*)NativePtr)->operator[](i);
    return __ret;
}

CommonTest::TestVariables::TestVariables(::TestVariables* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestVariables^ CommonTest::TestVariables::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestVariables((::TestVariables*) native.ToPointer());
}

CommonTest::TestVariables::~TestVariables()
{
    delete NativePtr;
}

void CommonTest::TestVariables::SetValue(int value)
{
    ((::TestVariables*)NativePtr)->SetValue(value);
}

CommonTest::TestVariables::TestVariables()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestVariables();
}

CommonTest::TestVariables::TestVariables(CommonTest::TestVariables^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestVariables*)_0->NativePtr;
    NativePtr = new ::TestVariables(__arg0);
}

System::IntPtr CommonTest::TestVariables::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestVariables::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestVariables*)object.ToPointer();
}
int CommonTest::TestVariables::VALUE::get()
{
    return ::TestVariables::VALUE;
}

void CommonTest::TestVariables::VALUE::set(int value)
{
    ::TestVariables::VALUE = value;
}

CommonTest::TestWideStrings::TestWideStrings(::TestWideStrings* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestWideStrings^ CommonTest::TestWideStrings::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestWideStrings((::TestWideStrings*) native.ToPointer());
}

CommonTest::TestWideStrings::~TestWideStrings()
{
    delete NativePtr;
}

CommonTest::TestWideStrings::TestWideStrings()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestWideStrings();
}

CommonTest::TestWideStrings::TestWideStrings(CommonTest::TestWideStrings^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestWideStrings*)_0->NativePtr;
    NativePtr = new ::TestWideStrings(__arg0);
}

System::IntPtr CommonTest::TestWideStrings::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestWideStrings::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestWideStrings*)object.ToPointer();
}

System::String^ CommonTest::TestWideStrings::WidePointer::get()
{
    auto __ret = ((::TestWideStrings*)NativePtr)->GetWidePointer();
    return (__ret == 0 ? nullptr : clix::marshalString<clix::E_UTF16>(__ret));
}

System::String^ CommonTest::TestWideStrings::WideNullPointer::get()
{
    auto __ret = ((::TestWideStrings*)NativePtr)->GetWideNullPointer();
    return (__ret == 0 ? nullptr : clix::marshalString<clix::E_UTF16>(__ret));
}

CommonTest::TestFixedArrays::TestFixedArrays(::TestFixedArrays* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestFixedArrays^ CommonTest::TestFixedArrays::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestFixedArrays((::TestFixedArrays*) native.ToPointer());
}

CommonTest::TestFixedArrays::~TestFixedArrays()
{
    delete NativePtr;
}

CommonTest::TestFixedArrays::TestFixedArrays()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestFixedArrays();
}

CommonTest::TestFixedArrays::TestFixedArrays(CommonTest::TestFixedArrays^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestFixedArrays*)_0->NativePtr;
    NativePtr = new ::TestFixedArrays(__arg0);
}

System::IntPtr CommonTest::TestFixedArrays::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestFixedArrays::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestFixedArrays*)object.ToPointer();
}
CommonTest::TestArraysPointers::TestArraysPointers(::TestArraysPointers* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestArraysPointers^ CommonTest::TestArraysPointers::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestArraysPointers((::TestArraysPointers*) native.ToPointer());
}

CommonTest::TestArraysPointers::~TestArraysPointers()
{
    delete NativePtr;
}

CommonTest::TestArraysPointers::TestArraysPointers(MyEnum* values, int count)
{
    __ownsNativeInstance = true;
    auto __arg0 = (::MyEnum)*values;
    NativePtr = new ::TestArraysPointers(&__arg0, count);
}

CommonTest::TestArraysPointers::TestArraysPointers(CommonTest::TestArraysPointers^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestArraysPointers*)_0->NativePtr;
    NativePtr = new ::TestArraysPointers(__arg0);
}

System::IntPtr CommonTest::TestArraysPointers::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestArraysPointers::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestArraysPointers*)object.ToPointer();
}

CommonTest::MyEnum CommonTest::TestArraysPointers::Value::get()
{
    return (CommonTest::MyEnum)((::TestArraysPointers*)NativePtr)->Value;
}

void CommonTest::TestArraysPointers::Value::set(CommonTest::MyEnum value)
{
    ((::TestArraysPointers*)NativePtr)->Value = (::MyEnum)value;
}

CommonTest::TestGetterSetterToProperties::TestGetterSetterToProperties(::TestGetterSetterToProperties* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestGetterSetterToProperties^ CommonTest::TestGetterSetterToProperties::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestGetterSetterToProperties((::TestGetterSetterToProperties*) native.ToPointer());
}

CommonTest::TestGetterSetterToProperties::~TestGetterSetterToProperties()
{
    delete NativePtr;
}

CommonTest::TestGetterSetterToProperties::TestGetterSetterToProperties()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestGetterSetterToProperties();
}

CommonTest::TestGetterSetterToProperties::TestGetterSetterToProperties(CommonTest::TestGetterSetterToProperties^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestGetterSetterToProperties*)_0->NativePtr;
    NativePtr = new ::TestGetterSetterToProperties(__arg0);
}

System::IntPtr CommonTest::TestGetterSetterToProperties::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestGetterSetterToProperties::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestGetterSetterToProperties*)object.ToPointer();
}

int CommonTest::TestGetterSetterToProperties::Width::get()
{
    auto __ret = ((::TestGetterSetterToProperties*)NativePtr)->getWidth();
    return __ret;
}

int CommonTest::TestGetterSetterToProperties::Height::get()
{
    auto __ret = ((::TestGetterSetterToProperties*)NativePtr)->getHeight();
    return __ret;
}

CommonTest::ClassA::ClassA(::ClassA* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ClassA^ CommonTest::ClassA::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ClassA((::ClassA*) native.ToPointer());
}

CommonTest::ClassA::~ClassA()
{
    delete NativePtr;
}

CommonTest::ClassA::ClassA(int value)
{
    __ownsNativeInstance = true;
    NativePtr = new ::ClassA(value);
}

CommonTest::ClassA::ClassA(CommonTest::ClassA^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassA*)_0->NativePtr;
    NativePtr = new ::ClassA(__arg0);
}

CommonTest::ClassA::operator CommonTest::ClassA^(int value)
{
    auto __ret = (::ClassA) value;
    auto ____ret = new ::ClassA(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::ClassA((::ClassA*)____ret);
}

System::IntPtr CommonTest::ClassA::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ClassA::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ClassA*)object.ToPointer();
}

int CommonTest::ClassA::Value::get()
{
    return ((::ClassA*)NativePtr)->Value;
}

void CommonTest::ClassA::Value::set(int value)
{
    ((::ClassA*)NativePtr)->Value = value;
}

CommonTest::ClassB::ClassB(::ClassB* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ClassB^ CommonTest::ClassB::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ClassB((::ClassB*) native.ToPointer());
}

CommonTest::ClassB::~ClassB()
{
    delete NativePtr;
}

CommonTest::ClassB::ClassB(CommonTest::ClassA^ x)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(x, nullptr))
        throw gcnew ::System::ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassA*)x->NativePtr;
    NativePtr = new ::ClassB(__arg0);
}

CommonTest::ClassB::ClassB(CommonTest::ClassB^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassB*)_0->NativePtr;
    NativePtr = new ::ClassB(__arg0);
}

CommonTest::ClassB::operator CommonTest::ClassB^(CommonTest::ClassA^ x)
{
    if (ReferenceEquals(x, nullptr))
        throw gcnew ::System::ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassA*)x->NativePtr;
    auto __ret = (::ClassB) __arg0;
    auto ____ret = new ::ClassB(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::ClassB((::ClassB*)____ret);
}

System::IntPtr CommonTest::ClassB::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ClassB::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ClassB*)object.ToPointer();
}

int CommonTest::ClassB::Value::get()
{
    return ((::ClassB*)NativePtr)->Value;
}

void CommonTest::ClassB::Value::set(int value)
{
    ((::ClassB*)NativePtr)->Value = value;
}

CommonTest::ClassC::ClassC(::ClassC* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ClassC^ CommonTest::ClassC::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ClassC((::ClassC*) native.ToPointer());
}

CommonTest::ClassC::~ClassC()
{
    delete NativePtr;
}

CommonTest::ClassC::ClassC(CommonTest::ClassA^ x)
{
    __ownsNativeInstance = true;
    auto __arg0 = (::ClassA*)x->NativePtr;
    NativePtr = new ::ClassC(__arg0);
}

CommonTest::ClassC::ClassC(CommonTest::ClassB^ x)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(x, nullptr))
        throw gcnew ::System::ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassB*)x->NativePtr;
    NativePtr = new ::ClassC(__arg0);
}

CommonTest::ClassC::ClassC(CommonTest::ClassC^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassC*)_0->NativePtr;
    NativePtr = new ::ClassC(__arg0);
}

CommonTest::ClassC::operator CommonTest::ClassC^(CommonTest::ClassB^ x)
{
    if (ReferenceEquals(x, nullptr))
        throw gcnew ::System::ArgumentNullException("x", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ClassB*)x->NativePtr;
    auto __ret = (::ClassC) __arg0;
    auto ____ret = new ::ClassC(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::ClassC((::ClassC*)____ret);
}

System::IntPtr CommonTest::ClassC::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ClassC::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ClassC*)object.ToPointer();
}

int CommonTest::ClassC::Value::get()
{
    return ((::ClassC*)NativePtr)->Value;
}

void CommonTest::ClassC::Value::set(int value)
{
    ((::ClassC*)NativePtr)->Value = value;
}

CommonTest::PureDtor::PureDtor(::PureDtor* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::PureDtor^ CommonTest::PureDtor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::PureDtor((::PureDtor*) native.ToPointer());
}

CommonTest::PureDtor::~PureDtor()
{
    delete NativePtr;
}

CommonTest::PureDtor::PureDtor()
{
    __ownsNativeInstance = true;
}

CommonTest::PureDtor::PureDtor(CommonTest::PureDtor^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::PureDtor::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::PureDtor::__Instance::set(System::IntPtr object)
{
    NativePtr = (::PureDtor*)object.ToPointer();
}
CommonTest::TestNestedTypes::AsTypes::Uchars::Uchars(::TestNestedTypes::as_types::uchars* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestNestedTypes::AsTypes::Uchars^ CommonTest::TestNestedTypes::AsTypes::Uchars::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestNestedTypes::AsTypes::Uchars((::TestNestedTypes::as_types::uchars*) native.ToPointer());
}

CommonTest::TestNestedTypes::AsTypes::Uchars::~Uchars()
{
    delete NativePtr;
}

CommonTest::TestNestedTypes::AsTypes::Uchars::Uchars()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestNestedTypes::as_types::uchars();
}

CommonTest::TestNestedTypes::AsTypes::Uchars::Uchars(CommonTest::TestNestedTypes::AsTypes::Uchars^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestNestedTypes::as_types::uchars*)_0->NativePtr;
    NativePtr = new ::TestNestedTypes::as_types::uchars(__arg0);
}

System::IntPtr CommonTest::TestNestedTypes::AsTypes::Uchars::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestNestedTypes::AsTypes::Uchars::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestNestedTypes::as_types::uchars*)object.ToPointer();
}

unsigned char CommonTest::TestNestedTypes::AsTypes::Uchars::Blue::get()
{
    return ((::TestNestedTypes::as_types::uchars*)NativePtr)->blue;
}

void CommonTest::TestNestedTypes::AsTypes::Uchars::Blue::set(unsigned char value)
{
    ((::TestNestedTypes::as_types::uchars*)NativePtr)->blue = value;
}

unsigned char CommonTest::TestNestedTypes::AsTypes::Uchars::Green::get()
{
    return ((::TestNestedTypes::as_types::uchars*)NativePtr)->green;
}

void CommonTest::TestNestedTypes::AsTypes::Uchars::Green::set(unsigned char value)
{
    ((::TestNestedTypes::as_types::uchars*)NativePtr)->green = value;
}

unsigned char CommonTest::TestNestedTypes::AsTypes::Uchars::Red::get()
{
    return ((::TestNestedTypes::as_types::uchars*)NativePtr)->red;
}

void CommonTest::TestNestedTypes::AsTypes::Uchars::Red::set(unsigned char value)
{
    ((::TestNestedTypes::as_types::uchars*)NativePtr)->red = value;
}

unsigned char CommonTest::TestNestedTypes::AsTypes::Uchars::Alpha::get()
{
    return ((::TestNestedTypes::as_types::uchars*)NativePtr)->alpha;
}

void CommonTest::TestNestedTypes::AsTypes::Uchars::Alpha::set(unsigned char value)
{
    ((::TestNestedTypes::as_types::uchars*)NativePtr)->alpha = value;
}

CommonTest::TestNestedTypes::AsTypes::AsTypes(::TestNestedTypes::as_types* native)
{
    __as_int = native->as_int;
    __as_uchar = (&native->as_uchar == nullptr) ? nullptr : gcnew CommonTest::TestNestedTypes::AsTypes::Uchars((::TestNestedTypes::as_types::uchars*)&native->as_uchar);
}

CommonTest::TestNestedTypes::AsTypes^ CommonTest::TestNestedTypes::AsTypes::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestNestedTypes::AsTypes((::TestNestedTypes::as_types*) native.ToPointer());
}

int CommonTest::TestNestedTypes::AsTypes::AsInt::get()
{
    return __as_int;
}

void CommonTest::TestNestedTypes::AsTypes::AsInt::set(int value)
{
    __as_int = value;
}

CommonTest::TestNestedTypes::AsTypes::Uchars^ CommonTest::TestNestedTypes::AsTypes::AsUchar::get()
{
    return __as_uchar;
}

void CommonTest::TestNestedTypes::AsTypes::AsUchar::set(CommonTest::TestNestedTypes::AsTypes::Uchars^ value)
{
    __as_uchar = value;
}

CommonTest::TestNestedTypes::TestNestedTypes(::TestNestedTypes* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestNestedTypes^ CommonTest::TestNestedTypes::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestNestedTypes((::TestNestedTypes*) native.ToPointer());
}

CommonTest::TestNestedTypes::~TestNestedTypes()
{
    delete NativePtr;
}

CommonTest::TestNestedTypes::TestNestedTypes()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestNestedTypes();
}

CommonTest::TestNestedTypes::TestNestedTypes(CommonTest::TestNestedTypes^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestNestedTypes*)_0->NativePtr;
    NativePtr = new ::TestNestedTypes(__arg0);
}

System::IntPtr CommonTest::TestNestedTypes::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestNestedTypes::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestNestedTypes*)object.ToPointer();
}
CommonTest::HasStdString::HasStdString(::HasStdString* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasStdString^ CommonTest::HasStdString::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasStdString((::HasStdString*) native.ToPointer());
}

CommonTest::HasStdString::~HasStdString()
{
    delete NativePtr;
}

System::String^ CommonTest::HasStdString::TestStdString(System::String^ s)
{
    auto __arg0 = clix::marshalString<clix::E_UTF8>(s);
    auto __ret = ((::HasStdString*)NativePtr)->testStdString(__arg0);
    return clix::marshalString<clix::E_UTF8>(__ret);
}

CommonTest::HasStdString::HasStdString()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasStdString();
}

CommonTest::HasStdString::HasStdString(CommonTest::HasStdString^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasStdString*)_0->NativePtr;
    NativePtr = new ::HasStdString(__arg0);
}

System::IntPtr CommonTest::HasStdString::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasStdString::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasStdString*)object.ToPointer();
}

System::String^ CommonTest::HasStdString::S::get()
{
    return clix::marshalString<clix::E_UTF8>(((::HasStdString*)NativePtr)->s);
}

void CommonTest::HasStdString::S::set(System::String^ value)
{
    ((::HasStdString*)NativePtr)->s = clix::marshalString<clix::E_UTF8>(value);
}

System::String^ CommonTest::HasStdString::StdString::get()
{
    auto &__ret = ((::HasStdString*)NativePtr)->getStdString();
    return (System::String^)(clix::marshalString<clix::E_UTF8>(__ret));
}

CommonTest::InternalCtorAmbiguity::InternalCtorAmbiguity(::InternalCtorAmbiguity* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::InternalCtorAmbiguity^ CommonTest::InternalCtorAmbiguity::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::InternalCtorAmbiguity((::InternalCtorAmbiguity*) native.ToPointer());
}

CommonTest::InternalCtorAmbiguity::~InternalCtorAmbiguity()
{
    delete NativePtr;
}

CommonTest::InternalCtorAmbiguity::InternalCtorAmbiguity(::System::IntPtr param)
{
    __ownsNativeInstance = true;
    auto __arg0 = (void*)param;
    NativePtr = new ::InternalCtorAmbiguity(__arg0);
}

CommonTest::InternalCtorAmbiguity::InternalCtorAmbiguity(CommonTest::InternalCtorAmbiguity^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::InternalCtorAmbiguity*)_0->NativePtr;
    NativePtr = new ::InternalCtorAmbiguity(__arg0);
}

System::IntPtr CommonTest::InternalCtorAmbiguity::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::InternalCtorAmbiguity::__Instance::set(System::IntPtr object)
{
    NativePtr = (::InternalCtorAmbiguity*)object.ToPointer();
}
CommonTest::InvokesInternalCtorAmbiguity::InvokesInternalCtorAmbiguity(::InvokesInternalCtorAmbiguity* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::InvokesInternalCtorAmbiguity^ CommonTest::InvokesInternalCtorAmbiguity::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::InvokesInternalCtorAmbiguity((::InvokesInternalCtorAmbiguity*) native.ToPointer());
}

CommonTest::InvokesInternalCtorAmbiguity::~InvokesInternalCtorAmbiguity()
{
    delete NativePtr;
}

CommonTest::InvokesInternalCtorAmbiguity::InvokesInternalCtorAmbiguity()
{
    __ownsNativeInstance = true;
    NativePtr = new ::InvokesInternalCtorAmbiguity();
}

CommonTest::InternalCtorAmbiguity^ CommonTest::InvokesInternalCtorAmbiguity::InvokeInternalCtor()
{
    auto __ret = ((::InvokesInternalCtorAmbiguity*)NativePtr)->InvokeInternalCtor();
    if (__ret == nullptr) return nullptr;
    return (__ret == nullptr) ? nullptr : gcnew CommonTest::InternalCtorAmbiguity((::InternalCtorAmbiguity*)__ret);
}

CommonTest::InvokesInternalCtorAmbiguity::InvokesInternalCtorAmbiguity(CommonTest::InvokesInternalCtorAmbiguity^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::InvokesInternalCtorAmbiguity*)_0->NativePtr;
    NativePtr = new ::InvokesInternalCtorAmbiguity(__arg0);
}

System::IntPtr CommonTest::InvokesInternalCtorAmbiguity::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::InvokesInternalCtorAmbiguity::__Instance::set(System::IntPtr object)
{
    NativePtr = (::InvokesInternalCtorAmbiguity*)object.ToPointer();
}
CommonTest::HasFriend::HasFriend(::HasFriend* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasFriend^ CommonTest::HasFriend::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasFriend((::HasFriend*) native.ToPointer());
}

CommonTest::HasFriend::~HasFriend()
{
    delete NativePtr;
}

CommonTest::HasFriend::HasFriend(int m)
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasFriend(m);
}

CommonTest::HasFriend::HasFriend(CommonTest::HasFriend^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasFriend*)_0->NativePtr;
    NativePtr = new ::HasFriend(__arg0);
}

CommonTest::HasFriend^ CommonTest::HasFriend::operator+(CommonTest::HasFriend^ f1, CommonTest::HasFriend^ f2)
{
    if (ReferenceEquals(f1, nullptr))
        throw gcnew ::System::ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasFriend*)f1->NativePtr;
    if (ReferenceEquals(f2, nullptr))
        throw gcnew ::System::ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
    auto &__arg1 = *(::HasFriend*)f2->NativePtr;
    auto __ret = __arg0 + __arg1;
    auto ____ret = new ::HasFriend(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::HasFriend((::HasFriend*)____ret);
}

CommonTest::HasFriend^ CommonTest::HasFriend::operator-(CommonTest::HasFriend^ f1, CommonTest::HasFriend^ f2)
{
    if (ReferenceEquals(f1, nullptr))
        throw gcnew ::System::ArgumentNullException("f1", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasFriend*)f1->NativePtr;
    if (ReferenceEquals(f2, nullptr))
        throw gcnew ::System::ArgumentNullException("f2", "Cannot be null because it is a C++ reference (&).");
    auto &__arg1 = *(::HasFriend*)f2->NativePtr;
    auto __ret = __arg0 - __arg1;
    auto ____ret = new ::HasFriend(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::HasFriend((::HasFriend*)____ret);
}

CommonTest::HasFriend::operator CommonTest::HasFriend^(int m)
{
    auto __ret = (::HasFriend) m;
    auto ____ret = new ::HasFriend(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::HasFriend((::HasFriend*)____ret);
}

System::IntPtr CommonTest::HasFriend::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasFriend::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasFriend*)object.ToPointer();
}

int CommonTest::HasFriend::M::get()
{
    auto __ret = ((::HasFriend*)NativePtr)->getM();
    return __ret;
}

CommonTest::DifferentConstOverloads::DifferentConstOverloads(::DifferentConstOverloads* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::DifferentConstOverloads^ CommonTest::DifferentConstOverloads::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DifferentConstOverloads((::DifferentConstOverloads*) native.ToPointer());
}

CommonTest::DifferentConstOverloads::~DifferentConstOverloads()
{
    delete NativePtr;
}

CommonTest::DifferentConstOverloads::DifferentConstOverloads()
{
    __ownsNativeInstance = true;
    NativePtr = new ::DifferentConstOverloads();
}

bool CommonTest::DifferentConstOverloads::operator==(CommonTest::DifferentConstOverloads^ __op, CommonTest::DifferentConstOverloads^ other)
{
    bool __opNull = ReferenceEquals(__op, nullptr);
    bool otherNull = ReferenceEquals(other, nullptr);
    if (__opNull || otherNull)
        return __opNull && otherNull;
    auto &__arg0 = *(::DifferentConstOverloads*)__op->NativePtr;
    auto &__arg1 = *(::DifferentConstOverloads*)other->NativePtr;
    auto __ret = __arg0 == __arg1;
    return __ret;
}

bool CommonTest::DifferentConstOverloads::Equals(::System::Object^ obj)
{
    return this == safe_cast<CommonTest::DifferentConstOverloads^>(obj);
}

bool CommonTest::DifferentConstOverloads::operator!=(CommonTest::DifferentConstOverloads^ __op, CommonTest::DifferentConstOverloads^ other)
{
    bool __opNull = ReferenceEquals(__op, nullptr);
    bool otherNull = ReferenceEquals(other, nullptr);
    if (__opNull || otherNull)
        return !(__opNull && otherNull);
    auto &__arg0 = *(::DifferentConstOverloads*)__op->NativePtr;
    auto &__arg1 = *(::DifferentConstOverloads*)other->NativePtr;
    auto __ret = __arg0 != __arg1;
    return __ret;
}

bool CommonTest::DifferentConstOverloads::operator==(CommonTest::DifferentConstOverloads^ __op, int number)
{
    bool __opNull = ReferenceEquals(__op, nullptr);
    bool numberNull = ReferenceEquals(number, nullptr);
    if (__opNull || numberNull)
        return __opNull && numberNull;
    auto &__arg0 = *(::DifferentConstOverloads*)__op->NativePtr;
    auto __ret = __arg0 == number;
    return __ret;
}

CommonTest::DifferentConstOverloads::DifferentConstOverloads(CommonTest::DifferentConstOverloads^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DifferentConstOverloads*)_0->NativePtr;
    NativePtr = new ::DifferentConstOverloads(__arg0);
}

System::IntPtr CommonTest::DifferentConstOverloads::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::DifferentConstOverloads::__Instance::set(System::IntPtr object)
{
    NativePtr = (::DifferentConstOverloads*)object.ToPointer();
}
CommonTest::TestNamingAnonymousTypesInUnion::TestNamingAnonymousTypesInUnion(::TestNamingAnonymousTypesInUnion* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestNamingAnonymousTypesInUnion^ CommonTest::TestNamingAnonymousTypesInUnion::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestNamingAnonymousTypesInUnion((::TestNamingAnonymousTypesInUnion*) native.ToPointer());
}

CommonTest::TestNamingAnonymousTypesInUnion::~TestNamingAnonymousTypesInUnion()
{
    delete NativePtr;
}

CommonTest::TestNamingAnonymousTypesInUnion::TestNamingAnonymousTypesInUnion()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestNamingAnonymousTypesInUnion();
}

CommonTest::TestNamingAnonymousTypesInUnion::TestNamingAnonymousTypesInUnion(CommonTest::TestNamingAnonymousTypesInUnion^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestNamingAnonymousTypesInUnion*)_0->NativePtr;
    NativePtr = new ::TestNamingAnonymousTypesInUnion(__arg0);
}

System::IntPtr CommonTest::TestNamingAnonymousTypesInUnion::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestNamingAnonymousTypesInUnion::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestNamingAnonymousTypesInUnion*)object.ToPointer();
}
CommonTest::RefTypeClassPassTry::RefTypeClassPassTry(::RefTypeClassPassTry* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::RefTypeClassPassTry^ CommonTest::RefTypeClassPassTry::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::RefTypeClassPassTry((::RefTypeClassPassTry*) native.ToPointer());
}

CommonTest::RefTypeClassPassTry::~RefTypeClassPassTry()
{
    delete NativePtr;
}

CommonTest::RefTypeClassPassTry::RefTypeClassPassTry()
{
    __ownsNativeInstance = true;
    NativePtr = new ::RefTypeClassPassTry();
}

CommonTest::RefTypeClassPassTry::RefTypeClassPassTry(CommonTest::RefTypeClassPassTry^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::RefTypeClassPassTry*)_0->NativePtr;
    NativePtr = new ::RefTypeClassPassTry(__arg0);
}

System::IntPtr CommonTest::RefTypeClassPassTry::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::RefTypeClassPassTry::__Instance::set(System::IntPtr object)
{
    NativePtr = (::RefTypeClassPassTry*)object.ToPointer();
}
CommonTest::ValueTypeArrays::ValueTypeArrays(::ValueTypeArrays* native)
{
    cli::array<float>^ __array0 = nullptr;
    if (native->firstValueTypeArrray != 0)
    {
        __array0 = gcnew cli::array<float>(5);
        for (int i = 0; i < 5; i++)
            __array0[i] = native->firstValueTypeArrray[i];
    }
    __firstValueTypeArrray = __array0;
    cli::array<int>^ __array1 = nullptr;
    if (native->secondValueTypeArray != 0)
    {
        __array1 = gcnew cli::array<int>(5);
        for (int i = 0; i < 5; i++)
            __array1[i] = native->secondValueTypeArray[i];
    }
    __secondValueTypeArray = __array1;
    cli::array<System::Char>^ __array2 = nullptr;
    if (native->thirdValueTypeArray != 0)
    {
        __array2 = gcnew cli::array<System::Char>(5);
        for (int i = 0; i < 5; i++)
            __array2[i] = native->thirdValueTypeArray[i];
    }
    __thirdValueTypeArray = __array2;
    __size = native->size;
}

CommonTest::ValueTypeArrays^ CommonTest::ValueTypeArrays::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ValueTypeArrays((::ValueTypeArrays*) native.ToPointer());
}

cli::array<float>^ CommonTest::ValueTypeArrays::FirstValueTypeArrray::get()
{
    return __firstValueTypeArrray;
}

void CommonTest::ValueTypeArrays::FirstValueTypeArrray::set(cli::array<float>^ value)
{
    __firstValueTypeArrray = value;
}

cli::array<int>^ CommonTest::ValueTypeArrays::SecondValueTypeArray::get()
{
    return __secondValueTypeArray;
}

void CommonTest::ValueTypeArrays::SecondValueTypeArray::set(cli::array<int>^ value)
{
    __secondValueTypeArray = value;
}

cli::array<System::Char>^ CommonTest::ValueTypeArrays::ThirdValueTypeArray::get()
{
    return __thirdValueTypeArray;
}

void CommonTest::ValueTypeArrays::ThirdValueTypeArray::set(cli::array<System::Char>^ value)
{
    __thirdValueTypeArray = value;
}

unsigned int CommonTest::ValueTypeArrays::Size::get()
{
    return __size;
}

void CommonTest::ValueTypeArrays::Size::set(unsigned int value)
{
    __size = value;
}

CommonTest::HasVirtualProperty::HasVirtualProperty(::HasVirtualProperty* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasVirtualProperty^ CommonTest::HasVirtualProperty::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasVirtualProperty((::HasVirtualProperty*) native.ToPointer());
}

CommonTest::HasVirtualProperty::~HasVirtualProperty()
{
    delete NativePtr;
}

CommonTest::HasVirtualProperty::HasVirtualProperty()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasVirtualProperty();
}

CommonTest::HasVirtualProperty::HasVirtualProperty(CommonTest::HasVirtualProperty^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasVirtualProperty*)_0->NativePtr;
    NativePtr = new ::HasVirtualProperty(__arg0);
}

System::IntPtr CommonTest::HasVirtualProperty::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasVirtualProperty::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasVirtualProperty*)object.ToPointer();
}

int CommonTest::HasVirtualProperty::Property::get()
{
    auto __ret = ((::HasVirtualProperty*)NativePtr)->getProperty();
    return __ret;
}

void CommonTest::HasVirtualProperty::Property::set(int target)
{
    ((::HasVirtualProperty*)NativePtr)->setProperty(target);
}

CommonTest::ChangedAccessOfInheritedProperty::ChangedAccessOfInheritedProperty(::ChangedAccessOfInheritedProperty* native)
    : CommonTest::HasVirtualProperty((::HasVirtualProperty*)native)
{
}

CommonTest::ChangedAccessOfInheritedProperty^ CommonTest::ChangedAccessOfInheritedProperty::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ChangedAccessOfInheritedProperty((::ChangedAccessOfInheritedProperty*) native.ToPointer());
}

CommonTest::ChangedAccessOfInheritedProperty::~ChangedAccessOfInheritedProperty()
{
}

CommonTest::ChangedAccessOfInheritedProperty::ChangedAccessOfInheritedProperty()
    : CommonTest::HasVirtualProperty((::HasVirtualProperty*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::ChangedAccessOfInheritedProperty();
}

CommonTest::ChangedAccessOfInheritedProperty::ChangedAccessOfInheritedProperty(CommonTest::ChangedAccessOfInheritedProperty^ _0)
    : CommonTest::HasVirtualProperty((::HasVirtualProperty*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ChangedAccessOfInheritedProperty*)_0->NativePtr;
    NativePtr = new ::ChangedAccessOfInheritedProperty(__arg0);
}

CommonTest::Empty::Empty(::Empty* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Empty^ CommonTest::Empty::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Empty((::Empty*) native.ToPointer());
}

CommonTest::Empty::~Empty()
{
    delete NativePtr;
}

CommonTest::Empty::Empty()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Empty();
}

CommonTest::Empty::Empty(CommonTest::Empty^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Empty*)_0->NativePtr;
    NativePtr = new ::Empty(__arg0);
}

System::IntPtr CommonTest::Empty::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Empty::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Empty*)object.ToPointer();
}
CommonTest::ReturnsEmpty::ReturnsEmpty(::ReturnsEmpty* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::ReturnsEmpty^ CommonTest::ReturnsEmpty::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ReturnsEmpty((::ReturnsEmpty*) native.ToPointer());
}

CommonTest::ReturnsEmpty::~ReturnsEmpty()
{
    delete NativePtr;
}

CommonTest::ReturnsEmpty::ReturnsEmpty()
{
    __ownsNativeInstance = true;
    NativePtr = new ::ReturnsEmpty();
}

CommonTest::ReturnsEmpty::ReturnsEmpty(CommonTest::ReturnsEmpty^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::ReturnsEmpty*)_0->NativePtr;
    NativePtr = new ::ReturnsEmpty(__arg0);
}

System::IntPtr CommonTest::ReturnsEmpty::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::ReturnsEmpty::__Instance::set(System::IntPtr object)
{
    NativePtr = (::ReturnsEmpty*)object.ToPointer();
}

CommonTest::Empty^ CommonTest::ReturnsEmpty::Empty::get()
{
    auto __ret = ((::ReturnsEmpty*)NativePtr)->getEmpty();
    auto ____ret = new ::Empty(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::Empty((::Empty*)____ret);
}

CommonTest::ValueTypeClassPassTry::ValueTypeClassPassTry(::ValueTypeClassPassTry* native)
{
}

CommonTest::ValueTypeClassPassTry^ CommonTest::ValueTypeClassPassTry::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::ValueTypeClassPassTry((::ValueTypeClassPassTry*) native.ToPointer());
}

CommonTest::HasProblematicFields::HasProblematicFields(::HasProblematicFields* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasProblematicFields^ CommonTest::HasProblematicFields::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasProblematicFields((::HasProblematicFields*) native.ToPointer());
}

CommonTest::HasProblematicFields::~HasProblematicFields()
{
    delete NativePtr;
}

CommonTest::HasProblematicFields::HasProblematicFields()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasProblematicFields();
}

CommonTest::HasProblematicFields::HasProblematicFields(CommonTest::HasProblematicFields^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasProblematicFields*)_0->NativePtr;
    NativePtr = new ::HasProblematicFields(__arg0);
}

System::IntPtr CommonTest::HasProblematicFields::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasProblematicFields::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasProblematicFields*)object.ToPointer();
}

bool CommonTest::HasProblematicFields::B::get()
{
    return ((::HasProblematicFields*)NativePtr)->b;
}

void CommonTest::HasProblematicFields::B::set(bool value)
{
    ((::HasProblematicFields*)NativePtr)->b = value;
}

System::Char CommonTest::HasProblematicFields::C::get()
{
    return ((::HasProblematicFields*)NativePtr)->c;
}

void CommonTest::HasProblematicFields::C::set(System::Char value)
{
    ((::HasProblematicFields*)NativePtr)->c = value;
}

CommonTest::HasVirtualReturningHasProblematicFields::HasVirtualReturningHasProblematicFields(::HasVirtualReturningHasProblematicFields* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasVirtualReturningHasProblematicFields^ CommonTest::HasVirtualReturningHasProblematicFields::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasVirtualReturningHasProblematicFields((::HasVirtualReturningHasProblematicFields*) native.ToPointer());
}

CommonTest::HasVirtualReturningHasProblematicFields::~HasVirtualReturningHasProblematicFields()
{
    delete NativePtr;
}

CommonTest::HasVirtualReturningHasProblematicFields::HasVirtualReturningHasProblematicFields()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasVirtualReturningHasProblematicFields();
}

CommonTest::HasVirtualReturningHasProblematicFields::HasVirtualReturningHasProblematicFields(CommonTest::HasVirtualReturningHasProblematicFields^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasVirtualReturningHasProblematicFields*)_0->NativePtr;
    NativePtr = new ::HasVirtualReturningHasProblematicFields(__arg0);
}

System::IntPtr CommonTest::HasVirtualReturningHasProblematicFields::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasVirtualReturningHasProblematicFields::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasVirtualReturningHasProblematicFields*)object.ToPointer();
}

CommonTest::HasProblematicFields^ CommonTest::HasVirtualReturningHasProblematicFields::ReturnsProblematicFields::get()
{
    auto __ret = ((::HasVirtualReturningHasProblematicFields*)NativePtr)->returnsProblematicFields();
    auto ____ret = new ::HasProblematicFields(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::HasProblematicFields((::HasProblematicFields*)____ret);
}

CommonTest::BaseClassVirtual::BaseClassVirtual(::BaseClassVirtual* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::BaseClassVirtual^ CommonTest::BaseClassVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::BaseClassVirtual((::BaseClassVirtual*) native.ToPointer());
}

CommonTest::BaseClassVirtual::~BaseClassVirtual()
{
    delete NativePtr;
}

int CommonTest::BaseClassVirtual::RetInt(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = ((::BaseClassVirtual*)NativePtr)->retInt(__arg0);
    return __ret;
}

CommonTest::BaseClassVirtual::BaseClassVirtual()
{
    __ownsNativeInstance = true;
    NativePtr = new ::BaseClassVirtual();
}

CommonTest::BaseClassVirtual::BaseClassVirtual(CommonTest::BaseClassVirtual^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::BaseClassVirtual*)_0->NativePtr;
    NativePtr = new ::BaseClassVirtual(__arg0);
}

System::IntPtr CommonTest::BaseClassVirtual::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::BaseClassVirtual::__Instance::set(System::IntPtr object)
{
    NativePtr = (::BaseClassVirtual*)object.ToPointer();
}

CommonTest::BaseClassVirtual^ CommonTest::BaseClassVirtual::Base::get()
{
    auto __ret = ::BaseClassVirtual::getBase();
    auto ____ret = new ::BaseClassVirtual(__ret);
    return (____ret == nullptr) ? nullptr : gcnew CommonTest::BaseClassVirtual((::BaseClassVirtual*)____ret);
}

CommonTest::DerivedClassVirtual::DerivedClassVirtual(::DerivedClassVirtual* native)
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)native)
{
}

CommonTest::DerivedClassVirtual^ CommonTest::DerivedClassVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DerivedClassVirtual((::DerivedClassVirtual*) native.ToPointer());
}

CommonTest::DerivedClassVirtual::~DerivedClassVirtual()
{
}

int CommonTest::DerivedClassVirtual::RetInt(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = ((::DerivedClassVirtual*)NativePtr)->retInt(__arg0);
    return __ret;
}

CommonTest::DerivedClassVirtual::DerivedClassVirtual()
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::DerivedClassVirtual();
}

CommonTest::DerivedClassVirtual::DerivedClassVirtual(CommonTest::DerivedClassVirtual^ _0)
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DerivedClassVirtual*)_0->NativePtr;
    NativePtr = new ::DerivedClassVirtual(__arg0);
}

CommonTest::DerivedClassAbstractVirtual::DerivedClassAbstractVirtual(::DerivedClassAbstractVirtual* native)
    : CommonTest::DerivedClassVirtual((::DerivedClassVirtual*)native)
{
}

CommonTest::DerivedClassAbstractVirtual^ CommonTest::DerivedClassAbstractVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DerivedClassAbstractVirtual((::DerivedClassAbstractVirtual*) native.ToPointer());
}

CommonTest::DerivedClassAbstractVirtual::~DerivedClassAbstractVirtual()
{
}

int CommonTest::DerivedClassAbstractVirtual::RetInt(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = ((::DerivedClassAbstractVirtual*)NativePtr)->retInt(__arg0);
    return __ret;
}

CommonTest::DerivedClassAbstractVirtual::DerivedClassAbstractVirtual()
    : CommonTest::DerivedClassVirtual((::DerivedClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
}

CommonTest::DerivedClassAbstractVirtual::DerivedClassAbstractVirtual(CommonTest::DerivedClassAbstractVirtual^ _0)
    : CommonTest::DerivedClassVirtual((::DerivedClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
}

CommonTest::DerivedClassOverrideAbstractVirtual::DerivedClassOverrideAbstractVirtual(::DerivedClassOverrideAbstractVirtual* native)
    : CommonTest::DerivedClassAbstractVirtual((::DerivedClassAbstractVirtual*)native)
{
}

CommonTest::DerivedClassOverrideAbstractVirtual^ CommonTest::DerivedClassOverrideAbstractVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DerivedClassOverrideAbstractVirtual((::DerivedClassOverrideAbstractVirtual*) native.ToPointer());
}

CommonTest::DerivedClassOverrideAbstractVirtual::~DerivedClassOverrideAbstractVirtual()
{
}

CommonTest::DerivedClassOverrideAbstractVirtual::DerivedClassOverrideAbstractVirtual()
    : CommonTest::DerivedClassAbstractVirtual((::DerivedClassAbstractVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::DerivedClassOverrideAbstractVirtual();
}

int CommonTest::DerivedClassOverrideAbstractVirtual::RetInt(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = ((::DerivedClassOverrideAbstractVirtual*)NativePtr)->retInt(__arg0);
    return __ret;
}

CommonTest::DerivedClassOverrideAbstractVirtual::DerivedClassOverrideAbstractVirtual(CommonTest::DerivedClassOverrideAbstractVirtual^ _0)
    : CommonTest::DerivedClassAbstractVirtual((::DerivedClassAbstractVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DerivedClassOverrideAbstractVirtual*)_0->NativePtr;
    NativePtr = new ::DerivedClassOverrideAbstractVirtual(__arg0);
}

CommonTest::BufferForVirtualFunction::BufferForVirtualFunction(::BufferForVirtualFunction* native)
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)native)
{
}

CommonTest::BufferForVirtualFunction^ CommonTest::BufferForVirtualFunction::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::BufferForVirtualFunction((::BufferForVirtualFunction*) native.ToPointer());
}

CommonTest::BufferForVirtualFunction::~BufferForVirtualFunction()
{
}

CommonTest::BufferForVirtualFunction::BufferForVirtualFunction()
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::BufferForVirtualFunction();
}

CommonTest::BufferForVirtualFunction::BufferForVirtualFunction(CommonTest::BufferForVirtualFunction^ _0)
    : CommonTest::BaseClassVirtual((::BaseClassVirtual*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::BufferForVirtualFunction*)_0->NativePtr;
    NativePtr = new ::BufferForVirtualFunction(__arg0);
}

CommonTest::OverridesNonDirectVirtual::OverridesNonDirectVirtual(::OverridesNonDirectVirtual* native)
    : CommonTest::BufferForVirtualFunction((::BufferForVirtualFunction*)native)
{
}

CommonTest::OverridesNonDirectVirtual^ CommonTest::OverridesNonDirectVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::OverridesNonDirectVirtual((::OverridesNonDirectVirtual*) native.ToPointer());
}

CommonTest::OverridesNonDirectVirtual::~OverridesNonDirectVirtual()
{
}

CommonTest::OverridesNonDirectVirtual::OverridesNonDirectVirtual()
    : CommonTest::BufferForVirtualFunction((::BufferForVirtualFunction*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::OverridesNonDirectVirtual();
}

int CommonTest::OverridesNonDirectVirtual::RetInt(CommonTest::Foo^ foo)
{
    if (ReferenceEquals(foo, nullptr))
        throw gcnew ::System::ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Foo*)foo->NativePtr;
    auto __ret = ((::OverridesNonDirectVirtual*)NativePtr)->retInt(__arg0);
    return __ret;
}

CommonTest::OverridesNonDirectVirtual::OverridesNonDirectVirtual(CommonTest::OverridesNonDirectVirtual^ _0)
    : CommonTest::BufferForVirtualFunction((::BufferForVirtualFunction*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::OverridesNonDirectVirtual*)_0->NativePtr;
    NativePtr = new ::OverridesNonDirectVirtual(__arg0);
}

CommonTest::AbstractWithVirtualDtor::AbstractWithVirtualDtor(::AbstractWithVirtualDtor* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::AbstractWithVirtualDtor^ CommonTest::AbstractWithVirtualDtor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::AbstractWithVirtualDtor((::AbstractWithVirtualDtor*) native.ToPointer());
}

CommonTest::AbstractWithVirtualDtor::~AbstractWithVirtualDtor()
{
    delete NativePtr;
}

CommonTest::AbstractWithVirtualDtor::AbstractWithVirtualDtor()
{
    __ownsNativeInstance = true;
}

void CommonTest::AbstractWithVirtualDtor::Abstract()
{
    ((::AbstractWithVirtualDtor*)NativePtr)->abstract();
}

CommonTest::AbstractWithVirtualDtor::AbstractWithVirtualDtor(CommonTest::AbstractWithVirtualDtor^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::AbstractWithVirtualDtor::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::AbstractWithVirtualDtor::__Instance::set(System::IntPtr object)
{
    NativePtr = (::AbstractWithVirtualDtor*)object.ToPointer();
}
CommonTest::NonTrivialDtorBase::NonTrivialDtorBase(::NonTrivialDtorBase* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::NonTrivialDtorBase^ CommonTest::NonTrivialDtorBase::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::NonTrivialDtorBase((::NonTrivialDtorBase*) native.ToPointer());
}

CommonTest::NonTrivialDtorBase::~NonTrivialDtorBase()
{
    delete NativePtr;
}

CommonTest::NonTrivialDtorBase::NonTrivialDtorBase()
{
    __ownsNativeInstance = true;
    NativePtr = new ::NonTrivialDtorBase();
}

CommonTest::NonTrivialDtorBase::NonTrivialDtorBase(CommonTest::NonTrivialDtorBase^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::NonTrivialDtorBase*)_0->NativePtr;
    NativePtr = new ::NonTrivialDtorBase(__arg0);
}

System::IntPtr CommonTest::NonTrivialDtorBase::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::NonTrivialDtorBase::__Instance::set(System::IntPtr object)
{
    NativePtr = (::NonTrivialDtorBase*)object.ToPointer();
}
CommonTest::NonTrivialDtor::NonTrivialDtor(::NonTrivialDtor* native)
    : CommonTest::NonTrivialDtorBase((::NonTrivialDtorBase*)native)
{
}

CommonTest::NonTrivialDtor^ CommonTest::NonTrivialDtor::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::NonTrivialDtor((::NonTrivialDtor*) native.ToPointer());
}

CommonTest::NonTrivialDtor::~NonTrivialDtor()
{
    if (NativePtr)
    {
        auto __nativePtr = NativePtr;
        NativePtr = 0;
        delete (::NonTrivialDtor*) __nativePtr;
    }
}

CommonTest::NonTrivialDtor::NonTrivialDtor()
    : CommonTest::NonTrivialDtorBase((::NonTrivialDtorBase*)nullptr)
{
    __ownsNativeInstance = true;
    NativePtr = new ::NonTrivialDtor();
}

CommonTest::NonTrivialDtor::NonTrivialDtor(CommonTest::NonTrivialDtor^ _0)
    : CommonTest::NonTrivialDtorBase((::NonTrivialDtorBase*)nullptr)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::NonTrivialDtor*)_0->NativePtr;
    NativePtr = new ::NonTrivialDtor(__arg0);
}

bool CommonTest::NonTrivialDtor::dtorCalled::get()
{
    auto __ret = ::NonTrivialDtor::getDtorCalled();
    return __ret;
}

void CommonTest::NonTrivialDtor::dtorCalled::set(bool value)
{
    ::NonTrivialDtor::setDtorCalled(value);
}

CommonTest::DerivedFromTemplateInstantiationWithVirtual::DerivedFromTemplateInstantiationWithVirtual(::DerivedFromTemplateInstantiationWithVirtual* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::DerivedFromTemplateInstantiationWithVirtual^ CommonTest::DerivedFromTemplateInstantiationWithVirtual::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::DerivedFromTemplateInstantiationWithVirtual((::DerivedFromTemplateInstantiationWithVirtual*) native.ToPointer());
}

CommonTest::DerivedFromTemplateInstantiationWithVirtual::~DerivedFromTemplateInstantiationWithVirtual()
{
    delete NativePtr;
}

CommonTest::DerivedFromTemplateInstantiationWithVirtual::DerivedFromTemplateInstantiationWithVirtual()
{
    __ownsNativeInstance = true;
    NativePtr = new ::DerivedFromTemplateInstantiationWithVirtual();
}

CommonTest::DerivedFromTemplateInstantiationWithVirtual::DerivedFromTemplateInstantiationWithVirtual(CommonTest::DerivedFromTemplateInstantiationWithVirtual^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::DerivedFromTemplateInstantiationWithVirtual*)_0->NativePtr;
    NativePtr = new ::DerivedFromTemplateInstantiationWithVirtual(__arg0);
}

System::IntPtr CommonTest::DerivedFromTemplateInstantiationWithVirtual::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::DerivedFromTemplateInstantiationWithVirtual::__Instance::set(System::IntPtr object)
{
    NativePtr = (::DerivedFromTemplateInstantiationWithVirtual*)object.ToPointer();
}
CommonTest::UnionT::UnionT(::union_t* native)
{
    __c = native->c;
}

CommonTest::UnionT^ CommonTest::UnionT::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::UnionT((::union_t*) native.ToPointer());
}

int CommonTest::UnionT::C::get()
{
    return __c;
}

void CommonTest::UnionT::C::set(int value)
{
    __c = value;
}

CommonTest::HasProtectedEnum::HasProtectedEnum(::HasProtectedEnum* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasProtectedEnum^ CommonTest::HasProtectedEnum::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasProtectedEnum((::HasProtectedEnum*) native.ToPointer());
}

CommonTest::HasProtectedEnum::~HasProtectedEnum()
{
    delete NativePtr;
}

CommonTest::HasProtectedEnum::HasProtectedEnum()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasProtectedEnum();
}

CommonTest::HasProtectedEnum::HasProtectedEnum(CommonTest::HasProtectedEnum^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasProtectedEnum*)_0->NativePtr;
    NativePtr = new ::HasProtectedEnum(__arg0);
}

System::IntPtr CommonTest::HasProtectedEnum::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasProtectedEnum::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasProtectedEnum*)object.ToPointer();
}
CommonTest::TestsTypes::TestsTypes(::TestsTypes* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::TestsTypes^ CommonTest::TestsTypes::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::TestsTypes((::TestsTypes*) native.ToPointer());
}

CommonTest::TestsTypes::~TestsTypes()
{
    delete NativePtr;
}

CommonTest::TestsTypes::TestsTypes()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestsTypes();
}

CommonTest::TestsTypes::TestsTypes(CommonTest::TestsTypes^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestsTypes*)_0->NativePtr;
    NativePtr = new ::TestsTypes(__arg0);
}

System::IntPtr CommonTest::TestsTypes::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::TestsTypes::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestsTypes*)object.ToPointer();
}
CommonTest::UsesSpecialisationOfVoid::UsesSpecialisationOfVoid(::UsesSpecialisationOfVoid* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::UsesSpecialisationOfVoid^ CommonTest::UsesSpecialisationOfVoid::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::UsesSpecialisationOfVoid((::UsesSpecialisationOfVoid*) native.ToPointer());
}

CommonTest::UsesSpecialisationOfVoid::~UsesSpecialisationOfVoid()
{
    delete NativePtr;
}

CommonTest::UsesSpecialisationOfVoid::UsesSpecialisationOfVoid()
{
    __ownsNativeInstance = true;
    NativePtr = new ::UsesSpecialisationOfVoid();
}

CommonTest::UsesSpecialisationOfVoid::UsesSpecialisationOfVoid(CommonTest::UsesSpecialisationOfVoid^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::UsesSpecialisationOfVoid*)_0->NativePtr;
    NativePtr = new ::UsesSpecialisationOfVoid(__arg0);
}

System::IntPtr CommonTest::UsesSpecialisationOfVoid::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::UsesSpecialisationOfVoid::__Instance::set(System::IntPtr object)
{
    NativePtr = (::UsesSpecialisationOfVoid*)object.ToPointer();
}
CommonTest::HasAbstractOperator::HasAbstractOperator(::HasAbstractOperator* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasAbstractOperator^ CommonTest::HasAbstractOperator::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasAbstractOperator((::HasAbstractOperator*) native.ToPointer());
}

CommonTest::HasAbstractOperator::~HasAbstractOperator()
{
    delete NativePtr;
}

CommonTest::HasAbstractOperator::HasAbstractOperator()
{
    __ownsNativeInstance = true;
}

CommonTest::HasAbstractOperator::HasAbstractOperator(CommonTest::HasAbstractOperator^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::HasAbstractOperator::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasAbstractOperator::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasAbstractOperator*)object.ToPointer();
}
CommonTest::HasSystemBase::HasSystemBase(::HasSystemBase* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasSystemBase^ CommonTest::HasSystemBase::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasSystemBase((::HasSystemBase*) native.ToPointer());
}

CommonTest::HasSystemBase::~HasSystemBase()
{
    delete NativePtr;
}

CommonTest::HasSystemBase::HasSystemBase()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasSystemBase();
}

CommonTest::HasSystemBase::HasSystemBase(CommonTest::HasSystemBase^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasSystemBase*)_0->NativePtr;
    NativePtr = new ::HasSystemBase(__arg0);
}

System::IntPtr CommonTest::HasSystemBase::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasSystemBase::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasSystemBase*)object.ToPointer();
}
CommonTest::HasLongDoubles::HasLongDoubles(::HasLongDoubles* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasLongDoubles^ CommonTest::HasLongDoubles::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasLongDoubles((::HasLongDoubles*) native.ToPointer());
}

CommonTest::HasLongDoubles::~HasLongDoubles()
{
    delete NativePtr;
}

CommonTest::HasLongDoubles::HasLongDoubles()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasLongDoubles();
}

CommonTest::HasLongDoubles::HasLongDoubles(CommonTest::HasLongDoubles^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasLongDoubles*)_0->NativePtr;
    NativePtr = new ::HasLongDoubles(__arg0);
}

System::IntPtr CommonTest::HasLongDoubles::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasLongDoubles::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasLongDoubles*)object.ToPointer();
}
CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::HasOverloadsWithDifferentPointerKindsToSameType(::HasOverloadsWithDifferentPointerKindsToSameType* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::HasOverloadsWithDifferentPointerKindsToSameType^ CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::HasOverloadsWithDifferentPointerKindsToSameType((::HasOverloadsWithDifferentPointerKindsToSameType*) native.ToPointer());
}

CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::~HasOverloadsWithDifferentPointerKindsToSameType()
{
    delete NativePtr;
}

CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::HasOverloadsWithDifferentPointerKindsToSameType()
{
    __ownsNativeInstance = true;
    NativePtr = new ::HasOverloadsWithDifferentPointerKindsToSameType();
}

void CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::Overload([System::Runtime::InteropServices::In, System::Runtime::InteropServices::Out] int% i)
{
    int __arg0 = i;
    ((::HasOverloadsWithDifferentPointerKindsToSameType*)NativePtr)->overload(__arg0);
    i = __arg0;
}

void CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::dispose()
{
    ((::HasOverloadsWithDifferentPointerKindsToSameType*)NativePtr)->dispose();
}

CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::HasOverloadsWithDifferentPointerKindsToSameType(CommonTest::HasOverloadsWithDifferentPointerKindsToSameType^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::HasOverloadsWithDifferentPointerKindsToSameType*)_0->NativePtr;
    NativePtr = new ::HasOverloadsWithDifferentPointerKindsToSameType(__arg0);
}

System::IntPtr CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::HasOverloadsWithDifferentPointerKindsToSameType::__Instance::set(System::IntPtr object)
{
    NativePtr = (::HasOverloadsWithDifferentPointerKindsToSameType*)object.ToPointer();
}
void CommonTest::DelegateNamespace::Common::F2(CommonTest::DelegateNamespace::__AnonymousDelegate0^ _0)
{
    auto __arg0 = static_cast<void (*)()>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_0).ToPointer());
    ::DelegateNamespace::f2(__arg0);
}

void CommonTest::DelegateNamespace::Nested::Common::F1(CommonTest::DelegateNamespace::Nested::__AnonymousDelegate0^ _0)
{
    auto __arg0 = static_cast<void (*)()>(System::Runtime::InteropServices::Marshal::GetFunctionPointerForDelegate(_0).ToPointer());
    ::DelegateNamespace::Nested::f1(__arg0);
}

CommonTest::SomeNamespace::AbstractClass::AbstractClass(::SomeNamespace::AbstractClass* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::SomeNamespace::AbstractClass^ CommonTest::SomeNamespace::AbstractClass::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::SomeNamespace::AbstractClass((::SomeNamespace::AbstractClass*) native.ToPointer());
}

CommonTest::SomeNamespace::AbstractClass::~AbstractClass()
{
    delete NativePtr;
}

void CommonTest::SomeNamespace::AbstractClass::AbstractMethod()
{
    ((::SomeNamespace::AbstractClass*)NativePtr)->AbstractMethod();
}

CommonTest::SomeNamespace::AbstractClass::AbstractClass()
{
    __ownsNativeInstance = true;
}

CommonTest::SomeNamespace::AbstractClass::AbstractClass(CommonTest::SomeNamespace::AbstractClass^ _0)
{
    __ownsNativeInstance = true;
}

System::IntPtr CommonTest::SomeNamespace::AbstractClass::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::SomeNamespace::AbstractClass::__Instance::set(System::IntPtr object)
{
    NativePtr = (::SomeNamespace::AbstractClass*)object.ToPointer();
}
CommonTest::Boost::Detail::SwallowAssign::SwallowAssign(::boost::detail::swallow_assign* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CommonTest::Boost::Detail::SwallowAssign^ CommonTest::Boost::Detail::SwallowAssign::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CommonTest::Boost::Detail::SwallowAssign((::boost::detail::swallow_assign*) native.ToPointer());
}

CommonTest::Boost::Detail::SwallowAssign::~SwallowAssign()
{
    delete NativePtr;
}

CommonTest::Boost::Detail::SwallowAssign::SwallowAssign(CommonTest::Boost::Detail::SwallowAssign^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::boost::detail::swallow_assign*)_0->NativePtr;
    NativePtr = new ::boost::detail::swallow_assign(__arg0);
}

System::IntPtr CommonTest::Boost::Detail::SwallowAssign::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CommonTest::Boost::Detail::SwallowAssign::__Instance::set(System::IntPtr object)
{
    NativePtr = (::boost::detail::swallow_assign*)object.ToPointer();
}
