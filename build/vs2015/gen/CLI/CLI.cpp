// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include "CLI.h"

#include <sstream>

using namespace System;
using namespace System::Runtime::InteropServices;

CLI::Types::Types(::Types* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CLI::Types^ CLI::Types::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CLI::Types((::Types*) native.ToPointer());
}

CLI::Types::~Types()
{
    delete NativePtr;
}

CLI::Types::!Types()
{
    delete NativePtr;
}

int CLI::Types::AttributedSum(int _0, int _1)
{
    auto __ret = ((::Types*)NativePtr)->AttributedSum(_0, _1);
    return __ret;
}

CLI::Types::Types()
{
    __ownsNativeInstance = true;
    NativePtr = new ::Types();
}

CLI::Types::Types(::CLI::Types^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Types*)_0->NativePtr;
    NativePtr = new ::Types(__arg0);
}

bool CLI::Types::Equals(System::Object^ object)
{
    if (!object) return false;
    auto obj = dynamic_cast<Types^>(object);

    if (!obj) return false;
    return __Instance == obj->__Instance;
}

int CLI::Types::GetHashCode()
{
    return (int)NativePtr;
}

System::IntPtr CLI::Types::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CLI::Types::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Types*)object.ToPointer();
}
CLI::TestProtectedDestructors::TestProtectedDestructors(::TestProtectedDestructors* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CLI::TestProtectedDestructors^ CLI::TestProtectedDestructors::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CLI::TestProtectedDestructors((::TestProtectedDestructors*) native.ToPointer());
}

CLI::TestProtectedDestructors::TestProtectedDestructors()
{
    __ownsNativeInstance = true;
    NativePtr = new ::TestProtectedDestructors();
}

CLI::TestProtectedDestructors::TestProtectedDestructors(::CLI::TestProtectedDestructors^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::TestProtectedDestructors*)_0->NativePtr;
    NativePtr = new ::TestProtectedDestructors(__arg0);
}

bool CLI::TestProtectedDestructors::Equals(System::Object^ object)
{
    if (!object) return false;
    auto obj = dynamic_cast<TestProtectedDestructors^>(object);

    if (!obj) return false;
    return __Instance == obj->__Instance;
}

int CLI::TestProtectedDestructors::GetHashCode()
{
    return (int)NativePtr;
}

System::IntPtr CLI::TestProtectedDestructors::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CLI::TestProtectedDestructors::__Instance::set(System::IntPtr object)
{
    NativePtr = (::TestProtectedDestructors*)object.ToPointer();
}
CLI::Date::Date(::Date* native)
    : __ownsNativeInstance(false)
{
    NativePtr = native;
}

CLI::Date^ CLI::Date::__CreateInstance(::System::IntPtr native)
{
    return gcnew ::CLI::Date((::Date*) native.ToPointer());
}

CLI::Date::~Date()
{
    delete NativePtr;
}

CLI::Date::!Date()
{
    delete NativePtr;
}

CLI::Date::Date(int m, int d, int y)
{
    __ownsNativeInstance = true;
    NativePtr = new ::Date(m, d, y);
}

System::String^ CLI::Date::TestStdString(System::String^ s)
{
    auto __arg0 = clix::marshalString<clix::E_UTF8>(s);
    auto __ret = ((::Date*)NativePtr)->testStdString(__arg0);
    return clix::marshalString<clix::E_UTF8>(__ret);
}

CLI::Date::Date(::CLI::Date^ _0)
{
    __ownsNativeInstance = true;
    if (ReferenceEquals(_0, nullptr))
        throw gcnew ::System::ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
    auto &__arg0 = *(::Date*)_0->NativePtr;
    NativePtr = new ::Date(__arg0);
}

System::String^ CLI::Date::ToString()
{
    std::ostringstream os;
    os << *NativePtr;
    return clix::marshalString<clix::E_UTF8>(os.str());
}

bool CLI::Date::Equals(System::Object^ object)
{
    if (!object) return false;
    auto obj = dynamic_cast<Date^>(object);

    if (!obj) return false;
    return __Instance == obj->__Instance;
}

int CLI::Date::GetHashCode()
{
    return (int)NativePtr;
}

System::IntPtr CLI::Date::__Instance::get()
{
    return System::IntPtr(NativePtr);
}

void CLI::Date::__Instance::set(System::IntPtr object)
{
    NativePtr = (::Date*)object.ToPointer();
}

int CLI::Date::Mo::get()
{
    return ((::Date*)NativePtr)->mo;
}

void CLI::Date::Mo::set(int value)
{
    ((::Date*)NativePtr)->mo = value;
}

int CLI::Date::Da::get()
{
    return ((::Date*)NativePtr)->da;
}

void CLI::Date::Da::set(int value)
{
    ((::Date*)NativePtr)->da = value;
}

int CLI::Date::Yr::get()
{
    return ((::Date*)NativePtr)->yr;
}

void CLI::Date::Yr::set(int value)
{
    ((::Date*)NativePtr)->yr = value;
}

void CLI::CLI::TestFreeFunction()
{
    ::testFreeFunction();
}

