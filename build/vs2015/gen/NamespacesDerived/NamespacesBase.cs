// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.CompilerServices;
using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("NamespacesDerived.CSharp")]

[assembly:InternalsVisibleTo("NamespacesDerived")]

namespace NamespacesBase
{
    namespace TemplateClass
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::NamespacesBase.TemplateClass._.__Internal _;
        }


        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }
        }
    }

    public unsafe partial class Base : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int b;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?parent@Base@@QAEHXZ")]
            internal static extern int Parent_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.Base> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.Base>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NamespacesBase.Base __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Base(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesBase.Base __CreateInstance(global::NamespacesBase.Base.__Internal native, bool skipVTables = false)
        {
            return new Base(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesBase.Base.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base.__Internal));
            *(global::NamespacesBase.Base.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Base(global::NamespacesBase.Base.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Base(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Base(int i)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), i);
        }

        public Base()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public Base(global::NamespacesBase.Base _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::NamespacesBase.Base.__Internal*) __Instance) = *((global::NamespacesBase.Base.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::NamespacesBase.Base __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::NamespacesBase.Base(int i)
        {
            return new global::NamespacesBase.Base(i);
        }

        public int Parent
        {
            get
            {
                var __ret = __Internal.Parent_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class Base2 : global::NamespacesBase.Base, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Base2;

            [FieldOffset(4)]
            public int b;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base2@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base2@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base2@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::NamespacesBase.Base2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Base2(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesBase.Base2 __CreateInstance(global::NamespacesBase.Base2.__Internal native, bool skipVTables = false)
        {
            return new Base2(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesBase.Base2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base2.__Internal));
            global::NamespacesBase.Base2.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Base2(global::NamespacesBase.Base2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Base2(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Base2(int i)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4), i);
            SetupVTables(GetType().FullName == "NamespacesBase.Base2");
        }

        public Base2()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "NamespacesBase.Base2");
        }

        public Base2(global::NamespacesBase.Base2 _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Base2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "NamespacesBase.Base2");
        }

        public virtual void parent(int i)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___parent_0Delegate = (global::NamespacesBase.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::NamespacesBase.Delegates.Action_IntPtr_int));
            ___parent_0Delegate((__Instance + __PointerAdjustment - 4), i);
        }

        public static implicit operator global::NamespacesBase.Base2(int i)
        {
            return new global::NamespacesBase.Base2(i);
        }

        #region Virtual table interop

        // void parent(int i)
        private static global::NamespacesBase.Delegates.Action_IntPtr_int _parent_0DelegateInstance;

        private static void _parent_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::NamespacesBase.Base2) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.parent(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _parent_0DelegateInstance += _parent_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_parent_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class Abstract : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Abstract;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Abstract@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Abstract@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.Abstract> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.Abstract>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NamespacesBase.Abstract __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractInternal(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesBase.Abstract __CreateInstance(global::NamespacesBase.Abstract.__Internal native, bool skipVTables = false)
        {
            return new AbstractInternal(native, skipVTables);
        }

        protected Abstract(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected Abstract()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Abstract.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "NamespacesBase.Abstract");
        }

        protected Abstract(global::NamespacesBase.Abstract _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Abstract.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "NamespacesBase.Abstract");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::NamespacesBase.Abstract __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::NamespacesBase.Abstract.__Internal*) __Instance)->vfptr_Abstract = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract void AbstractFunction();

        #region Virtual table interop

        // void abstractFunction() = 0
        private static global::NamespacesBase.Delegates.Action_IntPtr _AbstractFunction_0DelegateInstance;

        private static void _AbstractFunction_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::NamespacesBase.Abstract) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.AbstractFunction();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AbstractFunction_0DelegateInstance += _AbstractFunction_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AbstractFunction_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasVirtualInCore : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualInCore;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualInCore@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualInCore@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.HasVirtualInCore> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.HasVirtualInCore>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NamespacesBase.HasVirtualInCore __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualInCore(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesBase.HasVirtualInCore __CreateInstance(global::NamespacesBase.HasVirtualInCore.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualInCore(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesBase.HasVirtualInCore.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.HasVirtualInCore.__Internal));
            global::NamespacesBase.HasVirtualInCore.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualInCore(global::NamespacesBase.HasVirtualInCore.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualInCore(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasVirtualInCore()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.HasVirtualInCore.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "NamespacesBase.HasVirtualInCore");
        }

        public HasVirtualInCore(global::NamespacesBase.HasVirtualInCore _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.HasVirtualInCore.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "NamespacesBase.HasVirtualInCore");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::NamespacesBase.HasVirtualInCore __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::NamespacesBase.HasVirtualInCore.__Internal*) __Instance)->vfptr_HasVirtualInCore = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual int VirtualInCore(int parameter)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___VirtualInCore_0Delegate = (global::NamespacesBase.Delegates.Func_int_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::NamespacesBase.Delegates.Func_int_IntPtr_int));
            var __ret = ___VirtualInCore_0Delegate((__Instance + __PointerAdjustment), parameter);
            return __ret;
        }

        #region Virtual table interop

        // int virtualInCore(int parameter)
        private static global::NamespacesBase.Delegates.Func_int_IntPtr_int _VirtualInCore_0DelegateInstance;

        private static int _VirtualInCore_0DelegateHook(global::System.IntPtr instance, int parameter)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::NamespacesBase.HasVirtualInCore) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VirtualInCore(parameter);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _VirtualInCore_0DelegateInstance += _VirtualInCore_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_VirtualInCore_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class AbstractInternal : global::NamespacesBase.Abstract, IDisposable
    {
        private static void* __CopyValue(global::NamespacesBase.Abstract.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.Abstract.__Internal));
            *(global::NamespacesBase.Abstract.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractInternal(global::NamespacesBase.Abstract.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void AbstractFunction()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___AbstractFunction_0Delegate = (global::NamespacesBase.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::NamespacesBase.Delegates.Action_IntPtr));
            ___AbstractFunction_0Delegate((__Instance + __PointerAdjustment));
        }
    }

    namespace OverlappingNamespace
    {
        public enum ColorsEnum
        {
            White = 0,
            Black = 1,
            Red = 2,
            Blue = 3,
            Green = 4
        }

        public unsafe partial class InBaseLib : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0InBaseLib@OverlappingNamespace@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesBase.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0InBaseLib@OverlappingNamespace@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.OverlappingNamespace.InBaseLib> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesBase.OverlappingNamespace.InBaseLib>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::NamespacesBase.OverlappingNamespace.InBaseLib __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new InBaseLib(native.ToPointer(), skipVTables);
            }

            internal static global::NamespacesBase.OverlappingNamespace.InBaseLib __CreateInstance(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal native, bool skipVTables = false)
            {
                return new InBaseLib(native, skipVTables);
            }

            private static void* __CopyValue(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal));
                *(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InBaseLib(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InBaseLib(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public InBaseLib()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
            }

            public InBaseLib(global::NamespacesBase.OverlappingNamespace.InBaseLib _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal*) __Instance) = *((global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::NamespacesBase.OverlappingNamespace.InBaseLib __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr_int(global::System.IntPtr instance, int arg1);
    }
}
