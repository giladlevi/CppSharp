// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("NamespacesDerived.CSharp")]

namespace NamespacesDerived
{
    public unsafe partial class Derived : global::NamespacesBase.Base2, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Base2;

            [FieldOffset(4)]
            public int b;

            [FieldOffset(8)]
            public global::NamespacesBase.Base.__Internal baseComponent;

            [FieldOffset(12)]
            public global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal nestedNSComponent;

            [FieldOffset(16)]
            public global::NamespacesBase.OverlappingNamespace.ColorsEnum color;

            [FieldOffset(20)]
            public int d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Derived@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Derived@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getNestedNSComponent@Derived@@QAE?AVInBaseLib@OverlappingNamespace@@XZ")]
            internal static extern void nestedNSComponent_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setNestedNSComponent@Derived@@QAEXVInBaseLib@OverlappingNamespace@@@Z")]
            internal static extern void SetNestedNSComponent_0(global::System.IntPtr instance, global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getBase@Derived@@QAE?AVBase@@XZ")]
            internal static extern void Base_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setBase@Derived@@QAEXVBase@@@Z")]
            internal static extern void SetBase_0(global::System.IntPtr instance, global::NamespacesBase.Base.__Internal _0);
        }

        internal static new global::NamespacesDerived.Derived __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Derived(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesDerived.Derived __CreateInstance(global::NamespacesDerived.Derived.__Internal native, bool skipVTables = false)
        {
            return new Derived(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesDerived.Derived.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived.__Internal));
            global::NamespacesDerived.Derived.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Derived(global::NamespacesDerived.Derived.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Derived(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Derived()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "NamespacesDerived.Derived");
        }

        public Derived(global::NamespacesDerived.Derived _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "NamespacesDerived.Derived");
        }

        public override void parent(int i)
        {
            base.parent(i);
        }

        public global::NamespacesBase.OverlappingNamespace.InBaseLib nestedNSComponent()
        {
            var __ret = new global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal();
            __Internal.nestedNSComponent_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::NamespacesBase.OverlappingNamespace.InBaseLib.__CreateInstance(__ret);
        }

        public void SetNestedNSComponent(global::NamespacesBase.OverlappingNamespace.InBaseLib _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? new global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal() : *(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal*) _0.__Instance;
            __Internal.SetNestedNSComponent_0((__Instance + __PointerAdjustment), __arg0);
        }

        public global::NamespacesBase.Base BaseComponent
        {
            get
            {
                return global::NamespacesBase.Base.__CreateInstance(((global::NamespacesDerived.Derived.__Internal*) __Instance)->baseComponent);
            }

            set
            {
                ((global::NamespacesDerived.Derived.__Internal*) __Instance)->baseComponent = ReferenceEquals(value, null) ? new global::NamespacesBase.Base.__Internal() : *(global::NamespacesBase.Base.__Internal*) value.__Instance;
            }
        }

        public global::NamespacesBase.OverlappingNamespace.InBaseLib NestedNSComponent
        {
            get
            {
                return global::NamespacesBase.OverlappingNamespace.InBaseLib.__CreateInstance(((global::NamespacesDerived.Derived.__Internal*) __Instance)->nestedNSComponent);
            }

            set
            {
                ((global::NamespacesDerived.Derived.__Internal*) __Instance)->nestedNSComponent = ReferenceEquals(value, null) ? new global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal() : *(global::NamespacesBase.OverlappingNamespace.InBaseLib.__Internal*) value.__Instance;
            }
        }

        public global::NamespacesBase.OverlappingNamespace.ColorsEnum Color
        {
            get
            {
                return ((global::NamespacesDerived.Derived.__Internal*) __Instance)->color;
            }

            set
            {
                ((global::NamespacesDerived.Derived.__Internal*) __Instance)->color = value;
            }
        }

        public global::NamespacesBase.Base Base
        {
            get
            {
                var __ret = new global::NamespacesBase.Base.__Internal();
                __Internal.Base_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::NamespacesBase.Base.__CreateInstance(__ret);
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? new global::NamespacesBase.Base.__Internal() : *(global::NamespacesBase.Base.__Internal*) value.__Instance;
                __Internal.SetBase_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        #region Virtual table interop

        // void parent(int i)
        private static global::NamespacesDerived.Delegates.Action_IntPtr_int _parent_0DelegateInstance;

        private static void _parent_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::NamespacesDerived.Derived) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.parent(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _parent_0DelegateInstance += _parent_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_parent_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Base3 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Base3@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.Base3> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.Base3>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::NamespacesDerived.Base3 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Base3(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesDerived.Base3 __CreateInstance(global::NamespacesDerived.Base3.__Internal native, bool skipVTables = false)
        {
            return new Base3(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesDerived.Base3.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Base3.__Internal));
            *(global::NamespacesDerived.Base3.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Base3(global::NamespacesDerived.Base3.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Base3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Base3()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Base3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Base3(global::NamespacesDerived.Base3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Base3.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::NamespacesDerived.Base3.__Internal*) __Instance) = *((global::NamespacesDerived.Base3.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::NamespacesDerived.Base3 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class Derived2 : global::NamespacesDerived.Base3, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::NamespacesDerived.Base3.__Internal baseComponent;

            [FieldOffset(4)]
            public global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal nestedNSComponent;

            [FieldOffset(12)]
            internal global::NamespacesBase.TemplateClass.__Internal t;

            [FieldOffset(16)]
            internal global::NamespacesBase.TemplateClass.__Internal d;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Derived2@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Derived2@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getNestedNSComponent@Derived2@@QAE?AVInDerivedLib@OverlappingNamespace@@XZ")]
            internal static extern void nestedNSComponent_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setNestedNSComponent@Derived2@@QAEXVInDerivedLib@OverlappingNamespace@@@Z")]
            internal static extern void SetNestedNSComponent_0(global::System.IntPtr instance, global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultEnumValueFromDependency@Derived2@@QAEXW4ColorsEnum@OverlappingNamespace@@@Z")]
            internal static extern void DefaultEnumValueFromDependency_0(global::System.IntPtr instance, global::NamespacesBase.OverlappingNamespace.ColorsEnum c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getBase@Derived2@@QAE?AVBase3@@XZ")]
            internal static extern void Base_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setBase@Derived2@@QAEXVBase3@@@Z")]
            internal static extern void SetBase_0(global::System.IntPtr instance, global::NamespacesDerived.Base3.__Internal _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getAbstract@Derived2@@QAEPAVAbstract@@XZ")]
            internal static extern global::System.IntPtr GetAbstract_0(global::System.IntPtr instance);
        }

        internal static new global::NamespacesDerived.Derived2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Derived2(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesDerived.Derived2 __CreateInstance(global::NamespacesDerived.Derived2.__Internal native, bool skipVTables = false)
        {
            return new Derived2(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesDerived.Derived2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived2.__Internal));
            *(global::NamespacesDerived.Derived2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Derived2(global::NamespacesDerived.Derived2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Derived2(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Derived2()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Derived2(global::NamespacesDerived.Derived2 _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.Derived2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::NamespacesDerived.Derived2.__Internal*) __Instance) = *((global::NamespacesDerived.Derived2.__Internal*) _0.__Instance);
        }

        public global::NamespacesDerived.OverlappingNamespace.InDerivedLib nestedNSComponent()
        {
            var __ret = new global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal();
            __Internal.nestedNSComponent_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
            return global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__CreateInstance(__ret);
        }

        public void SetNestedNSComponent(global::NamespacesDerived.OverlappingNamespace.InDerivedLib _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? new global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal() : *(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) _0.__Instance;
            __Internal.SetNestedNSComponent_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultEnumValueFromDependency(global::NamespacesBase.OverlappingNamespace.ColorsEnum c = global::NamespacesBase.OverlappingNamespace.ColorsEnum.Black)
        {
            __Internal.DefaultEnumValueFromDependency_0((__Instance + __PointerAdjustment), c);
        }

        public global::NamespacesDerived.Base3 BaseComponent
        {
            get
            {
                return global::NamespacesDerived.Base3.__CreateInstance(((global::NamespacesDerived.Derived2.__Internal*) __Instance)->baseComponent);
            }

            set
            {
                ((global::NamespacesDerived.Derived2.__Internal*) __Instance)->baseComponent = ReferenceEquals(value, null) ? new global::NamespacesDerived.Base3.__Internal() : *(global::NamespacesDerived.Base3.__Internal*) value.__Instance;
            }
        }

        public global::NamespacesDerived.OverlappingNamespace.InDerivedLib NestedNSComponent
        {
            get
            {
                return global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__CreateInstance(((global::NamespacesDerived.Derived2.__Internal*) __Instance)->nestedNSComponent);
            }

            set
            {
                ((global::NamespacesDerived.Derived2.__Internal*) __Instance)->nestedNSComponent = ReferenceEquals(value, null) ? new global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal() : *(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) value.__Instance;
            }
        }

        public global::NamespacesDerived.Base3 Base
        {
            get
            {
                var __ret = new global::NamespacesDerived.Base3.__Internal();
                __Internal.Base_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::NamespacesDerived.Base3.__CreateInstance(__ret);
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? new global::NamespacesDerived.Base3.__Internal() : *(global::NamespacesDerived.Base3.__Internal*) value.__Instance;
                __Internal.SetBase_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::NamespacesBase.Abstract Abstract
        {
            get
            {
                var __ret = __Internal.GetAbstract_0((__Instance + __PointerAdjustment));
                global::NamespacesBase.Abstract __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::NamespacesBase.Abstract.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::NamespacesBase.Abstract) global::NamespacesBase.Abstract.NativeToManagedMap[__ret];
                else __result0 = global::NamespacesBase.Abstract.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public unsafe partial class HasVirtualInDependency : global::NamespacesBase.HasVirtualInCore, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualInCore;

            [FieldOffset(4)]
            public global::System.IntPtr managedObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualInDependency@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualInDependency@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?callManagedOverride@HasVirtualInDependency@@QAEHXZ")]
            internal static extern int CallManagedOverride_0(global::System.IntPtr instance);
        }

        internal static new global::NamespacesDerived.HasVirtualInDependency __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualInDependency(native.ToPointer(), skipVTables);
        }

        internal static global::NamespacesDerived.HasVirtualInDependency __CreateInstance(global::NamespacesDerived.HasVirtualInDependency.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualInDependency(native, skipVTables);
        }

        private static void* __CopyValue(global::NamespacesDerived.HasVirtualInDependency.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.HasVirtualInDependency.__Internal));
            global::NamespacesDerived.HasVirtualInDependency.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualInDependency(global::NamespacesDerived.HasVirtualInDependency.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualInDependency(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasVirtualInDependency()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.HasVirtualInDependency.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "NamespacesDerived.HasVirtualInDependency");
        }

        public HasVirtualInDependency(global::NamespacesDerived.HasVirtualInDependency _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.HasVirtualInDependency.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "NamespacesDerived.HasVirtualInDependency");
        }

        public int CallManagedOverride()
        {
            var __ret = __Internal.CallManagedOverride_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public global::NamespacesDerived.HasVirtualInDependency ManagedObject
        {
            get
            {
                global::NamespacesDerived.HasVirtualInDependency __result0;
                if (((global::NamespacesDerived.HasVirtualInDependency.__Internal*) __Instance)->managedObject == IntPtr.Zero) __result0 = null;
                else if (global::NamespacesDerived.HasVirtualInDependency.NativeToManagedMap.ContainsKey(((global::NamespacesDerived.HasVirtualInDependency.__Internal*) __Instance)->managedObject))
                    __result0 = (global::NamespacesDerived.HasVirtualInDependency) global::NamespacesDerived.HasVirtualInDependency.NativeToManagedMap[((global::NamespacesDerived.HasVirtualInDependency.__Internal*) __Instance)->managedObject];
                else __result0 = global::NamespacesDerived.HasVirtualInDependency.__CreateInstance(((global::NamespacesDerived.HasVirtualInDependency.__Internal*) __Instance)->managedObject);
                return __result0;
            }

            set
            {
                ((global::NamespacesDerived.HasVirtualInDependency.__Internal*) __Instance)->managedObject = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        #region Virtual table interop

        // int virtualInCore(int parameter)
        private static global::NamespacesBase.Delegates.Func_int_IntPtr_int _VirtualInCore_0DelegateInstance;

        private static int _VirtualInCore_0DelegateHook(global::System.IntPtr instance, int parameter)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::NamespacesDerived.HasVirtualInDependency) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VirtualInCore(parameter);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _VirtualInCore_0DelegateInstance += _VirtualInCore_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_VirtualInCore_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    namespace OverlappingNamespace
    {
        public unsafe partial class InDerivedLib : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::NamespacesBase.Base.__Internal parentNSComponent;

                [FieldOffset(4)]
                public global::NamespacesBase.OverlappingNamespace.ColorsEnum color;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0InDerivedLib@OverlappingNamespace@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0InDerivedLib@OverlappingNamespace@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.OverlappingNamespace.InDerivedLib> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.OverlappingNamespace.InDerivedLib>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::NamespacesDerived.OverlappingNamespace.InDerivedLib __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new InDerivedLib(native.ToPointer(), skipVTables);
            }

            internal static global::NamespacesDerived.OverlappingNamespace.InDerivedLib __CreateInstance(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal native, bool skipVTables = false)
            {
                return new InDerivedLib(native, skipVTables);
            }

            private static void* __CopyValue(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal));
                *(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InDerivedLib(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InDerivedLib(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public InDerivedLib()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
            }

            public InDerivedLib(global::NamespacesDerived.OverlappingNamespace.InDerivedLib _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) __Instance) = *((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::NamespacesDerived.OverlappingNamespace.InDerivedLib __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public global::NamespacesBase.Base ParentNSComponent
            {
                get
                {
                    return global::NamespacesBase.Base.__CreateInstance(((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) __Instance)->parentNSComponent);
                }

                set
                {
                    ((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) __Instance)->parentNSComponent = ReferenceEquals(value, null) ? new global::NamespacesBase.Base.__Internal() : *(global::NamespacesBase.Base.__Internal*) value.__Instance;
                }
            }

            public global::NamespacesBase.OverlappingNamespace.ColorsEnum Color
            {
                get
                {
                    return ((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) __Instance)->color;
                }

                set
                {
                    ((global::NamespacesDerived.OverlappingNamespace.InDerivedLib.__Internal*) __Instance)->color = value;
                }
            }
        }
    }

    namespace NamespacesBase
    {
        public unsafe partial class ClassInNamespaceNamedAfterDependency : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public global::NamespacesBase.Base.__Internal @base;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ClassInNamespaceNamedAfterDependency@NamespacesBase@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("NamespacesDerived.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ClassInNamespaceNamedAfterDependency@NamespacesBase@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new ClassInNamespaceNamedAfterDependency(native.ToPointer(), skipVTables);
            }

            internal static global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency __CreateInstance(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal native, bool skipVTables = false)
            {
                return new ClassInNamespaceNamedAfterDependency(native, skipVTables);
            }

            private static void* __CopyValue(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal));
                *(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ClassInNamespaceNamedAfterDependency(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ClassInNamespaceNamedAfterDependency(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ClassInNamespaceNamedAfterDependency()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment));
            }

            public ClassInNamespaceNamedAfterDependency(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal*) __Instance) = *((global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::NamespacesDerived.NamespacesBase.ClassInNamespaceNamedAfterDependency __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr instance, int arg1);
    }
}
