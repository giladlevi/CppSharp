// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CSharp
{
    public unsafe partial class DuplicateDeclaredStruct
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DuplicateDeclaredStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DuplicateDeclaredStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.DuplicateDeclaredStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DuplicateDeclaredStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.DuplicateDeclaredStruct __CreateInstance(global::CSharp.DuplicateDeclaredStruct.__Internal native, bool skipVTables = false)
        {
            return new DuplicateDeclaredStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.DuplicateDeclaredStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.DuplicateDeclaredStruct.__Internal));
            *(global::CSharp.DuplicateDeclaredStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DuplicateDeclaredStruct(global::CSharp.DuplicateDeclaredStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DuplicateDeclaredStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    namespace TemplateInAnotherUnit
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_TemplateInAnotherUnit__I
        {
            [FieldOffset(0)]
            public int field;
        }

        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_TemplateInAnotherUnit__f
        {
            [FieldOffset(0)]
            public float field;
        }
    }

    public unsafe partial class ForwardInOtherUnitButSameModule : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ForwardInOtherUnitButSameModule@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ForwardInOtherUnitButSameModule> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ForwardInOtherUnitButSameModule>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.ForwardInOtherUnitButSameModule __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ForwardInOtherUnitButSameModule(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ForwardInOtherUnitButSameModule __CreateInstance(global::CSharp.ForwardInOtherUnitButSameModule.__Internal native, bool skipVTables = false)
        {
            return new ForwardInOtherUnitButSameModule(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ForwardInOtherUnitButSameModule.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardInOtherUnitButSameModule.__Internal));
            *(global::CSharp.ForwardInOtherUnitButSameModule.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ForwardInOtherUnitButSameModule(global::CSharp.ForwardInOtherUnitButSameModule.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ForwardInOtherUnitButSameModule(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ForwardInOtherUnitButSameModule()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardInOtherUnitButSameModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ForwardInOtherUnitButSameModule(global::CSharp.ForwardInOtherUnitButSameModule _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardInOtherUnitButSameModule.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.ForwardInOtherUnitButSameModule.__Internal*) __Instance) = *((global::CSharp.ForwardInOtherUnitButSameModule.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ForwardInOtherUnitButSameModule __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class AnotherUnit
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?functionInAnotherUnit@@YAXXZ")]
            internal static extern void FunctionInAnotherUnit_0();
        }

        public static void FunctionInAnotherUnit()
        {
            __Internal.FunctionInAnotherUnit_0();
        }
    }

    namespace HasFreeConstant
    {
        public unsafe partial class AnotherUnit
        {
            public partial struct __Internal
            {
            }

            public static int FREE_CONSTANT_IN_NAMESPACE
            {
                get
                {
                    var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?FREE_CONSTANT_IN_NAMESPACE@HasFreeConstant@@3HB");
                    return *__ptr;
                }
            }
        }
    }

    public enum TestFlag
    {
        Flag1 = 0,
        Flag2 = 1
    }

    [Flags]
    public enum Flags
    {
        Flag1 = 1,
        Flag2 = 2,
        Flag3 = 4
    }

    [Flags]
    public enum UntypedFlags
    {
        Flag1 = 1,
        Flag2 = 2,
        Flag3 = 4
    }

    public enum MyMacroTestEnum
    {
        MY_MACRO_TEST_1 = 49,
        MY_MACRO_TEST_2 = 50
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void ALLCAPS_UNDERSCORES(int i);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void funcPtr();

    namespace QFlags
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internal
        {
            [FieldOffset(0)]
            public int flag;
        }
    }

    namespace QList
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    namespace IgnoredType
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    namespace TemplateWithDependentField
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_TemplateWithDependentField__I
        {
            [FieldOffset(0)]
            public int t;
        }
    }

    namespace LowerCase
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    public unsafe partial class CompleteIncompleteStruct
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.CompleteIncompleteStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.CompleteIncompleteStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.CompleteIncompleteStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CompleteIncompleteStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.CompleteIncompleteStruct __CreateInstance(global::CSharp.CompleteIncompleteStruct.__Internal native, bool skipVTables = false)
        {
            return new CompleteIncompleteStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.CompleteIncompleteStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.CompleteIncompleteStruct.__Internal));
            *(global::CSharp.CompleteIncompleteStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CompleteIncompleteStruct(global::CSharp.CompleteIncompleteStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CompleteIncompleteStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class IncompleteStruct
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IncompleteStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IncompleteStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.IncompleteStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new IncompleteStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.IncompleteStruct __CreateInstance(global::CSharp.IncompleteStruct.__Internal native, bool skipVTables = false)
        {
            return new IncompleteStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.IncompleteStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.IncompleteStruct.__Internal));
            *(global::CSharp.IncompleteStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IncompleteStruct(global::CSharp.IncompleteStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IncompleteStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class Foo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(8)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(12)]
            public int P;

            [FieldOffset(16)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@PBD@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@HH@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int a, int p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Foo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setNoParams@Foo@@QAEXXZ")]
            internal static extern void SetNoParams_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?foo@Foo@@QAEXH@Z")]
            internal static extern void foo_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?makeFunctionCall@Foo@@SAHXZ")]
            internal static extern int MakeFunctionCall_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??AFoo@@QAEHI@Z")]
            internal static extern int OperatorSubscript_1(global::System.IntPtr instance, uint i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??AFoo@@QAEAAHH@Z")]
            internal static extern int* OperatorSubscript_2(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?width@Foo@@QAEHXZ")]
            internal static extern int Width_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?set_width@Foo@@QAEXH@Z")]
            internal static extern void SetWidth_0(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?method@Foo@@QAEHXZ")]
            internal static extern int Method_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?isNoParams@Foo@@QAE_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNoParams_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?propertyCall@Foo@@SAHXZ")]
            internal static extern int PropertyCall_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getGetPropertyCall@Foo@@SAHXZ")]
            internal static extern int GetGetPropertyCall_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Foo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Foo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.Foo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Foo(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Foo __CreateInstance(global::CSharp.Foo.__Internal native, bool skipVTables = false)
        {
            return new Foo(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Foo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Foo.__Internal));
            *(global::CSharp.Foo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Foo(global::CSharp.Foo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Foo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Foo(string name = null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment), name);
        }

        public Foo(int a, int p = 0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), a, p);
        }

        public Foo(global::CSharp.Foo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Foo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.Foo.__Internal*) __Instance) = *((global::CSharp.Foo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void SetNoParams()
        {
            __Internal.SetNoParams_0((__Instance + __PointerAdjustment));
        }

        public void foo(int i)
        {
            __Internal.foo_0((__Instance + __PointerAdjustment), i);
        }

        public static implicit operator global::CSharp.Foo(string name)
        {
            return new global::CSharp.Foo(name);
        }

        public static implicit operator global::CSharp.Foo(int a)
        {
            return new global::CSharp.Foo(a);
        }

        public static int MakeFunctionCall()
        {
            var __ret = __Internal.MakeFunctionCall_0();
            return __ret;
        }

        public static int Rename
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?rename@Foo@@2HB");
                return *__ptr;
            }
        }

        public int this[uint i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_1((__Instance + __PointerAdjustment), i);
                return __ret;
            }
        }

        public int this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_2((__Instance + __PointerAdjustment), i);
                return *__ret;
            }

            set
            {
                *__Internal.OperatorSubscript_2((__Instance + __PointerAdjustment), i) = value;
            }
        }

        public int A
        {
            get
            {
                return ((global::CSharp.Foo.__Internal*) __Instance)->A;
            }

            set
            {
                ((global::CSharp.Foo.__Internal*) __Instance)->A = value;
            }
        }

        protected int P
        {
            get
            {
                return ((global::CSharp.Foo.__Internal*) __Instance)->P;
            }

            set
            {
                ((global::CSharp.Foo.__Internal*) __Instance)->P = value;
            }
        }

        public int Width
        {
            get
            {
                var __ret = __Internal.Width_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetWidth_0((__Instance + __PointerAdjustment), value);
            }
        }

        public int Method
        {
            get
            {
                var __ret = __Internal.Method_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public bool IsNoParams
        {
            get
            {
                var __ret = __Internal.IsNoParams_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public static int PropertyCall
        {
            get
            {
                var __ret = __Internal.PropertyCall_0();
                return __ret;
            }
        }

        public static int GetPropertyCall
        {
            get
            {
                var __ret = __Internal.GetGetPropertyCall_0();
                return __ret;
            }
        }
    }

    public unsafe partial class Quux : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int priv;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Quux@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Quux@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Quux@@QAE@D@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Quux@@QAE@VFoo@@@Z")]
            internal static extern global::System.IntPtr ctor_3(global::System.IntPtr instance, global::CSharp.Foo.__Internal f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Quux@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Quux> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Quux>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.Quux __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Quux(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Quux __CreateInstance(global::CSharp.Quux.__Internal native, bool skipVTables = false)
        {
            return new Quux(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Quux.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            *(global::CSharp.Quux.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Quux(global::CSharp.Quux.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Quux(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Quux()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public Quux(int i)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), i);
        }

        public Quux(char c)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = global::System.Convert.ToSByte(c);
            __Internal.ctor_2((__Instance + __PointerAdjustment), __arg0);
        }

        public Quux(global::CSharp.Foo f)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(f, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) f.__Instance;
            __Internal.ctor_3((__Instance + __PointerAdjustment), __arg0);
        }

        public Quux(global::CSharp.Quux _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Quux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.Quux.__Internal*) __Instance) = *((global::CSharp.Quux.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.Quux __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CSharp.Quux(int i)
        {
            return new global::CSharp.Quux(i);
        }

        public static implicit operator global::CSharp.Quux(char c)
        {
            return new global::CSharp.Quux(c);
        }

        public static implicit operator global::CSharp.Quux(global::CSharp.Foo f)
        {
            return new global::CSharp.Quux(f);
        }
    }

    public unsafe partial class Qux : global::CSharp.IQux, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Qux;

            [FieldOffset(4)]
            public fixed int array[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Qux@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Qux@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Qux@@QAE@VFoo@@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::CSharp.Foo.__Internal foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Qux@@QAE@VBar@@@Z")]
            internal static extern global::System.IntPtr ctor_3(global::System.IntPtr instance, global::CSharp.Bar.__Internal bar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?obsolete@Qux@@QAEXXZ")]
            internal static extern void Obsolete_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getInterface@Qux@@QAEPAV1@XZ")]
            internal static extern global::System.IntPtr Interface_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setInterface@Qux@@QAEXPAV1@@Z")]
            internal static extern void SetInterface_0(global::System.IntPtr instance, global::System.IntPtr qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?farAwayFunc@Qux@@QBEHXZ")]
            internal static extern int FarAwayFunc_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IQux> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IQux>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.Qux __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Qux(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Qux __CreateInstance(global::CSharp.Qux.__Internal native, bool skipVTables = false)
        {
            return new Qux(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Qux.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Qux.__Internal));
            global::CSharp.Qux.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Qux(global::CSharp.Qux.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Qux(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Qux()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Qux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.Qux");
        }

        public Qux(global::CSharp.IQux other)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Qux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(other, null))
                throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = other.__PointerToQux;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Qux");
        }

        public Qux(global::CSharp.Foo foo)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Qux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            __Internal.ctor_2((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Qux");
        }

        public Qux(global::CSharp.IBar bar)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Qux.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(bar, null) ? new global::CSharp.Bar.__Internal() : *(global::CSharp.Bar.__Internal*) bar.__PointerToBar;
            __Internal.ctor_3((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Qux");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IQux __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.Qux.__Internal*) __Instance)->vfptr_Qux = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        [System.ObsoleteAttribute("obsolete is obsolete.")]
        public void Obsolete()
        {
            __Internal.Obsolete_0((__Instance));
        }

        public virtual void V()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___V_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___V_0Delegate((__Instance));
        }

        public static implicit operator global::CSharp.Qux(global::CSharp.Foo foo)
        {
            return new global::CSharp.Qux(foo);
        }

        public int[] Array
        {
            get
            {
                int[] __value = null;
                if (((global::CSharp.Qux.__Internal*) __Instance)->array != null)
                {
                    __value = new int[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::CSharp.Qux.__Internal*) __Instance)->array[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::CSharp.Qux.__Internal*) __Instance)->array[i] = value[i];
                }
            }
        }

        public global::System.IntPtr __PointerToQux
        {
            get
            {
                return __Instance + 0;
            }
        }

        public global::CSharp.IQux Interface
        {
            get
            {
                var __ret = __Internal.Interface_0((__Instance));
                global::CSharp.IQux __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Qux.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.IQux) global::CSharp.Qux.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Qux.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__PointerToQux;
                __Internal.SetInterface_0((__Instance), __arg0);
            }
        }

        public int FarAwayFunc
        {
            get
            {
                var __ret = __Internal.FarAwayFunc_0((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // void v()
        private static global::CSharp.Delegates.Action_IntPtr _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Qux) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Bar : global::CSharp.Qux, global::CSharp.IBar, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 124)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Qux;

            [FieldOffset(4)]
            public fixed int array[3];

            [FieldOffset(16)]
            public void* arrayOfPrimitivePointers;

            [FieldOffset(20)]
            public fixed byte foos[80];

            [FieldOffset(100)]
            public int index;

            [FieldOffset(104)]
            public global::CSharp.Foo.__Internal m_foo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@VQux@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::CSharp.Qux.__Internal qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@W4Items@0@@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, global::CSharp.Bar.Items item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Bar@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??DBar@@QAEABV0@H@Z")]
            internal static extern global::System.IntPtr OperatorStar_1(global::System.IntPtr instance, int m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??EBar@@QAEABV0@XZ")]
            internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ABar@@QAEAAVFoo@@H@Z")]
            internal static extern global::System.IntPtr OperatorSubscript_1(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?method@Bar@@QAEHXZ")]
            internal static extern int Method_0(global::System.IntPtr instance);
        }

        public enum Items
        {
            Item1 = 0,
            Item2 = 1
        }

        internal static new global::CSharp.Bar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Bar(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Bar __CreateInstance(global::CSharp.Bar.__Internal native, bool skipVTables = false)
        {
            return new Bar(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Bar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Bar.__Internal));
            global::CSharp.Bar.__Internal.cctor_4(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Bar(global::CSharp.Bar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Bar(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Bar()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Bar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.Bar");
        }

        public Bar(global::CSharp.IQux qux)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Bar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(qux, null) ? new global::CSharp.Qux.__Internal() : *(global::CSharp.Qux.__Internal*) qux.__PointerToQux;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Bar");
        }

        public Bar(global::CSharp.Bar.Items item)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Bar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_2((__Instance + __PointerAdjustment), item);
            SetupVTables(GetType().FullName == "CSharp.Bar");
        }

        public Bar(global::CSharp.IBar _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Bar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToBar;
            __Internal.cctor_4((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Bar");
        }

        public static global::CSharp.IBar operator *(global::CSharp.Bar __op, int m)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorStar_1(__arg0, m);
            global::CSharp.IBar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Bar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.IBar) global::CSharp.Bar.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.Bar.__CreateInstance(__ret);
            return __result0;
        }

        public static global::CSharp.Bar operator ++(global::CSharp.Bar __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorPlusPlus_0(__arg0);
            global::CSharp.Bar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Bar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.Bar) global::CSharp.Bar.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.Bar.__CreateInstance(__ret);
            return __result0;
        }

        public static implicit operator global::CSharp.Bar(global::CSharp.Bar.Items item)
        {
            return new global::CSharp.Bar(item);
        }

        public global::CSharp.Foo this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript_1((__Instance + __PointerAdjustment), i);
                global::CSharp.Foo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Foo.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(global::CSharp.Foo.__Internal*) __Internal.OperatorSubscript_1((__Instance + __PointerAdjustment), i) = *(global::CSharp.Foo.__Internal*) value.__Instance;
            }
        }

        private global::System.IntPtr[] __arrayOfPrimitivePointers;

        private bool __arrayOfPrimitivePointersInitialised;
        public global::System.IntPtr[] ArrayOfPrimitivePointers
        {
            get
            {
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointers = null;
                    __arrayOfPrimitivePointersInitialised = true;
                }
                return __arrayOfPrimitivePointers;
            }

            set
            {
                __arrayOfPrimitivePointers = value;
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointersInitialised = true;
                }
            }
        }

        public global::CSharp.Foo[] Foos
        {
            get
            {
                global::CSharp.Foo[] __value = null;
                if (((global::CSharp.Bar.__Internal*) __Instance)->foos != null)
                {
                    __value = new global::CSharp.Foo[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::CSharp.Foo.__CreateInstance(*((global::CSharp.Foo.__Internal*)&(((global::CSharp.Bar.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        ((global::CSharp.Bar.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)] = *((byte*)(global::CSharp.Foo.__Internal*)value[i].__Instance);
                }
            }
        }

        public global::System.IntPtr __PointerToBar
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int Method
        {
            get
            {
                var __ret = __Internal.Method_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void v()
        private static global::CSharp.Delegates.Action_IntPtr _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Bar) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ForceCreationOfInterface : global::CSharp.Foo, global::CSharp.IBar, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Qux;

            [FieldOffset(4)]
            public fixed int array[3];

            [FieldOffset(16)]
            public void* arrayOfPrimitivePointers;

            [FieldOffset(20)]
            public fixed byte foos[80];

            [FieldOffset(100)]
            public int index;

            [FieldOffset(104)]
            public global::CSharp.Foo.__Internal m_foo;

            [FieldOffset(124)]
            public int A;

            [FieldOffset(128)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(132)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(136)]
            public int P;

            [FieldOffset(140)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ForceCreationOfInterface@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ForceCreationOfInterface@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?obsolete@Qux@@QAEXXZ")]
            internal static extern void Obsolete_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ABar@@QAEAAVFoo@@H@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getInterface@Qux@@QAEPAV1@XZ")]
            internal static extern global::System.IntPtr Interface_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setInterface@Qux@@QAEXPAV1@@Z")]
            internal static extern void SetInterface_0(global::System.IntPtr instance, global::System.IntPtr qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?method@Bar@@QAEHXZ")]
            internal static extern int Method_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?farAwayFunc@Qux@@QBEHXZ")]
            internal static extern int FarAwayFunc_0(global::System.IntPtr instance);
        }

        internal static new global::CSharp.ForceCreationOfInterface __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ForceCreationOfInterface(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ForceCreationOfInterface __CreateInstance(global::CSharp.ForceCreationOfInterface.__Internal native, bool skipVTables = false)
        {
            return new ForceCreationOfInterface(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ForceCreationOfInterface.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ForceCreationOfInterface.__Internal));
            global::CSharp.ForceCreationOfInterface.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ForceCreationOfInterface(global::CSharp.ForceCreationOfInterface.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ForceCreationOfInterface(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 124;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public ForceCreationOfInterface()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForceCreationOfInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 124));
            SetupVTables(GetType().FullName == "CSharp.ForceCreationOfInterface");
        }

        public ForceCreationOfInterface(global::CSharp.ForceCreationOfInterface _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForceCreationOfInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 124), __arg0);
            SetupVTables(GetType().FullName == "CSharp.ForceCreationOfInterface");
        }

        public void Obsolete()
        {
            __Internal.Obsolete_0((__Instance));
        }

        public virtual void V()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___V_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___V_0Delegate((__Instance));
        }

        global::CSharp.Foo IBar.this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance), i);
                global::CSharp.Foo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Foo.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(global::CSharp.Foo.__Internal*) __Internal.OperatorSubscript((__Instance), i) = *(global::CSharp.Foo.__Internal*) value.__Instance;
            }
        }

        private global::System.IntPtr[] __arrayOfPrimitivePointers;

        private bool __arrayOfPrimitivePointersInitialised;
        public global::System.IntPtr[] ArrayOfPrimitivePointers
        {
            get
            {
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointers = null;
                    __arrayOfPrimitivePointersInitialised = true;
                }
                return __arrayOfPrimitivePointers;
            }

            set
            {
                __arrayOfPrimitivePointers = value;
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointersInitialised = true;
                }
            }
        }

        public global::CSharp.Foo[] Foos
        {
            get
            {
                global::CSharp.Foo[] __value = null;
                if (((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->foos != null)
                {
                    __value = new global::CSharp.Foo[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::CSharp.Foo.__CreateInstance(*((global::CSharp.Foo.__Internal*)&(((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        ((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)] = *((byte*)(global::CSharp.Foo.__Internal*)value[i].__Instance);
                }
            }
        }

        public global::System.IntPtr __PointerToBar
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int[] Array
        {
            get
            {
                int[] __value = null;
                if (((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->array != null)
                {
                    __value = new int[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->array[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::CSharp.ForceCreationOfInterface.__Internal*) __Instance)->array[i] = value[i];
                }
            }
        }

        public global::System.IntPtr __PointerToQux
        {
            get
            {
                return __Instance + 0;
            }
        }

        public global::CSharp.IQux Interface
        {
            get
            {
                var __ret = __Internal.Interface_0((__Instance));
                global::CSharp.IQux __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Qux.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.IQux) global::CSharp.Qux.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Qux.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__PointerToQux;
                __Internal.SetInterface_0((__Instance), __arg0);
            }
        }

        int IBar.Method
        {
            get
            {
                var __ret = __Internal.Method_0((__Instance));
                return __ret;
            }
        }

        public int FarAwayFunc
        {
            get
            {
                var __ret = __Internal.FarAwayFunc_0((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // void v()
        private static global::CSharp.Delegates.Action_IntPtr _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ForceCreationOfInterface) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Baz : global::CSharp.Foo, global::CSharp.IBar, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 152)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_Qux;

            [FieldOffset(4)]
            public fixed int array[3];

            [FieldOffset(16)]
            public void* arrayOfPrimitivePointers;

            [FieldOffset(20)]
            public fixed byte foos[80];

            [FieldOffset(100)]
            public int index;

            [FieldOffset(104)]
            public global::CSharp.Foo.__Internal m_foo;

            [FieldOffset(124)]
            public int A;

            [FieldOffset(128)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(132)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(136)]
            public int P;

            [FieldOffset(140)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [FieldOffset(144)]
            public int P1;

            [FieldOffset(148)]
            public global::System.IntPtr functionTypedef;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Baz@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Baz@@QAE@W4Items@Bar@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::CSharp.Bar.Items item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Baz@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?takesQux@Baz@@QAEHABVQux@@@Z")]
            internal static extern int TakesQux_0(global::System.IntPtr instance, global::System.IntPtr qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?returnQux@Baz@@QAE?AVQux@@XZ")]
            internal static extern void ReturnQux_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setMethod@Baz@@QAEXH@Z")]
            internal static extern void SetMethod_0(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?obsolete@Qux@@QAEXXZ")]
            internal static extern void Obsolete_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ABar@@QAEAAVFoo@@H@Z")]
            internal static extern global::System.IntPtr OperatorSubscript(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getInterface@Qux@@QAEPAV1@XZ")]
            internal static extern global::System.IntPtr Interface_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setInterface@Qux@@QAEXPAV1@@Z")]
            internal static extern void SetInterface_0(global::System.IntPtr instance, global::System.IntPtr qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?method@Bar@@QAEHXZ")]
            internal static extern int Method_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?farAwayFunc@Qux@@QBEHXZ")]
            internal static extern int FarAwayFunc_0(global::System.IntPtr instance);
        }

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate bool FunctionTypedef(global::System.IntPtr _0);

        public unsafe partial class NestedBase1 : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int f1;

                [FieldOffset(8)]
                public double f2;

                [FieldOffset(16)]
                public global::System.IntPtr f3;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedBase1@Baz@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Baz.NestedBase1> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Baz.NestedBase1>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CSharp.Baz.NestedBase1 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new NestedBase1(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.Baz.NestedBase1 __CreateInstance(global::CSharp.Baz.NestedBase1.__Internal native, bool skipVTables = false)
            {
                return new NestedBase1(native, skipVTables);
            }

            private static void* __CopyValue(global::CSharp.Baz.NestedBase1.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase1.__Internal));
                *(global::CSharp.Baz.NestedBase1.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private NestedBase1(global::CSharp.Baz.NestedBase1.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedBase1(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public NestedBase1()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase1.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public NestedBase1(global::CSharp.Baz.NestedBase1 _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase1.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CSharp.Baz.NestedBase1.__Internal*) __Instance) = *((global::CSharp.Baz.NestedBase1.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CSharp.Baz.NestedBase1 __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class NestedBase2 : global::CSharp.Baz.INestedBase2, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedBase2@Baz@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Baz.INestedBase2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.Baz.INestedBase2>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CSharp.Baz.NestedBase2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new NestedBase2(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.Baz.NestedBase2 __CreateInstance(global::CSharp.Baz.NestedBase2.__Internal native, bool skipVTables = false)
            {
                return new NestedBase2(native, skipVTables);
            }

            private static void* __CopyValue(global::CSharp.Baz.NestedBase2.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase2.__Internal));
                *(global::CSharp.Baz.NestedBase2.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private NestedBase2(global::CSharp.Baz.NestedBase2.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedBase2(void* native, bool skipVTables = false)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public NestedBase2()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase2.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public NestedBase2(global::CSharp.Baz.INestedBase2 _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedBase2.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CSharp.Baz.NestedBase2.__Internal*) __Instance) = *((global::CSharp.Baz.NestedBase2.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CSharp.Baz.INestedBase2 __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public global::System.IntPtr __PointerToNestedBase2
            {
                get
                {
                    return __Instance + 0;
                }
            }
        }

        public unsafe partial class NestedDerived : global::CSharp.Baz.NestedBase1, global::CSharp.Baz.INestedBase2, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct __Internal
            {
                [FieldOffset(0)]
                public int f1;

                [FieldOffset(8)]
                public double f2;

                [FieldOffset(16)]
                public global::System.IntPtr f3;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0NestedDerived@Baz@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            internal static new global::CSharp.Baz.NestedDerived __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new NestedDerived(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.Baz.NestedDerived __CreateInstance(global::CSharp.Baz.NestedDerived.__Internal native, bool skipVTables = false)
            {
                return new NestedDerived(native, skipVTables);
            }

            private static void* __CopyValue(global::CSharp.Baz.NestedDerived.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedDerived.__Internal));
                *(global::CSharp.Baz.NestedDerived.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private NestedDerived(global::CSharp.Baz.NestedDerived.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedDerived(void* native, bool skipVTables = false)
                : base((void*) null)
            {
                __PointerAdjustment = 0;
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public NestedDerived()
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedDerived.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public NestedDerived(global::CSharp.Baz.NestedDerived _0)
                : this((void*) null)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.NestedDerived.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CSharp.Baz.NestedDerived.__Internal*) __Instance) = *((global::CSharp.Baz.NestedDerived.__Internal*) _0.__Instance);
            }

            public global::System.IntPtr __PointerToNestedBase2
            {
                get
                {
                    return __Instance + 24;
                }
            }
        }

        public unsafe partial interface INestedBase2
        {
            global::System.IntPtr __Instance { get; }

            global::System.IntPtr __PointerToNestedBase2 { get; }
        }

        internal static new global::CSharp.Baz __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Baz(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Baz __CreateInstance(global::CSharp.Baz.__Internal native, bool skipVTables = false)
        {
            return new Baz(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Baz.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.__Internal));
            global::CSharp.Baz.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Baz(global::CSharp.Baz.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Baz(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 124;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Baz()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 124));
            SetupVTables(GetType().FullName == "CSharp.Baz");
        }

        public Baz(global::CSharp.Bar.Items item)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment - 124), item);
            SetupVTables(GetType().FullName == "CSharp.Baz");
        }

        public Baz(global::CSharp.Baz _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Baz.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment - 124), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Baz");
        }

        public int TakesQux(global::CSharp.IQux qux)
        {
            if (ReferenceEquals(qux, null))
                throw new global::System.ArgumentNullException("qux", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = qux.__PointerToQux;
            var __ret = __Internal.TakesQux_0((__Instance + __PointerAdjustment - 124), __arg0);
            return __ret;
        }

        public global::CSharp.IQux ReturnQux()
        {
            var __ret = new global::CSharp.Qux.__Internal();
            __Internal.ReturnQux_0((__Instance + __PointerAdjustment - 124), new IntPtr(&__ret));
            return global::CSharp.Qux.__CreateInstance(__ret);
        }

        public void SetMethod(int value)
        {
            __Internal.SetMethod_0((__Instance + __PointerAdjustment - 124), value);
        }

        public static implicit operator global::CSharp.Baz(global::CSharp.Bar.Items item)
        {
            return new global::CSharp.Baz(item);
        }

        public void Obsolete()
        {
            __Internal.Obsolete_0((__Instance));
        }

        public virtual void V()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___V_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___V_0Delegate((__Instance));
        }

        public int P
        {
            get
            {
                return ((global::CSharp.Baz.__Internal*) __Instance)->P1;
            }

            set
            {
                ((global::CSharp.Baz.__Internal*) __Instance)->P1 = value;
            }
        }

        public global::CSharp.Baz.FunctionTypedef functionTypedef
        {
            get
            {
                var __ptr0 = ((global::CSharp.Baz.__Internal*) __Instance)->functionTypedef;
                return __ptr0 == IntPtr.Zero? null : (global::CSharp.Baz.FunctionTypedef)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::CSharp.Baz.FunctionTypedef));
            }

            set
            {
                ((global::CSharp.Baz.__Internal*) __Instance)->functionTypedef = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        global::CSharp.Foo IBar.this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript((__Instance), i);
                global::CSharp.Foo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Foo.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                *(global::CSharp.Foo.__Internal*) __Internal.OperatorSubscript((__Instance), i) = *(global::CSharp.Foo.__Internal*) value.__Instance;
            }
        }

        private global::System.IntPtr[] __arrayOfPrimitivePointers;

        private bool __arrayOfPrimitivePointersInitialised;
        public global::System.IntPtr[] ArrayOfPrimitivePointers
        {
            get
            {
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointers = null;
                    __arrayOfPrimitivePointersInitialised = true;
                }
                return __arrayOfPrimitivePointers;
            }

            set
            {
                __arrayOfPrimitivePointers = value;
                if (!__arrayOfPrimitivePointersInitialised)
                {
                    __arrayOfPrimitivePointersInitialised = true;
                }
            }
        }

        public global::CSharp.Foo[] Foos
        {
            get
            {
                global::CSharp.Foo[] __value = null;
                if (((global::CSharp.Baz.__Internal*) __Instance)->foos != null)
                {
                    __value = new global::CSharp.Foo[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::CSharp.Foo.__CreateInstance(*((global::CSharp.Foo.__Internal*)&(((global::CSharp.Baz.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        ((global::CSharp.Baz.__Internal*) __Instance)->foos[i * sizeof(global::CSharp.Foo.__Internal)] = *((byte*)(global::CSharp.Foo.__Internal*)value[i].__Instance);
                }
            }
        }

        public global::System.IntPtr __PointerToBar
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int[] Array
        {
            get
            {
                int[] __value = null;
                if (((global::CSharp.Baz.__Internal*) __Instance)->array != null)
                {
                    __value = new int[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::CSharp.Baz.__Internal*) __Instance)->array[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::CSharp.Baz.__Internal*) __Instance)->array[i] = value[i];
                }
            }
        }

        public global::System.IntPtr __PointerToQux
        {
            get
            {
                return __Instance + 0;
            }
        }

        public global::CSharp.IQux Interface
        {
            get
            {
                var __ret = __Internal.Interface_0((__Instance));
                global::CSharp.IQux __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Qux.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.IQux) global::CSharp.Qux.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Qux.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__PointerToQux;
                __Internal.SetInterface_0((__Instance), __arg0);
            }
        }

        int IBar.Method
        {
            get
            {
                var __ret = __Internal.Method_0((__Instance));
                return __ret;
            }
        }

        public int FarAwayFunc
        {
            get
            {
                var __ret = __Internal.FarAwayFunc_0((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // void v()
        private static global::CSharp.Delegates.Action_IntPtr _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Baz) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class QArrayData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QArrayData@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QArrayData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QArrayData>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QArrayData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QArrayData(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QArrayData __CreateInstance(global::CSharp.QArrayData.__Internal native, bool skipVTables = false)
        {
            return new QArrayData(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QArrayData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QArrayData.__Internal));
            *(global::CSharp.QArrayData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QArrayData(global::CSharp.QArrayData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QArrayData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QArrayData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QArrayData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public QArrayData(global::CSharp.QArrayData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QArrayData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.QArrayData.__Internal*) __Instance) = *((global::CSharp.QArrayData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.QArrayData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class QByteArrayDataPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr ptr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QByteArrayDataPtr@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QByteArrayDataPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QByteArrayDataPtr>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QByteArrayDataPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QByteArrayDataPtr(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QByteArrayDataPtr __CreateInstance(global::CSharp.QByteArrayDataPtr.__Internal native, bool skipVTables = false)
        {
            return new QByteArrayDataPtr(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QByteArrayDataPtr.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QByteArrayDataPtr.__Internal));
            *(global::CSharp.QByteArrayDataPtr.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QByteArrayDataPtr(global::CSharp.QByteArrayDataPtr.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QByteArrayDataPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QByteArrayDataPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QByteArrayDataPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public QByteArrayDataPtr(global::CSharp.QByteArrayDataPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QByteArrayDataPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance) = *((global::CSharp.QByteArrayDataPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.QByteArrayDataPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CSharp.QArrayData Ptr
        {
            get
            {
                global::CSharp.QArrayData __result0;
                if (((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance)->ptr == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.QArrayData.NativeToManagedMap.ContainsKey(((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance)->ptr))
                    __result0 = (global::CSharp.QArrayData) global::CSharp.QArrayData.NativeToManagedMap[((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance)->ptr];
                else __result0 = global::CSharp.QArrayData.__CreateInstance(((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance)->ptr);
                return __result0;
            }

            set
            {
                ((global::CSharp.QByteArrayDataPtr.__Internal*) __Instance)->ptr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe abstract partial class AbstractProprietor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractProprietor;

            [FieldOffset(4)]
            public int m_value;

            [FieldOffset(8)]
            public int m_property;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractProprietor@@IAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractProprietor@@IAE@H@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractProprietor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractProprietor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractProprietor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.AbstractProprietor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractProprietorInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.AbstractProprietor __CreateInstance(global::CSharp.AbstractProprietor.__Internal native, bool skipVTables = false)
        {
            return new AbstractProprietorInternal(native, skipVTables);
        }

        protected AbstractProprietor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected AbstractProprietor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractProprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.AbstractProprietor");
        }

        protected AbstractProprietor(int i)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractProprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), i);
            SetupVTables(GetType().FullName == "CSharp.AbstractProprietor");
        }

        protected AbstractProprietor(global::CSharp.AbstractProprietor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractProprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.AbstractProprietor");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.AbstractProprietor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.AbstractProprietor.__Internal*) __Instance)->vfptr_AbstractProprietor = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        protected int MValue
        {
            get
            {
                return ((global::CSharp.AbstractProprietor.__Internal*) __Instance)->m_value;
            }

            set
            {
                ((global::CSharp.AbstractProprietor.__Internal*) __Instance)->m_value = value;
            }
        }

        protected int MProperty
        {
            get
            {
                return ((global::CSharp.AbstractProprietor.__Internal*) __Instance)->m_property;
            }

            set
            {
                ((global::CSharp.AbstractProprietor.__Internal*) __Instance)->m_property = value;
            }
        }

        public abstract int Value
        {
            get;

            set;
        }

        public abstract int Prop
        {
            get;

            set;
        }

        public virtual int Parent
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 5 * 4);
                var ___Parent_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Parent_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public abstract global::CSharp.Foo Covariant
        {
            get;
        }

        #region Virtual table interop

        // int getValue()
        private static global::CSharp.Delegates.Func_int_IntPtr _Value_0DelegateInstance;

        private static int _Value_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Value;
            return __ret;
        }

        // void setValue(int newValue) = 0
        private static global::CSharp.Delegates.Action_IntPtr_int _SetValue_0DelegateInstance;

        private static void _SetValue_0DelegateHook(global::System.IntPtr instance, int newValue)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Value = newValue;
        }

        // long prop() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Prop_0DelegateInstance;

        private static int _Prop_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Prop;
            return __ret;
        }

        // void setProp(long prop)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProp_0DelegateInstance;

        private static void _SetProp_0DelegateHook(global::System.IntPtr instance, int prop)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Prop = prop;
        }

        // int parent()
        private static global::CSharp.Delegates.Func_int_IntPtr _Parent_0DelegateInstance;

        private static int _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return __ret;
        }

        // Foo& covariant() = 0
        private static global::CSharp.Delegates.Func_IntPtr_IntPtr _Covariant_0DelegateInstance;

        private static global::System.IntPtr _Covariant_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractProprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Covariant;
            if (ReferenceEquals(__ret, null))
                throw new global::System.ArgumentNullException("__ret", "Cannot be null because it is a C++ reference (&).");
            return __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _Value_0DelegateInstance += _Value_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Value_0DelegateInstance).ToPointer();
                _SetValue_0DelegateInstance += _SetValue_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValue_0DelegateInstance).ToPointer();
                _Prop_0DelegateInstance += _Prop_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Prop_0DelegateInstance).ToPointer();
                _SetProp_0DelegateInstance += _SetProp_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetProp_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Covariant_0DelegateInstance += _Covariant_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Covariant_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(7 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
                *(void**) (vfptr0 + 12) = _Thunks[3];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 20) = _Thunks[4];
                *(void**) (vfptr0 + 24) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class Proprietor : global::CSharp.AbstractProprietor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractProprietor;

            [FieldOffset(4)]
            public int m_value;

            [FieldOffset(8)]
            public int m_property;

            [FieldOffset(12)]
            public global::CSharp.Bar.Items _items;

            [FieldOffset(16)]
            public global::CSharp.Bar.Items _itemsByValue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Proprietor@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Proprietor@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0Proprietor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?items@Proprietor@@QBE?AW4Items@Bar@@XZ")]
            internal static extern global::CSharp.Bar.Items Items_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setItems@Proprietor@@QAEXABW4Items@Bar@@@Z")]
            internal static extern void SetItems_0(global::System.IntPtr instance, global::CSharp.Bar.Items* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?itemsByValue@Proprietor@@QBE?AW4Items@Bar@@XZ")]
            internal static extern global::CSharp.Bar.Items ItemsByValue_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setItemsByValue@Proprietor@@QAEXW4Items@Bar@@@Z")]
            internal static extern void SetItemsByValue_0(global::System.IntPtr instance, global::CSharp.Bar.Items value);
        }

        internal static new global::CSharp.Proprietor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new Proprietor(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.Proprietor __CreateInstance(global::CSharp.Proprietor.__Internal native, bool skipVTables = false)
        {
            return new Proprietor(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.Proprietor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.Proprietor.__Internal));
            global::CSharp.Proprietor.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private Proprietor(global::CSharp.Proprietor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Proprietor(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public Proprietor()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Proprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.Proprietor");
        }

        public Proprietor(int i)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Proprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), i);
            SetupVTables(GetType().FullName == "CSharp.Proprietor");
        }

        public Proprietor(global::CSharp.Proprietor _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.Proprietor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.Proprietor");
        }

        public static implicit operator global::CSharp.Proprietor(int i)
        {
            return new global::CSharp.Proprietor(i);
        }

        public override int Value
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Value_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Value_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetValue_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetValue_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        public global::CSharp.Bar.Items Items
        {
            get
            {
                var __ret = __Internal.Items_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetItems_0((__Instance + __PointerAdjustment), &value);
            }
        }

        public global::CSharp.Bar.Items ItemsByValue
        {
            get
            {
                var __ret = __Internal.ItemsByValue_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetItemsByValue_0((__Instance + __PointerAdjustment), value);
            }
        }

        public override int Prop
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                var ___Prop_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Prop_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
                var ___SetProp_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProp_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        public override global::CSharp.Foo Covariant
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 4);
                var ___Covariant_0Delegate = (global::CSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___Covariant_0Delegate((__Instance + __PointerAdjustment));
                global::CSharp.Foo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Foo.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // int getValue()
        private static global::CSharp.Delegates.Func_int_IntPtr _Value_0DelegateInstance;

        private static int _Value_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Value;
            return __ret;
        }

        // void setValue(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetValue_0DelegateInstance;

        private static void _SetValue_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Value = value;
        }

        // long prop()
        private static global::CSharp.Delegates.Func_int_IntPtr _Prop_0DelegateInstance;

        private static int _Prop_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Prop;
            return __ret;
        }

        // void setProp(long prop)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProp_0DelegateInstance;

        private static void _SetProp_0DelegateHook(global::System.IntPtr instance, int prop)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Prop = prop;
        }

        // int parent()
        private static global::CSharp.Delegates.Func_int_IntPtr _Parent_0DelegateInstance;

        private static int _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return __ret;
        }

        // Baz& covariant()
        private static global::CSharp.Delegates.Func_IntPtr_IntPtr _Covariant_0DelegateInstance;

        private static global::System.IntPtr _Covariant_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.Proprietor) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Covariant;
            if (ReferenceEquals(__ret, null))
                throw new global::System.ArgumentNullException("__ret", "Cannot be null because it is a C++ reference (&).");
            return __ret.__Instance;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[6];
                _Value_0DelegateInstance += _Value_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Value_0DelegateInstance).ToPointer();
                _SetValue_0DelegateInstance += _SetValue_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValue_0DelegateInstance).ToPointer();
                _Prop_0DelegateInstance += _Prop_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Prop_0DelegateInstance).ToPointer();
                _SetProp_0DelegateInstance += _SetProp_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetProp_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Covariant_0DelegateInstance += _Covariant_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Covariant_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(8 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
                *(void**) (vfptr0 + 12) = _Thunks[3];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 20) = _Thunks[4];
                *(void**) (vfptr0 + 24) = _Thunks[5];
                *(void**) (vfptr0 + 28) = _Thunks[5];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ComplexType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CSharp.TestFlag qFlags;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ComplexType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ComplexType@@QAE@V?$QFlags@W4TestFlag@@@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::CSharp.TestFlag f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ComplexType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?check@ComplexType@@QAEHXZ")]
            internal static extern int Check_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?takesQFlags@ComplexType@@QAEXV?$QFlags@H@@@Z")]
            internal static extern void TakesQFlags_0(global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?returnsQFlags@ComplexType@@QAE?AV?$QFlags@W4TestFlag@@@@XZ")]
            internal static extern void ReturnsQFlags_0(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ComplexType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ComplexType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.ComplexType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ComplexType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ComplexType __CreateInstance(global::CSharp.ComplexType.__Internal native, bool skipVTables = false)
        {
            return new ComplexType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ComplexType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ComplexType.__Internal));
            *(global::CSharp.ComplexType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ComplexType(global::CSharp.ComplexType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ComplexType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ComplexType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ComplexType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public ComplexType(global::CSharp.TestFlag f)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ComplexType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), f);
        }

        public ComplexType(global::CSharp.ComplexType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ComplexType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.ComplexType.__Internal*) __Instance) = *((global::CSharp.ComplexType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ComplexType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Check()
        {
            var __ret = __Internal.Check_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void TakesQFlags(int f)
        {
            __Internal.TakesQFlags_0((__Instance + __PointerAdjustment), f);
        }

        public static implicit operator global::CSharp.ComplexType(global::CSharp.TestFlag f)
        {
            return new global::CSharp.ComplexType(f);
        }

        public global::CSharp.TestFlag ReturnsQFlags
        {
            get
            {
                global::CSharp.TestFlag __ret;
                __Internal.ReturnsQFlags_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return __ret;
            }
        }
    }

    public unsafe partial class P : global::CSharp.Proprietor, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractProprietor;

            [FieldOffset(4)]
            public int m_value;

            [FieldOffset(8)]
            public int m_property;

            [FieldOffset(12)]
            public global::CSharp.Bar.Items _items;

            [FieldOffset(16)]
            public global::CSharp.Bar.Items _itemsByValue;

            [FieldOffset(20)]
            public global::CSharp.ComplexType.__Internal m_complexType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0P@@QAE@PAVQux@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::System.IntPtr qux);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0P@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?test@P@@QAEXXZ")]
            internal static extern void GetTest_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?complexType@P@@QAE?AVComplexType@@XZ")]
            internal static extern void ComplexType_0(global::System.IntPtr instance, global::System.IntPtr @return);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setComplexType@P@@QAEXABVComplexType@@@Z")]
            internal static extern void SetComplexType_0(global::System.IntPtr instance, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?isTest@P@@QAE_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Test_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setTest@P@@QAEX_N@Z")]
            internal static extern void SetTest_0(global::System.IntPtr instance, sbyte value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?isBool@P@@QAE_NXZ")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsBool_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setIsBool@P@@QAEX_N@Z")]
            internal static extern void SetIsBool_0(global::System.IntPtr instance, sbyte value);
        }

        internal static new global::CSharp.P __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new P(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.P __CreateInstance(global::CSharp.P.__Internal native, bool skipVTables = false)
        {
            return new P(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.P.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.P.__Internal));
            global::CSharp.P.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private P(global::CSharp.P.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected P(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public P(global::CSharp.IQux qux)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.P.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(qux, null) ? global::System.IntPtr.Zero : qux.__PointerToQux;
            __Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.P");
        }

        public P(global::CSharp.P _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.P.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.P");
        }

        public virtual void parent(int i)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 8 * 4);
            var ___parent_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
            ___parent_0Delegate((__Instance + __PointerAdjustment), i);
        }

        public void GetTest()
        {
            __Internal.GetTest_0((__Instance + __PointerAdjustment));
        }

        public static implicit operator global::CSharp.P(global::CSharp.Qux qux)
        {
            return new global::CSharp.P((IQux) qux);
        }

        public override int Value
        {
            get
            {
                return base.Value;
            }

            set
            {
                base.Value = value;
            }
        }

        public global::CSharp.ComplexType ComplexType
        {
            get
            {
                var __ret = new global::CSharp.ComplexType.__Internal();
                __Internal.ComplexType_0((__Instance + __PointerAdjustment), new IntPtr(&__ret));
                return global::CSharp.ComplexType.__CreateInstance(__ret);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = value.__Instance;
                __Internal.SetComplexType_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public bool Test
        {
            get
            {
                var __ret = __Internal.Test_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetTest_0((__Instance + __PointerAdjustment), value ? (sbyte)1: (sbyte)0);
            }
        }

        public bool IsBool
        {
            get
            {
                var __ret = __Internal.IsBool_0((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                __Internal.SetIsBool_0((__Instance + __PointerAdjustment), value ? (sbyte)1: (sbyte)0);
            }
        }

        public override int Prop
        {
            get
            {
                return base.Prop;
            }

            set
            {
                base.Prop = value;
            }
        }

        #region Virtual table interop

        // int getValue()
        private static global::CSharp.Delegates.Func_int_IntPtr _Value_0DelegateInstance;

        private static int _Value_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Value;
            return __ret;
        }

        // void setValue(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetValue_0DelegateInstance;

        private static void _SetValue_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Value = value;
        }

        // long prop()
        private static global::CSharp.Delegates.Func_int_IntPtr _Prop_0DelegateInstance;

        private static int _Prop_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Prop;
            return __ret;
        }

        // void setProp(long prop)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProp_0DelegateInstance;

        private static void _SetProp_0DelegateHook(global::System.IntPtr instance, int prop)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Prop = prop;
        }

        // int parent()
        private static global::CSharp.Delegates.Func_int_IntPtr _Parent_0DelegateInstance;

        private static int _Parent_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Parent;
            return __ret;
        }

        // Baz& covariant()
        private static global::CSharp.Delegates.Func_IntPtr_IntPtr _Covariant_0DelegateInstance;

        private static global::System.IntPtr _Covariant_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Covariant;
            if (ReferenceEquals(__ret, null))
                throw new global::System.ArgumentNullException("__ret", "Cannot be null because it is a C++ reference (&).");
            return __ret.__Instance;
        }

        // void parent(int i)
        private static global::CSharp.Delegates.Action_IntPtr_int _parent_0DelegateInstance;

        private static void _parent_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.P) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.parent(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[7];
                _Value_0DelegateInstance += _Value_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Value_0DelegateInstance).ToPointer();
                _SetValue_0DelegateInstance += _SetValue_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetValue_0DelegateInstance).ToPointer();
                _Prop_0DelegateInstance += _Prop_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Prop_0DelegateInstance).ToPointer();
                _SetProp_0DelegateInstance += _SetProp_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_SetProp_0DelegateInstance).ToPointer();
                _Parent_0DelegateInstance += _Parent_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_Parent_0DelegateInstance).ToPointer();
                _Covariant_0DelegateInstance += _Covariant_0DelegateHook;
                _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_Covariant_0DelegateInstance).ToPointer();
                _parent_0DelegateInstance += _parent_0DelegateHook;
                _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_parent_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(9 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
                *(void**) (vfptr0 + 8) = _Thunks[2];
                *(void**) (vfptr0 + 12) = _Thunks[3];
                *(void**) (vfptr0 + 16) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 16);
                *(void**) (vfptr0 + 20) = _Thunks[4];
                *(void**) (vfptr0 + 24) = _Thunks[5];
                *(void**) (vfptr0 + 28) = _Thunks[5];
                *(void**) (vfptr0 + 32) = _Thunks[6];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TestDestructors : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestDestructors@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestDestructors@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1TestDestructors@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?InitMarker@TestDestructors@@SAXXZ")]
            internal static extern void InitMarker_0();
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestDestructors> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestDestructors>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestDestructors __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestDestructors(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestDestructors __CreateInstance(global::CSharp.TestDestructors.__Internal native, bool skipVTables = false)
        {
            return new TestDestructors(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestDestructors.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestDestructors.__Internal));
            *(global::CSharp.TestDestructors.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestDestructors(global::CSharp.TestDestructors.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestDestructors(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestDestructors()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestDestructors.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestDestructors(global::CSharp.TestDestructors _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestDestructors.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestDestructors.__Internal*) __Instance) = *((global::CSharp.TestDestructors.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestDestructors __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static void InitMarker()
        {
            __Internal.InitMarker_0();
        }

        public static int Marker
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?Marker@TestDestructors@@2HA");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?Marker@TestDestructors@@2HA");
                *__ptr = value;
            }
        }
    }

    public unsafe partial struct TestCopyConstructorVal
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestCopyConstructorVal@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestCopyConstructorVal@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);
        }

        private TestCopyConstructorVal.__Internal __instance;
        internal TestCopyConstructorVal.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.TestCopyConstructorVal __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestCopyConstructorVal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestCopyConstructorVal __CreateInstance(global::CSharp.TestCopyConstructorVal.__Internal native, bool skipVTables = false)
        {
            return new TestCopyConstructorVal(native, skipVTables);
        }

        private TestCopyConstructorVal(global::CSharp.TestCopyConstructorVal.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private TestCopyConstructorVal(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.TestCopyConstructorVal.__Internal*) native;
        }

        public TestCopyConstructorVal(global::CSharp.TestCopyConstructorVal other)
            : this()
        {
            var ____arg0 = other.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public int A
        {
            get
            {
                return __instance.A;
            }

            set
            {
                __instance.A = value;
            }
        }

        public float B
        {
            get
            {
                return __instance.B;
            }

            set
            {
                __instance.B = value;
            }
        }
    }

    public unsafe partial class TestRenaming : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int _property;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestRenaming@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestRenaming@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1TestRenaming@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?name@TestRenaming@@QAEXXZ")]
            internal static extern void name_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?Name@TestRenaming@@QAEXXZ")]
            internal static extern void Name_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?property@TestRenaming@@QAEHXZ")]
            internal static extern int Property_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestRenaming> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestRenaming>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestRenaming __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestRenaming(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestRenaming __CreateInstance(global::CSharp.TestRenaming.__Internal native, bool skipVTables = false)
        {
            return new TestRenaming(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestRenaming.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestRenaming.__Internal));
            *(global::CSharp.TestRenaming.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestRenaming(global::CSharp.TestRenaming.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestRenaming(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestRenaming()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestRenaming.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestRenaming(global::CSharp.TestRenaming _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestRenaming.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestRenaming.__Internal*) __Instance) = *((global::CSharp.TestRenaming.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestRenaming __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void name()
        {
            __Internal.name_0((__Instance + __PointerAdjustment));
        }

        public void Name()
        {
            __Internal.Name_0((__Instance + __PointerAdjustment));
        }

        protected int _property
        {
            get
            {
                return ((global::CSharp.TestRenaming.__Internal*) __Instance)->_property;
            }

            set
            {
                ((global::CSharp.TestRenaming.__Internal*) __Instance)->_property = value;
            }
        }

        public int Property
        {
            get
            {
                var __ret = __Internal.Property_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class UsesPointerToEnumInParamOfVirtual : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_UsesPointerToEnumInParamOfVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0UsesPointerToEnumInParamOfVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0UsesPointerToEnumInParamOfVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?callOverrideOfHasPointerToEnumInParam@UsesPointerToEnumInParamOfVirtual@@SA?AV?$QFlags@W4Flags@@@@PBV1@ABV2@@Z")]
            internal static extern void CallOverrideOfHasPointerToEnumInParam_0(global::System.IntPtr @return, global::System.IntPtr @object, global::System.IntPtr pointerToEnum);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.UsesPointerToEnumInParamOfVirtual> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.UsesPointerToEnumInParamOfVirtual>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.UsesPointerToEnumInParamOfVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new UsesPointerToEnumInParamOfVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.UsesPointerToEnumInParamOfVirtual __CreateInstance(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal native, bool skipVTables = false)
        {
            return new UsesPointerToEnumInParamOfVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal));
            global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private UsesPointerToEnumInParamOfVirtual(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected UsesPointerToEnumInParamOfVirtual(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public UsesPointerToEnumInParamOfVirtual()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.UsesPointerToEnumInParamOfVirtual");
        }

        public UsesPointerToEnumInParamOfVirtual(global::CSharp.UsesPointerToEnumInParamOfVirtual _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.UsesPointerToEnumInParamOfVirtual");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.UsesPointerToEnumInParamOfVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.UsesPointerToEnumInParamOfVirtual.__Internal*) __Instance)->vfptr_UsesPointerToEnumInParamOfVirtual = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual global::CSharp.Flags HasPointerToEnumInParam(global::CSharp.Flags pointerToEnum)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___HasPointerToEnumInParam_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            var __arg0 = new global::System.IntPtr(&pointerToEnum);
            global::CSharp.Flags __ret;
            ___HasPointerToEnumInParam_0Delegate((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return __ret;
        }

        public static global::CSharp.Flags CallOverrideOfHasPointerToEnumInParam(global::CSharp.UsesPointerToEnumInParamOfVirtual @object, global::CSharp.Flags pointerToEnum)
        {
            var __arg0 = ReferenceEquals(@object, null) ? global::System.IntPtr.Zero : @object.__Instance;
            var __arg1 = new global::System.IntPtr(&pointerToEnum);
            global::CSharp.Flags __ret;
            __Internal.CallOverrideOfHasPointerToEnumInParam_0(new IntPtr(&__ret), __arg0, __arg1);
            return __ret;
        }

        #region Virtual table interop

        // virtual ~UsesPointerToEnumInParamOfVirtual()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.UsesPointerToEnumInParamOfVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // QFlags<Flags> hasPointerToEnumInParam(const QFlags<Flags>& pointerToEnum) const
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _HasPointerToEnumInParam_0DelegateInstance;

        private static void _HasPointerToEnumInParam_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr pointerToEnum)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.UsesPointerToEnumInParamOfVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.HasPointerToEnumInParam(*(global::CSharp.Flags*) pointerToEnum);
            *(global::CSharp.Flags*) @return = __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _HasPointerToEnumInParam_0DelegateInstance += _HasPointerToEnumInParam_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_HasPointerToEnumInParam_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial struct QGenericArgument
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public void* fixedArrayInValueType;

            [FieldOffset(4)]
            public global::System.IntPtr _name;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QGenericArgument@@QAE@PBD@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QGenericArgument@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private QGenericArgument.__Internal __instance;
        internal QGenericArgument.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.QGenericArgument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QGenericArgument(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QGenericArgument __CreateInstance(global::CSharp.QGenericArgument.__Internal native, bool skipVTables = false)
        {
            return new QGenericArgument(native, skipVTables);
        }

        private QGenericArgument(global::CSharp.QGenericArgument.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private QGenericArgument(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.QGenericArgument.__Internal*) native;
        }

        public QGenericArgument(string name = null)
            : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_0(new global::System.IntPtr(__instancePtr), name);
            }
        }

        public QGenericArgument(global::CSharp.QGenericArgument _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public static implicit operator global::CSharp.QGenericArgument(string name)
        {
            return new global::CSharp.QGenericArgument(name);
        }

        private global::System.IntPtr[] __fixedArrayInValueType;

        private bool __fixedArrayInValueTypeInitialised;
        public global::System.IntPtr[] FixedArrayInValueType
        {
            get
            {
                if (!__fixedArrayInValueTypeInitialised)
                {
                    __fixedArrayInValueType = null;
                    __fixedArrayInValueTypeInitialised = true;
                }
                return __fixedArrayInValueType;
            }

            set
            {
                __fixedArrayInValueType = value;
                if (!__fixedArrayInValueTypeInitialised)
                {
                    __fixedArrayInValueTypeInitialised = true;
                }
            }
        }
    }

    public unsafe partial class TestObjectMapWithClassDerivedFromStruct : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public void* fixedArrayInValueType;

            [FieldOffset(4)]
            public global::System.IntPtr _name;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestObjectMapWithClassDerivedFromStruct@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestObjectMapWithClassDerivedFromStruct@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestObjectMapWithClassDerivedFromStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestObjectMapWithClassDerivedFromStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestObjectMapWithClassDerivedFromStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestObjectMapWithClassDerivedFromStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestObjectMapWithClassDerivedFromStruct __CreateInstance(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal native, bool skipVTables = false)
        {
            return new TestObjectMapWithClassDerivedFromStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal));
            *(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestObjectMapWithClassDerivedFromStruct(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestObjectMapWithClassDerivedFromStruct(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestObjectMapWithClassDerivedFromStruct()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestObjectMapWithClassDerivedFromStruct(global::CSharp.TestObjectMapWithClassDerivedFromStruct _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal*) __Instance) = *((global::CSharp.TestObjectMapWithClassDerivedFromStruct.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestObjectMapWithClassDerivedFromStruct __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class QColor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QColor@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QColor@@QAE@W4GlobalColor@Qt@@@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, global::CSharp.Qt.GlobalColor color);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QColor@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QColor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QColor>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QColor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QColor(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QColor __CreateInstance(global::CSharp.QColor.__Internal native, bool skipVTables = false)
        {
            return new QColor(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QColor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QColor.__Internal));
            *(global::CSharp.QColor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QColor(global::CSharp.QColor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public QColor(global::CSharp.Qt.GlobalColor color)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), color);
        }

        public QColor(global::CSharp.QColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.QColor.__Internal*) __Instance) = *((global::CSharp.QColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.QColor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CSharp.QColor(global::CSharp.Qt.GlobalColor color)
        {
            return new global::CSharp.QColor(color);
        }
    }

    public unsafe partial struct QPoint
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPoint@@QAE@HH@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int x, int y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPoint@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private QPoint.__Internal __instance;
        internal QPoint.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.QPoint __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QPoint(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QPoint __CreateInstance(global::CSharp.QPoint.__Internal native, bool skipVTables = false)
        {
            return new QPoint(native, skipVTables);
        }

        private QPoint(global::CSharp.QPoint.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private QPoint(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.QPoint.__Internal*) native;
        }

        public QPoint(int x, int y)
            : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_0(new global::System.IntPtr(__instancePtr), x, y);
            }
        }

        public QPoint(global::CSharp.QPoint _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }
    }

    public unsafe partial struct QSize
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QSize@@QAE@HH@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int w, int h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QSize@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private QSize.__Internal __instance;
        internal QSize.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.QSize __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QSize(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QSize __CreateInstance(global::CSharp.QSize.__Internal native, bool skipVTables = false)
        {
            return new QSize(native, skipVTables);
        }

        private QSize(global::CSharp.QSize.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private QSize(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.QSize.__Internal*) native;
        }

        public QSize(int w, int h)
            : this()
        {
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_0(new global::System.IntPtr(__instancePtr), w, h);
            }
        }

        public QSize(global::CSharp.QSize _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }
    }

    public unsafe partial struct QRect
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QRect@@QAE@VQPoint@@VQSize@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::CSharp.QPoint.__Internal p, global::CSharp.QSize.__Internal s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QRect@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private QRect.__Internal __instance;
        internal QRect.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.QRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QRect(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QRect __CreateInstance(global::CSharp.QRect.__Internal native, bool skipVTables = false)
        {
            return new QRect(native, skipVTables);
        }

        private QRect(global::CSharp.QRect.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private QRect(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.QRect.__Internal*) native;
        }

        public QRect(global::CSharp.QPoint p, global::CSharp.QSize s)
            : this()
        {
            var __arg0 = p.__Instance;
            var __arg1 = s.__Instance;
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_0(new global::System.IntPtr(__instancePtr), __arg0, __arg1);
            }
        }

        public QRect(global::CSharp.QRect _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }
    }

    public unsafe partial class DefaultZeroMappedToEnum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DefaultZeroMappedToEnum@@QAE@PAH@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int* _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DefaultZeroMappedToEnum@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DefaultZeroMappedToEnum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DefaultZeroMappedToEnum>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.DefaultZeroMappedToEnum __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DefaultZeroMappedToEnum(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.DefaultZeroMappedToEnum __CreateInstance(global::CSharp.DefaultZeroMappedToEnum.__Internal native, bool skipVTables = false)
        {
            return new DefaultZeroMappedToEnum(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.DefaultZeroMappedToEnum.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.DefaultZeroMappedToEnum.__Internal));
            *(global::CSharp.DefaultZeroMappedToEnum.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DefaultZeroMappedToEnum(global::CSharp.DefaultZeroMappedToEnum.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DefaultZeroMappedToEnum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DefaultZeroMappedToEnum(ref int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.DefaultZeroMappedToEnum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            fixed (int* __refParamPtr0 = &_0)
            {
                var __arg0 = __refParamPtr0;
                __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public DefaultZeroMappedToEnum(global::CSharp.DefaultZeroMappedToEnum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.DefaultZeroMappedToEnum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.DefaultZeroMappedToEnum.__Internal*) __Instance) = *((global::CSharp.DefaultZeroMappedToEnum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.DefaultZeroMappedToEnum __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CSharp.DefaultZeroMappedToEnum(int* _0)
        {
            return new global::CSharp.DefaultZeroMappedToEnum(ref *_0);
        }
    }

    public unsafe partial class MethodsWithDefaultValues : global::CSharp.Quux, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public int priv;

            [FieldOffset(4)]
            public global::CSharp.Foo.__Internal m_foo;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MethodsWithDefaultValues@@QAE@VFoo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::CSharp.Foo.__Internal foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MethodsWithDefaultValues@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MethodsWithDefaultValues@@QAE@MPAH@Z")]
            internal static extern global::System.IntPtr ctor_2(global::System.IntPtr instance, float a, int* b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MethodsWithDefaultValues@@QAE@NV?$QList@VQColor@@@@@Z")]
            internal static extern global::System.IntPtr ctor_3(global::System.IntPtr instance, double d, QList.__Internal list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MethodsWithDefaultValues@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultPointer@MethodsWithDefaultValues@@QAEXPAVFoo@@@Z")]
            internal static extern void DefaultPointer_0(global::System.IntPtr instance, global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultVoidStar@MethodsWithDefaultValues@@QAEXPAX@Z")]
            internal static extern void DefaultVoidStar_0(global::System.IntPtr instance, global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultValueType@MethodsWithDefaultValues@@QAEXUQGenericArgument@@@Z")]
            internal static extern void DefaultValueType_0(global::System.IntPtr instance, global::CSharp.QGenericArgument.__Internal valueType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultChar@MethodsWithDefaultValues@@QAEXD@Z")]
            internal static extern void DefaultChar_0(global::System.IntPtr instance, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultEmptyChar@MethodsWithDefaultValues@@QAEXD@Z")]
            internal static extern void DefaultEmptyChar_0(global::System.IntPtr instance, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultRefTypeBeforeOthers@MethodsWithDefaultValues@@QAEXVFoo@@HW4Items@Bar@@@Z")]
            internal static extern void DefaultRefTypeBeforeOthers_0(global::System.IntPtr instance, global::CSharp.Foo.__Internal foo, int i, global::CSharp.Bar.Items item);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultRefTypeAfterOthers@MethodsWithDefaultValues@@QAEXHW4Items@Bar@@VFoo@@@Z")]
            internal static extern void DefaultRefTypeAfterOthers_0(global::System.IntPtr instance, int i, global::CSharp.Bar.Items item, global::CSharp.Foo.__Internal foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultRefTypeBeforeAndAfterOthers@MethodsWithDefaultValues@@QAEXHVFoo@@W4Items@Bar@@VBaz@@@Z")]
            internal static extern void DefaultRefTypeBeforeAndAfterOthers_0(global::System.IntPtr instance, int i, global::CSharp.Foo.__Internal foo, global::CSharp.Bar.Items item, global::CSharp.Baz.__Internal baz);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultIntAssignedAnEnum@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultIntAssignedAnEnum_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultRefAssignedValue@MethodsWithDefaultValues@@QAEXABVFoo@@@Z")]
            internal static extern void defaultRefAssignedValue_0(global::System.IntPtr instance, global::System.IntPtr fooRef);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DefaultRefAssignedValue@MethodsWithDefaultValues@@QAEXABVFoo@@@Z")]
            internal static extern void DefaultRefAssignedValue_0(global::System.IntPtr instance, global::System.IntPtr fooRef);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultEnumAssignedBitwiseOr@MethodsWithDefaultValues@@QAEXW4Flags@@@Z")]
            internal static extern void DefaultEnumAssignedBitwiseOr_0(global::System.IntPtr instance, global::CSharp.Flags flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultEnumAssignedBitwiseOrShort@MethodsWithDefaultValues@@QAEXW4UntypedFlags@@@Z")]
            internal static extern void DefaultEnumAssignedBitwiseOrShort_0(global::System.IntPtr instance, global::CSharp.UntypedFlags flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultNonEmptyCtor@MethodsWithDefaultValues@@QAEXUQGenericArgument@@@Z")]
            internal static extern void DefaultNonEmptyCtor_0(global::System.IntPtr instance, global::CSharp.QGenericArgument.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultNonEmptyCtorWithNullPtr@MethodsWithDefaultValues@@QAEXUQGenericArgument@@@Z")]
            internal static extern void DefaultNonEmptyCtorWithNullPtr_0(global::System.IntPtr instance, global::CSharp.QGenericArgument.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultMappedToEnum@MethodsWithDefaultValues@@QAE?AV?$QFlags@W4Flags@@@@ABV2@@Z")]
            internal static extern void DefaultMappedToEnum_0(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr qFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultMappedToZeroEnum@MethodsWithDefaultValues@@QAEXV?$QFlags@W4Flags@@@@@Z")]
            internal static extern void DefaultMappedToZeroEnum_0(global::System.IntPtr instance, global::CSharp.Flags qFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultMappedToEnumAssignedWithCtor@MethodsWithDefaultValues@@QAEXV?$QFlags@W4Flags@@@@@Z")]
            internal static extern void DefaultMappedToEnumAssignedWithCtor_0(global::System.IntPtr instance, global::CSharp.Flags qFlags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultZeroMappedToEnumAssignedWithCtor@MethodsWithDefaultValues@@QAEXVDefaultZeroMappedToEnum@@@Z")]
            internal static extern void DefaultZeroMappedToEnumAssignedWithCtor_0(global::System.IntPtr instance, Flags defaultZeroMappedToEnum);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultImplicitCtorInt@MethodsWithDefaultValues@@QAEXVQuux@@@Z")]
            internal static extern void DefaultImplicitCtorInt_0(global::System.IntPtr instance, global::CSharp.Quux.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultImplicitCtorChar@MethodsWithDefaultValues@@QAEXVQuux@@@Z")]
            internal static extern void DefaultImplicitCtorChar_0(global::System.IntPtr instance, global::CSharp.Quux.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultImplicitCtorFoo@MethodsWithDefaultValues@@QAEXVQuux@@@Z")]
            internal static extern void DefaultImplicitCtorFoo_0(global::System.IntPtr instance, global::CSharp.Quux.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultImplicitCtorEnum@MethodsWithDefaultValues@@QAEXVBaz@@@Z")]
            internal static extern void DefaultImplicitCtorEnum_0(global::System.IntPtr instance, global::CSharp.Baz.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultImplicitCtorEnumTwo@MethodsWithDefaultValues@@QAEXVBar@@@Z")]
            internal static extern void DefaultImplicitCtorEnumTwo_0(global::System.IntPtr instance, global::CSharp.Bar.__Internal arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultIntWithLongExpression@MethodsWithDefaultValues@@QAEXI@Z")]
            internal static extern void DefaultIntWithLongExpression_0(global::System.IntPtr instance, uint i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultRefTypeEnumImplicitCtor@MethodsWithDefaultValues@@QAEXABVQColor@@@Z")]
            internal static extern void DefaultRefTypeEnumImplicitCtor_0(global::System.IntPtr instance, global::System.IntPtr fillColor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?rotate4x4Matrix@MethodsWithDefaultValues@@QAEXMMMM@Z")]
            internal static extern void Rotate4x4Matrix_0(global::System.IntPtr instance, float angle, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultPointerToValueType@MethodsWithDefaultValues@@QAEXPAUQGenericArgument@@@Z")]
            internal static extern void DefaultPointerToValueType_0(global::System.IntPtr instance, global::System.IntPtr pointer);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultDoubleWithoutF@MethodsWithDefaultValues@@QAEXNN@Z")]
            internal static extern void DefaultDoubleWithoutF_0(global::System.IntPtr instance, double d1, double d2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultIntExpressionWithEnum@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultIntExpressionWithEnum_0(global::System.IntPtr instance, int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultCtorWithMoreThanOneArg@MethodsWithDefaultValues@@QAEXVQMargins@1@@Z")]
            internal static extern void DefaultCtorWithMoreThanOneArg_0(global::System.IntPtr instance, global::CSharp.MethodsWithDefaultValues.QMargins.__Internal m);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithComplexArgs@MethodsWithDefaultValues@@QAEXABVQRect@@@Z")]
            internal static extern void DefaultWithComplexArgs_0(global::System.IntPtr instance, global::System.IntPtr rectangle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithRefManagedLong@MethodsWithDefaultValues@@QAEXPA_J@Z")]
            internal static extern void DefaultWithRefManagedLong_0(global::System.IntPtr instance, long* i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithFunctionCall@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultWithFunctionCall_0(global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithPropertyCall@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultWithPropertyCall_0(global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithGetPropertyCall@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultWithGetPropertyCall_0(global::System.IntPtr instance, int f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithIndirectStringConstant@MethodsWithDefaultValues@@QAEXABVFoo@@@Z")]
            internal static extern void DefaultWithIndirectStringConstant_0(global::System.IntPtr instance, global::System.IntPtr arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithDirectIntConstant@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultWithDirectIntConstant_0(global::System.IntPtr instance, int arg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithEnumInLowerCasedNameSpace@MethodsWithDefaultValues@@QAEXW4Enum@lowerCaseNameSpace@@@Z")]
            internal static extern void DefaultWithEnumInLowerCasedNameSpace_0(global::System.IntPtr instance, global::CSharp.LowerCaseNameSpace.Enum e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithCharFromInt@MethodsWithDefaultValues@@QAEXD@Z")]
            internal static extern void DefaultWithCharFromInt_0(global::System.IntPtr instance, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?defaultWithFreeConstantInNameSpace@MethodsWithDefaultValues@@QAEXH@Z")]
            internal static extern void DefaultWithFreeConstantInNameSpace_0(global::System.IntPtr instance, int c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?DefaultWithParamNamedSameAsMethod@MethodsWithDefaultValues@@QAEHHABVFoo@@@Z")]
            internal static extern int DefaultWithParamNamedSameAsMethod_0(global::System.IntPtr instance, int DefaultWithParamNamedSameAsMethod, global::System.IntPtr defaultArg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getA@MethodsWithDefaultValues@@QAEHXZ")]
            internal static extern int GetA_0(global::System.IntPtr instance);
        }

        public unsafe partial class QMargins : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0QMargins@MethodsWithDefaultValues@@QAE@HHHH@Z")]
                internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int left, int top, int right, int bottom);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0QMargins@MethodsWithDefaultValues@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MethodsWithDefaultValues.QMargins> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MethodsWithDefaultValues.QMargins>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CSharp.MethodsWithDefaultValues.QMargins __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new QMargins(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.MethodsWithDefaultValues.QMargins __CreateInstance(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal native, bool skipVTables = false)
            {
                return new QMargins(native, skipVTables);
            }

            private static void* __CopyValue(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal));
                *(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private QMargins(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QMargins(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public QMargins(int left, int top, int right, int bottom)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_0((__Instance + __PointerAdjustment), left, top, right, bottom);
            }

            public QMargins(global::CSharp.MethodsWithDefaultValues.QMargins _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CSharp.MethodsWithDefaultValues.QMargins.__Internal*) __Instance) = *((global::CSharp.MethodsWithDefaultValues.QMargins.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CSharp.MethodsWithDefaultValues.QMargins __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        internal static new global::CSharp.MethodsWithDefaultValues __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MethodsWithDefaultValues(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MethodsWithDefaultValues __CreateInstance(global::CSharp.MethodsWithDefaultValues.__Internal native, bool skipVTables = false)
        {
            return new MethodsWithDefaultValues(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MethodsWithDefaultValues.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            *(global::CSharp.MethodsWithDefaultValues.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MethodsWithDefaultValues(global::CSharp.MethodsWithDefaultValues.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MethodsWithDefaultValues(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MethodsWithDefaultValues(global::CSharp.Foo foo)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public MethodsWithDefaultValues(int a)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment), a);
        }

        public MethodsWithDefaultValues(float a, ref int b)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            fixed (int* __refParamPtr1 = &b)
            {
                var __arg1 = __refParamPtr1;
                __Internal.ctor_2((__Instance + __PointerAdjustment), a, __arg1);
            }
        }

        public MethodsWithDefaultValues(double d, System.Collections.Generic.IList<global::CSharp.QColor> list)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg1 = new QList.__Internal();
            __Internal.ctor_3((__Instance + __PointerAdjustment), d, __arg1);
        }

        public MethodsWithDefaultValues(global::CSharp.MethodsWithDefaultValues _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MethodsWithDefaultValues.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.MethodsWithDefaultValues.__Internal*) __Instance) = *((global::CSharp.MethodsWithDefaultValues.__Internal*) _0.__Instance);
        }

        public MethodsWithDefaultValues() : this(new global::CSharp.Foo(null))
        {
        }

        public MethodsWithDefaultValues(double d) : this(d, new System.Collections.Generic.List<global::CSharp.QColor>())
        {
        }

        public void DefaultPointer(global::CSharp.Foo ptr = null)
        {
            var __arg0 = ReferenceEquals(ptr, null) ? global::System.IntPtr.Zero : ptr.__Instance;
            __Internal.DefaultPointer_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultVoidStar(global::System.IntPtr ptr = new global::System.IntPtr())
        {
            __Internal.DefaultVoidStar_0((__Instance + __PointerAdjustment), ptr);
        }

        public void DefaultValueType(global::CSharp.QGenericArgument valueType)
        {
            var __arg0 = valueType.__Instance;
            __Internal.DefaultValueType_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultChar(char c = 'a')
        {
            var __arg0 = global::System.Convert.ToSByte(c);
            __Internal.DefaultChar_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultEmptyChar(char c = '\0')
        {
            var __arg0 = global::System.Convert.ToSByte(c);
            __Internal.DefaultEmptyChar_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultRefTypeBeforeOthers(global::CSharp.Foo foo, int i = 5, global::CSharp.Bar.Items item = global::CSharp.Bar.Items.Item2)
        {
            var __arg0 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            __Internal.DefaultRefTypeBeforeOthers_0((__Instance + __PointerAdjustment), __arg0, i, item);
        }

        public void DefaultRefTypeAfterOthers(int i, global::CSharp.Bar.Items item, global::CSharp.Foo foo)
        {
            var __arg2 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            __Internal.DefaultRefTypeAfterOthers_0((__Instance + __PointerAdjustment), i, item, __arg2);
        }

        public void DefaultRefTypeBeforeAndAfterOthers(int i, global::CSharp.Foo foo, global::CSharp.Bar.Items item, global::CSharp.Baz baz)
        {
            var __arg1 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            var __arg3 = ReferenceEquals(baz, null) ? new global::CSharp.Baz.__Internal() : *(global::CSharp.Baz.__Internal*) baz.__Instance;
            __Internal.DefaultRefTypeBeforeAndAfterOthers_0((__Instance + __PointerAdjustment), i, __arg1, item, __arg3);
        }

        public void DefaultIntAssignedAnEnum(int i = (int) global::CSharp.Bar.Items.Item1)
        {
            __Internal.DefaultIntAssignedAnEnum_0((__Instance + __PointerAdjustment), i);
        }

        public void defaultRefAssignedValue(global::CSharp.Foo fooRef)
        {
            if (ReferenceEquals(fooRef, null))
                throw new global::System.ArgumentNullException("fooRef", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = fooRef.__Instance;
            __Internal.defaultRefAssignedValue_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultRefAssignedValue(global::CSharp.Foo fooRef)
        {
            if (ReferenceEquals(fooRef, null))
                throw new global::System.ArgumentNullException("fooRef", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = fooRef.__Instance;
            __Internal.DefaultRefAssignedValue_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultEnumAssignedBitwiseOr(global::CSharp.Flags flags = global::CSharp.Flags.Flag1 | global::CSharp.Flags.Flag2)
        {
            __Internal.DefaultEnumAssignedBitwiseOr_0((__Instance + __PointerAdjustment), flags);
        }

        public void DefaultEnumAssignedBitwiseOrShort(global::CSharp.UntypedFlags flags = global::CSharp.UntypedFlags.Flag1 | global::CSharp.UntypedFlags.Flag2)
        {
            __Internal.DefaultEnumAssignedBitwiseOrShort_0((__Instance + __PointerAdjustment), flags);
        }

        public void DefaultNonEmptyCtor(global::CSharp.QGenericArgument arg)
        {
            var __arg0 = arg.__Instance;
            __Internal.DefaultNonEmptyCtor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultNonEmptyCtorWithNullPtr(global::CSharp.QGenericArgument arg)
        {
            var __arg0 = arg.__Instance;
            __Internal.DefaultNonEmptyCtorWithNullPtr_0((__Instance + __PointerAdjustment), __arg0);
        }

        public global::CSharp.Flags DefaultMappedToEnum(global::CSharp.Flags qFlags = global::CSharp.Flags.Flag3)
        {
            var __arg0 = new global::System.IntPtr(&qFlags);
            global::CSharp.Flags __ret;
            __Internal.DefaultMappedToEnum_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return __ret;
        }

        public void DefaultMappedToZeroEnum(global::CSharp.Flags qFlags = 0)
        {
            __Internal.DefaultMappedToZeroEnum_0((__Instance + __PointerAdjustment), qFlags);
        }

        public void DefaultMappedToEnumAssignedWithCtor(global::CSharp.Flags qFlags = 0)
        {
            __Internal.DefaultMappedToEnumAssignedWithCtor_0((__Instance + __PointerAdjustment), qFlags);
        }

        public void DefaultZeroMappedToEnumAssignedWithCtor(Flags defaultZeroMappedToEnum = 0)
        {
            __Internal.DefaultZeroMappedToEnumAssignedWithCtor_0((__Instance + __PointerAdjustment), defaultZeroMappedToEnum);
        }

        public void DefaultImplicitCtorInt(global::CSharp.Quux arg)
        {
            var __arg0 = ReferenceEquals(arg, null) ? new global::CSharp.Quux.__Internal() : *(global::CSharp.Quux.__Internal*) arg.__Instance;
            __Internal.DefaultImplicitCtorInt_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultImplicitCtorChar(global::CSharp.Quux arg)
        {
            var __arg0 = ReferenceEquals(arg, null) ? new global::CSharp.Quux.__Internal() : *(global::CSharp.Quux.__Internal*) arg.__Instance;
            __Internal.DefaultImplicitCtorChar_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultImplicitCtorFoo(global::CSharp.Quux arg)
        {
            var __arg0 = ReferenceEquals(arg, null) ? new global::CSharp.Quux.__Internal() : *(global::CSharp.Quux.__Internal*) arg.__Instance;
            __Internal.DefaultImplicitCtorFoo_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultImplicitCtorEnum(global::CSharp.Baz arg)
        {
            var __arg0 = ReferenceEquals(arg, null) ? new global::CSharp.Baz.__Internal() : *(global::CSharp.Baz.__Internal*) arg.__Instance;
            __Internal.DefaultImplicitCtorEnum_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultImplicitCtorEnumTwo(global::CSharp.IBar arg)
        {
            var __arg0 = ReferenceEquals(arg, null) ? new global::CSharp.Bar.__Internal() : *(global::CSharp.Bar.__Internal*) arg.__PointerToBar;
            __Internal.DefaultImplicitCtorEnumTwo_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultIntWithLongExpression(uint i = 2500)
        {
            __Internal.DefaultIntWithLongExpression_0((__Instance + __PointerAdjustment), i);
        }

        public void DefaultRefTypeEnumImplicitCtor(global::CSharp.QColor fillColor)
        {
            if (ReferenceEquals(fillColor, null))
                throw new global::System.ArgumentNullException("fillColor", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = fillColor.__Instance;
            __Internal.DefaultRefTypeEnumImplicitCtor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void Rotate4x4Matrix(float angle, float x, float y, float z = 0.0F)
        {
            __Internal.Rotate4x4Matrix_0((__Instance + __PointerAdjustment), angle, x, y, z);
        }

        public void DefaultPointerToValueType(global::CSharp.QGenericArgument pointer = new global::CSharp.QGenericArgument())
        {
            var ____arg0 = pointer.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.DefaultPointerToValueType_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultDoubleWithoutF(double d1 = 1.0, double d2 = 1.0)
        {
            __Internal.DefaultDoubleWithoutF_0((__Instance + __PointerAdjustment), d1, d2);
        }

        public void DefaultIntExpressionWithEnum(int i = (int) global::CSharp.Qt.GlobalColor.Black + 1)
        {
            __Internal.DefaultIntExpressionWithEnum_0((__Instance + __PointerAdjustment), i);
        }

        public void DefaultCtorWithMoreThanOneArg(global::CSharp.MethodsWithDefaultValues.QMargins m)
        {
            var __arg0 = ReferenceEquals(m, null) ? new global::CSharp.MethodsWithDefaultValues.QMargins.__Internal() : *(global::CSharp.MethodsWithDefaultValues.QMargins.__Internal*) m.__Instance;
            __Internal.DefaultCtorWithMoreThanOneArg_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultWithComplexArgs(global::CSharp.QRect rectangle)
        {
            var ____arg0 = rectangle.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            __Internal.DefaultWithComplexArgs_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultWithRefManagedLong(ref long i)
        {
            fixed (long* __refParamPtr0 = &i)
            {
                var __arg0 = __refParamPtr0;
                __Internal.DefaultWithRefManagedLong_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public void DefaultWithFunctionCall(int f)
        {
            __Internal.DefaultWithFunctionCall_0((__Instance + __PointerAdjustment), f);
        }

        public void DefaultWithPropertyCall(int f)
        {
            __Internal.DefaultWithPropertyCall_0((__Instance + __PointerAdjustment), f);
        }

        public void DefaultWithGetPropertyCall(int f)
        {
            __Internal.DefaultWithGetPropertyCall_0((__Instance + __PointerAdjustment), f);
        }

        public void DefaultWithIndirectStringConstant(global::CSharp.Foo arg)
        {
            if (ReferenceEquals(arg, null))
                throw new global::System.ArgumentNullException("arg", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = arg.__Instance;
            __Internal.DefaultWithIndirectStringConstant_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultWithDirectIntConstant(int arg)
        {
            __Internal.DefaultWithDirectIntConstant_0((__Instance + __PointerAdjustment), arg);
        }

        public void DefaultWithEnumInLowerCasedNameSpace(global::CSharp.LowerCaseNameSpace.Enum e = global::CSharp.LowerCaseNameSpace.Enum.Item2)
        {
            __Internal.DefaultWithEnumInLowerCasedNameSpace_0((__Instance + __PointerAdjustment), e);
        }

        public void DefaultWithCharFromInt(char c = (char) 32)
        {
            var __arg0 = global::System.Convert.ToSByte(c);
            __Internal.DefaultWithCharFromInt_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void DefaultWithFreeConstantInNameSpace(int c)
        {
            __Internal.DefaultWithFreeConstantInNameSpace_0((__Instance + __PointerAdjustment), c);
        }

        public int DefaultWithParamNamedSameAsMethod(int DefaultWithParamNamedSameAsMethod, global::CSharp.Foo defaultArg)
        {
            if (ReferenceEquals(defaultArg, null))
                throw new global::System.ArgumentNullException("defaultArg", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = defaultArg.__Instance;
            var __ret = __Internal.DefaultWithParamNamedSameAsMethod_0((__Instance + __PointerAdjustment), DefaultWithParamNamedSameAsMethod, __arg1);
            return __ret;
        }

        public static implicit operator global::CSharp.MethodsWithDefaultValues(global::CSharp.Foo foo)
        {
            return new global::CSharp.MethodsWithDefaultValues(foo);
        }

        public static implicit operator global::CSharp.MethodsWithDefaultValues(int a)
        {
            return new global::CSharp.MethodsWithDefaultValues(a);
        }

        public static implicit operator global::CSharp.MethodsWithDefaultValues(float a)
        {
            return new global::CSharp.MethodsWithDefaultValues(a);
        }

        public static implicit operator global::CSharp.MethodsWithDefaultValues(double d)
        {
            return new global::CSharp.MethodsWithDefaultValues(d);
        }

        public void DefaultValueType()
        {
            DefaultValueType(new global::CSharp.QGenericArgument(null));
        }

        public void DefaultRefTypeBeforeOthers()
        {
            DefaultRefTypeBeforeOthers(new global::CSharp.Foo(null), 5, global::CSharp.Bar.Items.Item2);
        }

        public void DefaultRefTypeAfterOthers(int i = 5, global::CSharp.Bar.Items item = global::CSharp.Bar.Items.Item2)
        {
            DefaultRefTypeAfterOthers(i, item, new global::CSharp.Foo(null));
        }

        public void DefaultRefTypeBeforeAndAfterOthers(int i = 5)
        {
            DefaultRefTypeBeforeAndAfterOthers(i, new global::CSharp.Foo(null), global::CSharp.Bar.Items.Item2, new global::CSharp.Baz());
        }

        public void DefaultRefTypeBeforeAndAfterOthers(int i, global::CSharp.Foo foo, global::CSharp.Bar.Items item = global::CSharp.Bar.Items.Item2)
        {
            DefaultRefTypeBeforeAndAfterOthers(i, foo, item, new global::CSharp.Baz());
        }

        public void defaultRefAssignedValue()
        {
            defaultRefAssignedValue(new global::CSharp.Foo(null));
        }

        public void DefaultRefAssignedValue()
        {
            DefaultRefAssignedValue(new global::CSharp.Foo(null));
        }

        public void DefaultNonEmptyCtor()
        {
            DefaultNonEmptyCtor(new global::CSharp.QGenericArgument());
        }

        public void DefaultNonEmptyCtorWithNullPtr()
        {
            DefaultNonEmptyCtorWithNullPtr(new global::CSharp.QGenericArgument());
        }

        public void DefaultImplicitCtorInt()
        {
            DefaultImplicitCtorInt(0);
        }

        public void DefaultImplicitCtorChar()
        {
            DefaultImplicitCtorChar('a');
        }

        public void DefaultImplicitCtorFoo()
        {
            DefaultImplicitCtorFoo(new global::CSharp.Quux(null));
        }

        public void DefaultImplicitCtorEnum()
        {
            DefaultImplicitCtorEnum(global::CSharp.Bar.Items.Item1);
        }

        public void DefaultImplicitCtorEnumTwo()
        {
            var param0 = (Bar) global::CSharp.Bar.Items.Item1;
            DefaultImplicitCtorEnumTwo(param0);
        }

        public void DefaultRefTypeEnumImplicitCtor()
        {
            DefaultRefTypeEnumImplicitCtor(global::CSharp.Qt.GlobalColor.White);
        }

        public void DefaultCtorWithMoreThanOneArg()
        {
            DefaultCtorWithMoreThanOneArg(new global::CSharp.MethodsWithDefaultValues.QMargins(0, 0, 0, 0));
        }

        public void DefaultWithComplexArgs()
        {
            DefaultWithComplexArgs(new global::CSharp.QRect(new global::CSharp.QPoint(0, 0), new global::CSharp.QSize(-1, -1)));
        }

        public void DefaultWithRefManagedLong()
        {
            long param0 = 0;
            DefaultWithRefManagedLong(ref param0);
        }

        public void DefaultWithFunctionCall()
        {
            DefaultWithFunctionCall((int) global::CSharp.Foo.MakeFunctionCall());
        }

        public void DefaultWithPropertyCall()
        {
            DefaultWithPropertyCall((int) global::CSharp.Foo.PropertyCall);
        }

        public void DefaultWithGetPropertyCall()
        {
            DefaultWithGetPropertyCall((int) global::CSharp.Foo.GetPropertyCall);
        }

        public void DefaultWithIndirectStringConstant()
        {
            DefaultWithIndirectStringConstant(global::CSharp.MethodsWithDefaultValues.StringConstant);
        }

        public void DefaultWithDirectIntConstant()
        {
            DefaultWithDirectIntConstant((int) global::CSharp.MethodsWithDefaultValues.IntConstant);
        }

        public void DefaultWithFreeConstantInNameSpace()
        {
            DefaultWithFreeConstantInNameSpace((int) global::CSharp.HasFreeConstant.AnotherUnit.FREE_CONSTANT_IN_NAMESPACE);
        }

        public int DefaultWithParamNamedSameAsMethod(int DefaultWithParamNamedSameAsMethod)
        {
            return this.DefaultWithParamNamedSameAsMethod(DefaultWithParamNamedSameAsMethod, new global::CSharp.Foo(null));
        }

        public static string StringConstant
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?stringConstant@MethodsWithDefaultValues@@2PBDB");
                return Marshal.PtrToStringAnsi(*__ptr);
            }

            set
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?stringConstant@MethodsWithDefaultValues@@2PBDB");
                *__ptr = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public static int IntConstant
        {
            get
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?intConstant@MethodsWithDefaultValues@@2HA");
                return *__ptr;
            }

            set
            {
                var __ptr = (int*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?intConstant@MethodsWithDefaultValues@@2HA");
                *__ptr = value;
            }
        }

        public int A
        {
            get
            {
                var __ret = __Internal.GetA_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class HasOverridesWithChangedAccessBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasOverridesWithChangedAccessBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithChangedAccessBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithChangedAccessBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasOverridesWithChangedAccessBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasOverridesWithChangedAccessBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasOverridesWithChangedAccessBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasOverridesWithChangedAccessBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasOverridesWithChangedAccessBase __CreateInstance(global::CSharp.HasOverridesWithChangedAccessBase.__Internal native, bool skipVTables = false)
        {
            return new HasOverridesWithChangedAccessBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasOverridesWithChangedAccessBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccessBase.__Internal));
            global::CSharp.HasOverridesWithChangedAccessBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasOverridesWithChangedAccessBase(global::CSharp.HasOverridesWithChangedAccessBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasOverridesWithChangedAccessBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasOverridesWithChangedAccessBase()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccessBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithChangedAccessBase");
        }

        public HasOverridesWithChangedAccessBase(global::CSharp.HasOverridesWithChangedAccessBase _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccessBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithChangedAccessBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasOverridesWithChangedAccessBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasOverridesWithChangedAccessBase.__Internal*) __Instance)->vfptr_HasOverridesWithChangedAccessBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void PrivateOverride(int i = 5)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___PrivateOverride_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
            ___PrivateOverride_0Delegate((__Instance + __PointerAdjustment), i);
        }

        protected virtual void PublicOverride()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___PublicOverride_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___PublicOverride_0Delegate((__Instance + __PointerAdjustment));
        }

        #region Virtual table interop

        // void privateOverride(int i = 5)
        private static global::CSharp.Delegates.Action_IntPtr_int _PrivateOverride_0DelegateInstance;

        private static void _PrivateOverride_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithChangedAccessBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PrivateOverride(i);
        }

        // void publicOverride()
        private static global::CSharp.Delegates.Action_IntPtr _PublicOverride_0DelegateInstance;

        private static void _PublicOverride_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithChangedAccessBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PublicOverride();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _PrivateOverride_0DelegateInstance += _PrivateOverride_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PrivateOverride_0DelegateInstance).ToPointer();
                _PublicOverride_0DelegateInstance += _PublicOverride_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PublicOverride_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasOverridesWithChangedAccess : global::CSharp.HasOverridesWithChangedAccessBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasOverridesWithChangedAccessBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithChangedAccess@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithChangedAccess@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.HasOverridesWithChangedAccess __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasOverridesWithChangedAccess(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasOverridesWithChangedAccess __CreateInstance(global::CSharp.HasOverridesWithChangedAccess.__Internal native, bool skipVTables = false)
        {
            return new HasOverridesWithChangedAccess(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasOverridesWithChangedAccess.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccess.__Internal));
            global::CSharp.HasOverridesWithChangedAccess.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasOverridesWithChangedAccess(global::CSharp.HasOverridesWithChangedAccess.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasOverridesWithChangedAccess(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasOverridesWithChangedAccess()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccess.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithChangedAccess");
        }

        public HasOverridesWithChangedAccess(global::CSharp.HasOverridesWithChangedAccess _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithChangedAccess.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithChangedAccess");
        }

        protected override void PublicOverride()
        {
            base.PublicOverride();
        }

        public override void PrivateOverride(int i = 5)
        {
            base.PrivateOverride(i);
        }

        #region Virtual table interop

        // void privateOverride(int i)
        private static global::CSharp.Delegates.Action_IntPtr_int _PrivateOverride_0DelegateInstance;

        private static void _PrivateOverride_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithChangedAccess) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PrivateOverride(i);
        }

        // void publicOverride()
        private static global::CSharp.Delegates.Action_IntPtr _PublicOverride_0DelegateInstance;

        private static void _PublicOverride_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithChangedAccess) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PublicOverride();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _PrivateOverride_0DelegateInstance += _PrivateOverride_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PrivateOverride_0DelegateInstance).ToPointer();
                _PublicOverride_0DelegateInstance += _PublicOverride_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PublicOverride_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasOverridesWithIncreasedAccess : global::CSharp.HasOverridesWithChangedAccess, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasOverridesWithChangedAccessBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithIncreasedAccess@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverridesWithIncreasedAccess@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.HasOverridesWithIncreasedAccess __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasOverridesWithIncreasedAccess(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasOverridesWithIncreasedAccess __CreateInstance(global::CSharp.HasOverridesWithIncreasedAccess.__Internal native, bool skipVTables = false)
        {
            return new HasOverridesWithIncreasedAccess(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasOverridesWithIncreasedAccess.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithIncreasedAccess.__Internal));
            global::CSharp.HasOverridesWithIncreasedAccess.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasOverridesWithIncreasedAccess(global::CSharp.HasOverridesWithIncreasedAccess.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasOverridesWithIncreasedAccess(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasOverridesWithIncreasedAccess()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithIncreasedAccess.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithIncreasedAccess");
        }

        public HasOverridesWithIncreasedAccess(global::CSharp.HasOverridesWithIncreasedAccess _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverridesWithIncreasedAccess.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasOverridesWithIncreasedAccess");
        }

        public override void PrivateOverride(int i = 5)
        {
            base.PrivateOverride(i);
        }

        #region Virtual table interop

        // void privateOverride(int i)
        private static global::CSharp.Delegates.Action_IntPtr_int _PrivateOverride_0DelegateInstance;

        private static void _PrivateOverride_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithIncreasedAccess) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PrivateOverride(i);
        }

        // void publicOverride()
        private static global::CSharp.Delegates.Action_IntPtr _PublicOverride_0DelegateInstance;

        private static void _PublicOverride_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverridesWithIncreasedAccess) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.PublicOverride();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _PrivateOverride_0DelegateInstance += _PrivateOverride_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PrivateOverride_0DelegateInstance).ToPointer();
                _PublicOverride_0DelegateInstance += _PublicOverride_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_PublicOverride_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class AbstractWithProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractWithProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractWithProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractWithProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractWithProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractWithProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.AbstractWithProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractWithPropertyInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.AbstractWithProperty __CreateInstance(global::CSharp.AbstractWithProperty.__Internal native, bool skipVTables = false)
        {
            return new AbstractWithPropertyInternal(native, skipVTables);
        }

        protected AbstractWithProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected AbstractWithProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractWithProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.AbstractWithProperty");
        }

        protected AbstractWithProperty(global::CSharp.AbstractWithProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractWithProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.AbstractWithProperty");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.AbstractWithProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.AbstractWithProperty.__Internal*) __Instance)->vfptr_AbstractWithProperty = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract int Property
        {
            get;
        }

        #region Virtual table interop

        // int property() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractWithProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class IgnoredTypeInheritingNonIgnoredWithNoEmptyCtor
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractProprietor;

            [FieldOffset(4)]
            public int m_value;

            [FieldOffset(8)]
            public int m_property;

            [FieldOffset(12)]
            public global::CSharp.Bar.Items _items;

            [FieldOffset(16)]
            public global::CSharp.Bar.Items _itemsByValue;

            [FieldOffset(20)]
            public global::CSharp.ComplexType.__Internal m_complexType;
        }
    }

    public unsafe partial class PropertyWithIgnoredType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CSharp.IgnoredType.__Internal _ignoredType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0PropertyWithIgnoredType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.PropertyWithIgnoredType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.PropertyWithIgnoredType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.PropertyWithIgnoredType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new PropertyWithIgnoredType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.PropertyWithIgnoredType __CreateInstance(global::CSharp.PropertyWithIgnoredType.__Internal native, bool skipVTables = false)
        {
            return new PropertyWithIgnoredType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.PropertyWithIgnoredType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.PropertyWithIgnoredType.__Internal));
            *(global::CSharp.PropertyWithIgnoredType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PropertyWithIgnoredType(global::CSharp.PropertyWithIgnoredType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PropertyWithIgnoredType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PropertyWithIgnoredType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.PropertyWithIgnoredType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PropertyWithIgnoredType(global::CSharp.PropertyWithIgnoredType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.PropertyWithIgnoredType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.PropertyWithIgnoredType.__Internal*) __Instance) = *((global::CSharp.PropertyWithIgnoredType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.PropertyWithIgnoredType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class MI_A0 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int F;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_A0@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_A0@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?get@MI_A0@@QAEHXZ")]
            internal static extern int Get_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MI_A0> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MI_A0>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MI_A0 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MI_A0(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MI_A0 __CreateInstance(global::CSharp.MI_A0.__Internal native, bool skipVTables = false)
        {
            return new MI_A0(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MI_A0.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A0.__Internal));
            *(global::CSharp.MI_A0.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MI_A0(global::CSharp.MI_A0.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MI_A0(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MI_A0()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public MI_A0(global::CSharp.MI_A0 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.MI_A0.__Internal*) __Instance) = *((global::CSharp.MI_A0.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.MI_A0 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Get()
        {
            var __ret = __Internal.Get_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public int F
        {
            get
            {
                return ((global::CSharp.MI_A0.__Internal*) __Instance)->F;
            }

            set
            {
                ((global::CSharp.MI_A0.__Internal*) __Instance)->F = value;
            }
        }
    }

    public unsafe partial class MI_A : global::CSharp.IMI_A, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MI_A;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_A@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_A@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMI_A> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMI_A>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MI_A __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MI_A(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MI_A __CreateInstance(global::CSharp.MI_A.__Internal native, bool skipVTables = false)
        {
            return new MI_A(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MI_A.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A.__Internal));
            global::CSharp.MI_A.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MI_A(global::CSharp.MI_A.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MI_A(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MI_A()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.MI_A");
        }

        public MI_A(global::CSharp.IMI_A _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_A.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToMI_A;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MI_A");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IMI_A __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.MI_A.__Internal*) __Instance)->vfptr_MI_A = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void V(int i = 5)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___V_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
            ___V_0Delegate((__Instance), i);
        }

        public global::System.IntPtr __PointerToMI_A
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void v(int i = 5)
        private static global::CSharp.Delegates.Action_IntPtr_int _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MI_A) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class MI_B : global::CSharp.MI_A, global::CSharp.IMI_B, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MI_A;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_B@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_B@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.MI_B __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MI_B(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MI_B __CreateInstance(global::CSharp.MI_B.__Internal native, bool skipVTables = false)
        {
            return new MI_B(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MI_B.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_B.__Internal));
            global::CSharp.MI_B.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MI_B(global::CSharp.MI_B.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MI_B(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MI_B()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_B.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.MI_B");
        }

        public MI_B(global::CSharp.IMI_B _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_B.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToMI_B;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MI_B");
        }

        public global::System.IntPtr __PointerToMI_B
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void v(int i = 5)
        private static global::CSharp.Delegates.Action_IntPtr_int _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MI_B) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class MI_C : global::CSharp.MI_A0, global::CSharp.IMI_B, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MI_A;

            [FieldOffset(4)]
            public int F;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_C@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MI_C@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.MI_C __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MI_C(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MI_C __CreateInstance(global::CSharp.MI_C.__Internal native, bool skipVTables = false)
        {
            return new MI_C(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MI_C.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_C.__Internal));
            global::CSharp.MI_C.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MI_C(global::CSharp.MI_C.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MI_C(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MI_C()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_C.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.MI_C");
        }

        public MI_C(global::CSharp.MI_C _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MI_C.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MI_C");
        }

        public virtual void V(int i = 5)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___V_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
            ___V_0Delegate((__Instance), i);
        }

        public global::System.IntPtr __PointerToMI_B
        {
            get
            {
                return __Instance + 0;
            }
        }

        public global::System.IntPtr __PointerToMI_A
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void v(int i = 5)
        private static global::CSharp.Delegates.Action_IntPtr_int _V_0DelegateInstance;

        private static void _V_0DelegateHook(global::System.IntPtr instance, int i)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MI_C) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.V(i);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _V_0DelegateInstance += _V_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_V_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial struct StructWithPrivateFields
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int protectedField;

            [FieldOffset(4)]
            public int simplePrivateField;

            [FieldOffset(8)]
            public global::CSharp.Foo.__Internal complexPrivateField;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0StructWithPrivateFields@@QAE@HVFoo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int simplePrivateField, global::CSharp.Foo.__Internal complexPrivateField);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0StructWithPrivateFields@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getSimplePrivateField@StructWithPrivateFields@@QAEHXZ")]
            internal static extern int GetSimplePrivateField_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getComplexPrivateField@StructWithPrivateFields@@QAE?AVFoo@@XZ")]
            internal static extern void GetComplexPrivateField_0(global::System.IntPtr instance, global::System.IntPtr @return);
        }

        private StructWithPrivateFields.__Internal __instance;
        internal StructWithPrivateFields.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.StructWithPrivateFields __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new StructWithPrivateFields(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.StructWithPrivateFields __CreateInstance(global::CSharp.StructWithPrivateFields.__Internal native, bool skipVTables = false)
        {
            return new StructWithPrivateFields(native, skipVTables);
        }

        private StructWithPrivateFields(global::CSharp.StructWithPrivateFields.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private StructWithPrivateFields(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.StructWithPrivateFields.__Internal*) native;
        }

        public StructWithPrivateFields(int simplePrivateField, global::CSharp.Foo complexPrivateField)
            : this()
        {
            var __arg1 = ReferenceEquals(complexPrivateField, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) complexPrivateField.__Instance;
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.ctor_0(new global::System.IntPtr(__instancePtr), simplePrivateField, __arg1);
            }
        }

        public StructWithPrivateFields(global::CSharp.StructWithPrivateFields _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public int SimplePrivateField
        {
            get
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    var __ret = __Internal.GetSimplePrivateField_0(new global::System.IntPtr(__instancePtr));
                    return __ret;
                }
            }
        }

        public global::CSharp.Foo ComplexPrivateField
        {
            get
            {
                var __ret = new global::CSharp.Foo.__Internal();
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.GetComplexPrivateField_0(new global::System.IntPtr(__instancePtr), new IntPtr(&__ret));
                    return global::CSharp.Foo.__CreateInstance(__ret);
                }
            }
        }
    }

    public unsafe partial class TestPointers : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr Names;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestPointers@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestDoubleCharPointers@TestPointers@@QAEXPAPBD@Z")]
            internal static extern void TestDoubleCharPointers_0(global::System.IntPtr instance, sbyte** names);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TestTripleCharPointers@TestPointers@@QAEXPAPAPBD@Z")]
            internal static extern void TestTripleCharPointers_0(global::System.IntPtr instance, sbyte*** names);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestPointers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestPointers>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestPointers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestPointers(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestPointers __CreateInstance(global::CSharp.TestPointers.__Internal native, bool skipVTables = false)
        {
            return new TestPointers(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestPointers.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestPointers.__Internal));
            *(global::CSharp.TestPointers.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestPointers(global::CSharp.TestPointers.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestPointers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestPointers()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestPointers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestPointers(global::CSharp.TestPointers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestPointers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestPointers.__Internal*) __Instance) = *((global::CSharp.TestPointers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestPointers __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void TestDoubleCharPointers(char** names)
        {
            var __arg0 = (sbyte**) names;
            __Internal.TestDoubleCharPointers_0((__Instance + __PointerAdjustment), __arg0);
        }

        public void TestTripleCharPointers(char*** names)
        {
            var __arg0 = (sbyte***) names;
            __Internal.TestTripleCharPointers_0((__Instance + __PointerAdjustment), __arg0);
        }

        public char** Names
        {
            get
            {
                return (char**) ((global::CSharp.TestPointers.__Internal*) __Instance)->Names;
            }

            set
            {
                ((global::CSharp.TestPointers.__Internal*) __Instance)->Names = (global::System.IntPtr) (sbyte**) value;
            }
        }
    }

    public unsafe partial class HasVirtualDtor1 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualDtor1;

            [FieldOffset(4)]
            public int testField;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualDtor1@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualDtor1@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualDtor1> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualDtor1>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasVirtualDtor1 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualDtor1(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasVirtualDtor1 __CreateInstance(global::CSharp.HasVirtualDtor1.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualDtor1(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasVirtualDtor1.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor1.__Internal));
            global::CSharp.HasVirtualDtor1.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualDtor1(global::CSharp.HasVirtualDtor1.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualDtor1(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public HasVirtualDtor1()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasVirtualDtor1");
        }

        public HasVirtualDtor1(global::CSharp.HasVirtualDtor1 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasVirtualDtor1");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasVirtualDtor1 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasVirtualDtor1.__Internal*) __Instance)->vfptr_HasVirtualDtor1 = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int TestField
        {
            get
            {
                return ((global::CSharp.HasVirtualDtor1.__Internal*) __Instance)->testField;
            }

            set
            {
                ((global::CSharp.HasVirtualDtor1.__Internal*) __Instance)->testField = value;
            }
        }

        #region Virtual table interop

        // virtual ~HasVirtualDtor1()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasVirtualDtor1) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class HasVirtualDtor2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualDtor2;

            [FieldOffset(4)]
            public global::System.IntPtr hasVirtualDtor1;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualDtor2@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualDtor2@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getHasVirtualDtor1@HasVirtualDtor2@@QAEPAVHasVirtualDtor1@@XZ")]
            internal static extern global::System.IntPtr GetHasVirtualDtor1_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualDtor2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualDtor2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasVirtualDtor2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualDtor2(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasVirtualDtor2 __CreateInstance(global::CSharp.HasVirtualDtor2.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualDtor2(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasVirtualDtor2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor2.__Internal));
            global::CSharp.HasVirtualDtor2.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualDtor2(global::CSharp.HasVirtualDtor2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualDtor2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public HasVirtualDtor2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasVirtualDtor2");
        }

        public HasVirtualDtor2(global::CSharp.HasVirtualDtor2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualDtor2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasVirtualDtor2");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasVirtualDtor2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasVirtualDtor2.__Internal*) __Instance)->vfptr_HasVirtualDtor2 = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void VirtualFunction(global::CSharp.HasVirtualDtor1 param1, global::CSharp.HasVirtualDtor1 param2)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___VirtualFunction_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr));
            if (ReferenceEquals(param1, null))
                throw new global::System.ArgumentNullException("param1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = param1.__Instance;
            if (ReferenceEquals(param2, null))
                throw new global::System.ArgumentNullException("param2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = param2.__Instance;
            ___VirtualFunction_0Delegate((__Instance + __PointerAdjustment), __arg0, __arg1);
        }

        public global::CSharp.HasVirtualDtor1 HasVirtualDtor1
        {
            get
            {
                var __ret = __Internal.GetHasVirtualDtor1_0((__Instance + __PointerAdjustment));
                global::CSharp.HasVirtualDtor1 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.HasVirtualDtor1.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.NativeToManagedMap[__ret];
                else global::CSharp.HasVirtualDtor1.NativeToManagedMap[__ret] = __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~HasVirtualDtor2()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasVirtualDtor2) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void virtualFunction(const HasVirtualDtor1& param1, const HasVirtualDtor1& param2)
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr_IntPtr _VirtualFunction_0DelegateInstance;

        private static void _VirtualFunction_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr param1, global::System.IntPtr param2)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasVirtualDtor2) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.HasVirtualDtor1 __result0;
            if (param1 == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.HasVirtualDtor1.NativeToManagedMap.ContainsKey(param1))
                __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.NativeToManagedMap[param1];
            else __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.__CreateInstance(param1, skipVTables: true);
            global::CSharp.HasVirtualDtor1 __result1;
            if (param2 == IntPtr.Zero) __result1 = null;
            else if (global::CSharp.HasVirtualDtor1.NativeToManagedMap.ContainsKey(param2))
                __result1 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.NativeToManagedMap[param2];
            else __result1 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.__CreateInstance(param2, skipVTables: true);
            __target.VirtualFunction(__result0, __result1);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _VirtualFunction_0DelegateInstance += _VirtualFunction_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_VirtualFunction_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class TestNativeToManagedMap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_TestNativeToManagedMap;

            [FieldOffset(4)]
            public global::System.IntPtr hasVirtualDtor2;

            [FieldOffset(8)]
            public global::System.IntPtr bar;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestNativeToManagedMap@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestNativeToManagedMap@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?propertyWithNoVirtualDtor@TestNativeToManagedMap@@QBEPAVBar@@XZ")]
            internal static extern global::System.IntPtr PropertyWithNoVirtualDtor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setPropertyWithNoVirtualDtor@TestNativeToManagedMap@@QAEXPAVBar@@@Z")]
            internal static extern void SetPropertyWithNoVirtualDtor_0(global::System.IntPtr instance, global::System.IntPtr bar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getHasVirtualDtor2@TestNativeToManagedMap@@QAEPAVHasVirtualDtor2@@XZ")]
            internal static extern global::System.IntPtr GetHasVirtualDtor2_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestNativeToManagedMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestNativeToManagedMap>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestNativeToManagedMap __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestNativeToManagedMap(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestNativeToManagedMap __CreateInstance(global::CSharp.TestNativeToManagedMap.__Internal native, bool skipVTables = false)
        {
            return new TestNativeToManagedMap(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestNativeToManagedMap.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestNativeToManagedMap.__Internal));
            global::CSharp.TestNativeToManagedMap.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private TestNativeToManagedMap(global::CSharp.TestNativeToManagedMap.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestNativeToManagedMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public TestNativeToManagedMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestNativeToManagedMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.TestNativeToManagedMap");
        }

        public TestNativeToManagedMap(global::CSharp.TestNativeToManagedMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestNativeToManagedMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.TestNativeToManagedMap");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestNativeToManagedMap __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.TestNativeToManagedMap.__Internal*) __Instance)->vfptr_TestNativeToManagedMap = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::CSharp.IBar PropertyWithNoVirtualDtor
        {
            get
            {
                var __ret = __Internal.PropertyWithNoVirtualDtor_0((__Instance + __PointerAdjustment));
                global::CSharp.IBar __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Bar.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.IBar) global::CSharp.Bar.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Bar.__CreateInstance(__ret);
                return __result0;
            }

            set
            {
                var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__PointerToBar;
                __Internal.SetPropertyWithNoVirtualDtor_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public global::CSharp.HasVirtualDtor2 HasVirtualDtor2
        {
            get
            {
                var __ret = __Internal.GetHasVirtualDtor2_0((__Instance + __PointerAdjustment));
                global::CSharp.HasVirtualDtor2 __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.HasVirtualDtor2.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.HasVirtualDtor2) global::CSharp.HasVirtualDtor2.NativeToManagedMap[__ret];
                else global::CSharp.HasVirtualDtor2.NativeToManagedMap[__ret] = __result0 = (global::CSharp.HasVirtualDtor2) global::CSharp.HasVirtualDtor2.__CreateInstance(__ret);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~TestNativeToManagedMap()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.TestNativeToManagedMap) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class CallDtorVirtually : global::CSharp.HasVirtualDtor1, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualDtor1;

            [FieldOffset(4)]
            public int testField;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0CallDtorVirtually@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0CallDtorVirtually@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?getHasVirtualDtor1@CallDtorVirtually@@SAPAVHasVirtualDtor1@@PAV2@@Z")]
            internal static extern global::System.IntPtr GetHasVirtualDtor1_0(global::System.IntPtr returned);
        }

        internal static new global::CSharp.CallDtorVirtually __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new CallDtorVirtually(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.CallDtorVirtually __CreateInstance(global::CSharp.CallDtorVirtually.__Internal native, bool skipVTables = false)
        {
            return new CallDtorVirtually(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.CallDtorVirtually.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.CallDtorVirtually.__Internal));
            global::CSharp.CallDtorVirtually.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private CallDtorVirtually(global::CSharp.CallDtorVirtually.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected CallDtorVirtually(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public CallDtorVirtually()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.CallDtorVirtually.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.CallDtorVirtually");
        }

        public CallDtorVirtually(global::CSharp.CallDtorVirtually _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.CallDtorVirtually.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.CallDtorVirtually");
        }

        public static global::CSharp.HasVirtualDtor1 GetHasVirtualDtor1(global::CSharp.HasVirtualDtor1 returned)
        {
            var __arg0 = ReferenceEquals(returned, null) ? global::System.IntPtr.Zero : returned.__Instance;
            var __ret = __Internal.GetHasVirtualDtor1_0(__arg0);
            global::CSharp.HasVirtualDtor1 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.HasVirtualDtor1.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.NativeToManagedMap[__ret];
            else global::CSharp.HasVirtualDtor1.NativeToManagedMap[__ret] = __result0 = (global::CSharp.HasVirtualDtor1) global::CSharp.HasVirtualDtor1.__CreateInstance(__ret);
            return __result0;
        }

        public static bool Destroyed
        {
            get
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?Destroyed@CallDtorVirtually@@2_NA");
                return *__ptr;
            }

            set
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?Destroyed@CallDtorVirtually@@2_NA");
                *__ptr = value;
            }
        }

        #region Virtual table interop

        // ~CallDtorVirtually()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.CallDtorVirtually) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class HasProtectedNestedAnonymousType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CSharp.HasProtectedNestedAnonymousType._.__Internal u;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProtectedNestedAnonymousType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        protected internal unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                public int i;

                [FieldOffset(0)]
                public double d;
            }
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasProtectedNestedAnonymousType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasProtectedNestedAnonymousType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasProtectedNestedAnonymousType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasProtectedNestedAnonymousType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasProtectedNestedAnonymousType __CreateInstance(global::CSharp.HasProtectedNestedAnonymousType.__Internal native, bool skipVTables = false)
        {
            return new HasProtectedNestedAnonymousType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasProtectedNestedAnonymousType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedNestedAnonymousType.__Internal));
            *(global::CSharp.HasProtectedNestedAnonymousType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasProtectedNestedAnonymousType(global::CSharp.HasProtectedNestedAnonymousType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasProtectedNestedAnonymousType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasProtectedNestedAnonymousType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedNestedAnonymousType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HasProtectedNestedAnonymousType(global::CSharp.HasProtectedNestedAnonymousType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedNestedAnonymousType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.HasProtectedNestedAnonymousType.__Internal*) __Instance) = *((global::CSharp.HasProtectedNestedAnonymousType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasProtectedNestedAnonymousType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class SecondaryBase : global::CSharp.ISecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_SecondaryBase;

            [FieldOffset(4)]
            public global::System.IntPtr hasPointerToEnum;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?function@SecondaryBase@@QAEXPA_N@Z")]
            internal static extern void function_0(global::System.IntPtr instance, bool* ok);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?protectedFunction@SecondaryBase@@IAEXXZ")]
            internal static extern void ProtectedFunction_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?property@SecondaryBase@@QAEHXZ")]
            internal static extern int property_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setProperty@SecondaryBase@@QAEXH@Z")]
            internal static extern void SetProperty_0(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?protectedProperty@SecondaryBase@@IAEHXZ")]
            internal static extern int ProtectedProperty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setProtectedProperty@SecondaryBase@@IAEXH@Z")]
            internal static extern void SetProtectedProperty_0(global::System.IntPtr instance, int value);
        }

        public enum Property
        {
            P1 = 0,
            P2 = 1
        }

        public enum Function
        {
            M1 = 0,
            M2 = 1
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ISecondaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ISecondaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.SecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.SecondaryBase __CreateInstance(global::CSharp.SecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new SecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.SecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBase.__Internal));
            global::CSharp.SecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private SecondaryBase(global::CSharp.SecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SecondaryBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public SecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.SecondaryBase");
        }

        public SecondaryBase(global::CSharp.ISecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToSecondaryBase;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.SecondaryBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ISecondaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.SecondaryBase.__Internal*) __Instance)->vfptr_SecondaryBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void VirtualMember()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___VirtualMember_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___VirtualMember_0Delegate((__Instance));
        }

        public void function(ref bool ok)
        {
            fixed (bool* __refParamPtr0 = &ok)
            {
                var __arg0 = __refParamPtr0;
                __Internal.function_0((__Instance), __arg0);
            }
        }

        protected void ProtectedFunction()
        {
            __Internal.ProtectedFunction_0((__Instance));
        }

        public void function()
        {
            bool param0 = false;
            function(ref param0);
        }

        public global::System.IntPtr __PointerToSecondaryBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int property
        {
            get
            {
                var __ret = __Internal.property_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetProperty_0((__Instance), value);
            }
        }

        protected int ProtectedProperty
        {
            get
            {
                var __ret = __Internal.ProtectedProperty_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetProtectedProperty_0((__Instance), value);
            }
        }

        #region Virtual table interop

        // void VirtualMember()
        private static global::CSharp.Delegates.Action_IntPtr _VirtualMember_0DelegateInstance;

        private static void _VirtualMember_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.SecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.VirtualMember();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _VirtualMember_0DelegateInstance += _VirtualMember_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_VirtualMember_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TestOverrideFromSecondaryBase : global::CSharp.Foo, global::CSharp.ISecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_SecondaryBase;

            [FieldOffset(4)]
            public global::System.IntPtr hasPointerToEnum;

            [FieldOffset(8)]
            public int A;

            [FieldOffset(12)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(16)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(20)]
            public int P;

            [FieldOffset(24)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestOverrideFromSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestOverrideFromSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?function@SecondaryBase@@QAEXPA_N@Z")]
            internal static extern void function_0(global::System.IntPtr instance, bool* ok);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?protectedFunction@SecondaryBase@@IAEXXZ")]
            internal static extern void ProtectedFunction_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?property@SecondaryBase@@QAEHXZ")]
            internal static extern int property_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setProperty@TestOverrideFromSecondaryBase@@QAEXH@Z")]
            internal static extern void SetProperty_0(global::System.IntPtr instance, int value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?protectedProperty@SecondaryBase@@IAEHXZ")]
            internal static extern int ProtectedProperty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setProtectedProperty@SecondaryBase@@IAEXH@Z")]
            internal static extern void SetProtectedProperty_0(global::System.IntPtr instance, int value);
        }

        internal static new global::CSharp.TestOverrideFromSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestOverrideFromSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestOverrideFromSecondaryBase __CreateInstance(global::CSharp.TestOverrideFromSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new TestOverrideFromSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestOverrideFromSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOverrideFromSecondaryBase.__Internal));
            global::CSharp.TestOverrideFromSecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private TestOverrideFromSecondaryBase(global::CSharp.TestOverrideFromSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestOverrideFromSecondaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 8;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public TestOverrideFromSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOverrideFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 8));
            SetupVTables(GetType().FullName == "CSharp.TestOverrideFromSecondaryBase");
        }

        public TestOverrideFromSecondaryBase(global::CSharp.TestOverrideFromSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOverrideFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 8), __arg0);
            SetupVTables(GetType().FullName == "CSharp.TestOverrideFromSecondaryBase");
        }

        public virtual void VirtualMember()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___VirtualMember_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___VirtualMember_0Delegate((__Instance));
        }

        public void function(ref bool ok)
        {
            fixed (bool* __refParamPtr0 = &ok)
            {
                var __arg0 = __refParamPtr0;
                __Internal.function_0((__Instance), __arg0);
            }
        }

        protected void ProtectedFunction()
        {
            __Internal.ProtectedFunction_0((__Instance));
        }

        public void function()
        {
            bool param0 = false;
            function(ref param0);
        }

        public global::System.IntPtr __PointerToSecondaryBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int property
        {
            get
            {
                var __ret = __Internal.property_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetProperty_0((__Instance), value);
            }
        }

        protected int ProtectedProperty
        {
            get
            {
                var __ret = __Internal.ProtectedProperty_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetProtectedProperty_0((__Instance), value);
            }
        }

        #region Virtual table interop

        // void VirtualMember()
        private static global::CSharp.Delegates.Action_IntPtr _VirtualMember_0DelegateInstance;

        private static void _VirtualMember_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.TestOverrideFromSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.VirtualMember();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _VirtualMember_0DelegateInstance += _VirtualMember_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_VirtualMember_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TestParamToInterfacePassBaseOne : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePassBaseOne@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestParamToInterfacePassBaseOne> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestParamToInterfacePassBaseOne>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestParamToInterfacePassBaseOne __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestParamToInterfacePassBaseOne(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestParamToInterfacePassBaseOne __CreateInstance(global::CSharp.TestParamToInterfacePassBaseOne.__Internal native, bool skipVTables = false)
        {
            return new TestParamToInterfacePassBaseOne(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestParamToInterfacePassBaseOne.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseOne.__Internal));
            *(global::CSharp.TestParamToInterfacePassBaseOne.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestParamToInterfacePassBaseOne(global::CSharp.TestParamToInterfacePassBaseOne.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestParamToInterfacePassBaseOne(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestParamToInterfacePassBaseOne()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseOne.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestParamToInterfacePassBaseOne(global::CSharp.TestParamToInterfacePassBaseOne _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseOne.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestParamToInterfacePassBaseOne.__Internal*) __Instance) = *((global::CSharp.TestParamToInterfacePassBaseOne.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestParamToInterfacePassBaseOne __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class TestParamToInterfacePassBaseTwo : global::CSharp.ITestParamToInterfacePassBaseTwo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int m;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePassBaseTwo@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePassBaseTwo@@QAE@H@Z")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePassBaseTwo@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??ETestParamToInterfacePassBaseTwo@@QAEABV0@XZ")]
            internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getM@TestParamToInterfacePassBaseTwo@@QAEHXZ")]
            internal static extern int M_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setM@TestParamToInterfacePassBaseTwo@@QAEXH@Z")]
            internal static extern void SetM_0(global::System.IntPtr instance, int n);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ITestParamToInterfacePassBaseTwo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ITestParamToInterfacePassBaseTwo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestParamToInterfacePassBaseTwo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestParamToInterfacePassBaseTwo(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestParamToInterfacePassBaseTwo __CreateInstance(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal native, bool skipVTables = false)
        {
            return new TestParamToInterfacePassBaseTwo(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal));
            *(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestParamToInterfacePassBaseTwo(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestParamToInterfacePassBaseTwo(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestParamToInterfacePassBaseTwo()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
        }

        public TestParamToInterfacePassBaseTwo(int n)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance), n);
        }

        public TestParamToInterfacePassBaseTwo(global::CSharp.ITestParamToInterfacePassBaseTwo _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) __Instance) = *((global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ITestParamToInterfacePassBaseTwo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static global::CSharp.TestParamToInterfacePassBaseTwo operator ++(global::CSharp.TestParamToInterfacePassBaseTwo __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorPlusPlus_0(__arg0);
            global::CSharp.TestParamToInterfacePassBaseTwo __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.TestParamToInterfacePassBaseTwo.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.TestParamToInterfacePassBaseTwo) global::CSharp.TestParamToInterfacePassBaseTwo.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.TestParamToInterfacePassBaseTwo.__CreateInstance(__ret);
            return __result0;
        }

        public static implicit operator global::CSharp.TestParamToInterfacePassBaseTwo(int n)
        {
            return new global::CSharp.TestParamToInterfacePassBaseTwo(n);
        }

        public global::System.IntPtr __PointerToTestParamToInterfacePassBaseTwo
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int M
        {
            get
            {
                var __ret = __Internal.M_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetM_0((__Instance), value);
            }
        }
    }

    public unsafe partial class TestParamToInterfacePass : global::CSharp.TestParamToInterfacePassBaseOne, global::CSharp.ITestParamToInterfacePassBaseTwo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public int m;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePass@@QAE@VTestParamToInterfacePassBaseTwo@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::CSharp.TestParamToInterfacePassBaseTwo.__Internal b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePass@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestParamToInterfacePass@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?addM@TestParamToInterfacePass@@QAE?AVTestParamToInterfacePassBaseTwo@@V2@@Z")]
            internal static extern void AddM_0(global::System.IntPtr instance, global::System.IntPtr @return, global::CSharp.TestParamToInterfacePassBaseTwo.__Internal b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??HTestParamToInterfacePass@@QAE?AVTestParamToInterfacePassBaseTwo@@V1@@Z")]
            internal static extern void OperatorPlus_0(global::System.IntPtr instance, global::System.IntPtr @return, global::CSharp.TestParamToInterfacePassBaseTwo.__Internal b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getM@TestParamToInterfacePassBaseTwo@@QAEHXZ")]
            internal static extern int M_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setM@TestParamToInterfacePassBaseTwo@@QAEXH@Z")]
            internal static extern void SetM_0(global::System.IntPtr instance, int n);
        }

        internal static new global::CSharp.TestParamToInterfacePass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestParamToInterfacePass(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestParamToInterfacePass __CreateInstance(global::CSharp.TestParamToInterfacePass.__Internal native, bool skipVTables = false)
        {
            return new TestParamToInterfacePass(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestParamToInterfacePass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePass.__Internal));
            *(global::CSharp.TestParamToInterfacePass.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestParamToInterfacePass(global::CSharp.TestParamToInterfacePass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestParamToInterfacePass(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestParamToInterfacePass(global::CSharp.ITestParamToInterfacePassBaseTwo b)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = ReferenceEquals(b, null) ? new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal() : *(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) b.__PointerToTestParamToInterfacePassBaseTwo;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public TestParamToInterfacePass()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1((__Instance + __PointerAdjustment));
        }

        public TestParamToInterfacePass(global::CSharp.TestParamToInterfacePass _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestParamToInterfacePass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestParamToInterfacePass.__Internal*) __Instance) = *((global::CSharp.TestParamToInterfacePass.__Internal*) _0.__Instance);
        }

        public global::CSharp.ITestParamToInterfacePassBaseTwo AddM(global::CSharp.ITestParamToInterfacePassBaseTwo b)
        {
            var __arg0 = ReferenceEquals(b, null) ? new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal() : *(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) b.__PointerToTestParamToInterfacePassBaseTwo;
            var __ret = new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal();
            __Internal.AddM_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), __arg0);
            return global::CSharp.TestParamToInterfacePassBaseTwo.__CreateInstance(__ret);
        }

        public static global::CSharp.ITestParamToInterfacePassBaseTwo operator +(global::CSharp.TestParamToInterfacePass __op, global::CSharp.ITestParamToInterfacePassBaseTwo b)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __arg1 = ReferenceEquals(b, null) ? new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal() : *(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) b.__PointerToTestParamToInterfacePassBaseTwo;
            var __ret = new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal();
            __Internal.OperatorPlus_0(__arg0, new IntPtr(&__ret), __arg1);
            return global::CSharp.TestParamToInterfacePassBaseTwo.__CreateInstance(__ret);
        }

        public static implicit operator global::CSharp.TestParamToInterfacePass(global::CSharp.TestParamToInterfacePassBaseTwo b)
        {
            return new global::CSharp.TestParamToInterfacePass((ITestParamToInterfacePassBaseTwo) b);
        }

        public global::System.IntPtr __PointerToTestParamToInterfacePassBaseTwo
        {
            get
            {
                return __Instance + 0;
            }
        }

        public int M
        {
            get
            {
                var __ret = __Internal.M_0((__Instance));
                return __ret;
            }

            set
            {
                __Internal.SetM_0((__Instance), value);
            }
        }
    }

    public unsafe partial class HasProtectedVirtual : global::CSharp.IHasProtectedVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasProtectedVirtual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProtectedVirtual@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasProtectedVirtual@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IHasProtectedVirtual> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IHasProtectedVirtual>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasProtectedVirtual __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasProtectedVirtual(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasProtectedVirtual __CreateInstance(global::CSharp.HasProtectedVirtual.__Internal native, bool skipVTables = false)
        {
            return new HasProtectedVirtual(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasProtectedVirtual.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedVirtual.__Internal));
            global::CSharp.HasProtectedVirtual.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasProtectedVirtual(global::CSharp.HasProtectedVirtual.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasProtectedVirtual(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasProtectedVirtual()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.HasProtectedVirtual");
        }

        public HasProtectedVirtual(global::CSharp.IHasProtectedVirtual _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasProtectedVirtual.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToHasProtectedVirtual;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasProtectedVirtual");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IHasProtectedVirtual __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasProtectedVirtual.__Internal*) __Instance)->vfptr_HasProtectedVirtual = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        protected virtual void ProtectedVirtual()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___ProtectedVirtual_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ProtectedVirtual_0Delegate((__Instance));
        }

        public global::System.IntPtr __PointerToHasProtectedVirtual
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void protectedVirtual()
        private static global::CSharp.Delegates.Action_IntPtr _ProtectedVirtual_0DelegateInstance;

        private static void _ProtectedVirtual_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasProtectedVirtual) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ProtectedVirtual();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ProtectedVirtual_0DelegateInstance += _ProtectedVirtual_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ProtectedVirtual_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class InheritanceBuffer : global::CSharp.Foo, global::CSharp.IHasProtectedVirtual, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasProtectedVirtual;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritanceBuffer@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritanceBuffer@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.InheritanceBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new InheritanceBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.InheritanceBuffer __CreateInstance(global::CSharp.InheritanceBuffer.__Internal native, bool skipVTables = false)
        {
            return new InheritanceBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.InheritanceBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritanceBuffer.__Internal));
            global::CSharp.InheritanceBuffer.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private InheritanceBuffer(global::CSharp.InheritanceBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InheritanceBuffer(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public InheritanceBuffer()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritanceBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.InheritanceBuffer");
        }

        public InheritanceBuffer(global::CSharp.InheritanceBuffer _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritanceBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.InheritanceBuffer");
        }

        protected virtual void ProtectedVirtual()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___ProtectedVirtual_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ProtectedVirtual_0Delegate((__Instance));
        }

        public global::System.IntPtr __PointerToHasProtectedVirtual
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void protectedVirtual()
        private static global::CSharp.Delegates.Action_IntPtr _ProtectedVirtual_0DelegateInstance;

        private static void _ProtectedVirtual_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.InheritanceBuffer) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ProtectedVirtual();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ProtectedVirtual_0DelegateInstance += _ProtectedVirtual_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ProtectedVirtual_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class InheritsProtectedVirtualFromSecondaryBase : global::CSharp.InheritanceBuffer, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasProtectedVirtual;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritsProtectedVirtualFromSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritsProtectedVirtualFromSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.InheritsProtectedVirtualFromSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new InheritsProtectedVirtualFromSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.InheritsProtectedVirtualFromSecondaryBase __CreateInstance(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new InheritsProtectedVirtualFromSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal));
            global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private InheritsProtectedVirtualFromSecondaryBase(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected InheritsProtectedVirtualFromSecondaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public InheritsProtectedVirtualFromSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.InheritsProtectedVirtualFromSecondaryBase");
        }

        public InheritsProtectedVirtualFromSecondaryBase(global::CSharp.InheritsProtectedVirtualFromSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsProtectedVirtualFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.InheritsProtectedVirtualFromSecondaryBase");
        }

        protected override void ProtectedVirtual()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___ProtectedVirtual_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ProtectedVirtual_0Delegate((__Instance + __PointerAdjustment));
        }

        #region Virtual table interop

        // void protectedVirtual()
        private static global::CSharp.Delegates.Action_IntPtr _ProtectedVirtual_0DelegateInstance;

        private static void _ProtectedVirtual_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.InheritsProtectedVirtualFromSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ProtectedVirtual();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ProtectedVirtual_0DelegateInstance += _ProtectedVirtual_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ProtectedVirtual_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TypeMappedWithOperator : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TypeMappedWithOperator@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TypeMappedWithOperator@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??UTypeMappedWithOperator@@QAEHH@Z")]
            internal static extern int OperatorPipe_0(global::System.IntPtr instance, int i);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TypeMappedWithOperator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TypeMappedWithOperator>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TypeMappedWithOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TypeMappedWithOperator(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TypeMappedWithOperator __CreateInstance(global::CSharp.TypeMappedWithOperator.__Internal native, bool skipVTables = false)
        {
            return new TypeMappedWithOperator(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TypeMappedWithOperator.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TypeMappedWithOperator.__Internal));
            *(global::CSharp.TypeMappedWithOperator.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TypeMappedWithOperator(global::CSharp.TypeMappedWithOperator.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TypeMappedWithOperator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TypeMappedWithOperator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TypeMappedWithOperator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TypeMappedWithOperator(global::CSharp.TypeMappedWithOperator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TypeMappedWithOperator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TypeMappedWithOperator.__Internal*) __Instance) = *((global::CSharp.TypeMappedWithOperator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TypeMappedWithOperator __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static int operator |(global::CSharp.TypeMappedWithOperator __op, int i)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorPipe_0(__arg0, i);
            return __ret;
        }
    }

    public unsafe partial class HasPropertyWithDerivedType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasPropertyWithDerivedType;

            [FieldOffset(4)]
            public global::System.IntPtr hasPropertyWithDerivedTypeSubclass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPropertyWithDerivedType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPropertyWithDerivedType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasPropertyWithDerivedType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasPropertyWithDerivedType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasPropertyWithDerivedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasPropertyWithDerivedType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasPropertyWithDerivedType __CreateInstance(global::CSharp.HasPropertyWithDerivedType.__Internal native, bool skipVTables = false)
        {
            return new HasPropertyWithDerivedType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasPropertyWithDerivedType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPropertyWithDerivedType.__Internal));
            global::CSharp.HasPropertyWithDerivedType.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasPropertyWithDerivedType(global::CSharp.HasPropertyWithDerivedType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasPropertyWithDerivedType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasPropertyWithDerivedType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPropertyWithDerivedType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasPropertyWithDerivedType");
        }

        public HasPropertyWithDerivedType(global::CSharp.HasPropertyWithDerivedType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPropertyWithDerivedType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasPropertyWithDerivedType");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasPropertyWithDerivedType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->vfptr_HasPropertyWithDerivedType = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void CauseRenamingError()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___CauseRenamingError_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___CauseRenamingError_0Delegate((__Instance + __PointerAdjustment));
        }

        public global::CSharp.HasOverrideOfHasPropertyWithDerivedType HasPropertyWithDerivedTypeSubclass
        {
            get
            {
                global::CSharp.HasOverrideOfHasPropertyWithDerivedType __result0;
                if (((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->hasPropertyWithDerivedTypeSubclass == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.HasOverrideOfHasPropertyWithDerivedType.NativeToManagedMap.ContainsKey(((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->hasPropertyWithDerivedTypeSubclass))
                    __result0 = (global::CSharp.HasOverrideOfHasPropertyWithDerivedType) global::CSharp.HasOverrideOfHasPropertyWithDerivedType.NativeToManagedMap[((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->hasPropertyWithDerivedTypeSubclass];
                else __result0 = global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__CreateInstance(((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->hasPropertyWithDerivedTypeSubclass);
                return __result0;
            }

            set
            {
                ((global::CSharp.HasPropertyWithDerivedType.__Internal*) __Instance)->hasPropertyWithDerivedTypeSubclass = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        #region Virtual table interop

        // void causeRenamingError()
        private static global::CSharp.Delegates.Action_IntPtr _CauseRenamingError_0DelegateInstance;

        private static void _CauseRenamingError_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasPropertyWithDerivedType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.CauseRenamingError();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CauseRenamingError_0DelegateInstance += _CauseRenamingError_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CauseRenamingError_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasOverrideOfHasPropertyWithDerivedType : global::CSharp.HasPropertyWithDerivedType, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasPropertyWithDerivedType;

            [FieldOffset(4)]
            public global::System.IntPtr hasPropertyWithDerivedTypeSubclass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverrideOfHasPropertyWithDerivedType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasOverrideOfHasPropertyWithDerivedType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.HasOverrideOfHasPropertyWithDerivedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasOverrideOfHasPropertyWithDerivedType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasOverrideOfHasPropertyWithDerivedType __CreateInstance(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal native, bool skipVTables = false)
        {
            return new HasOverrideOfHasPropertyWithDerivedType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal));
            global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasOverrideOfHasPropertyWithDerivedType(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasOverrideOfHasPropertyWithDerivedType(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasOverrideOfHasPropertyWithDerivedType()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasOverrideOfHasPropertyWithDerivedType");
        }

        public HasOverrideOfHasPropertyWithDerivedType(global::CSharp.HasOverrideOfHasPropertyWithDerivedType _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasOverrideOfHasPropertyWithDerivedType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasOverrideOfHasPropertyWithDerivedType");
        }

        public override void CauseRenamingError()
        {
            base.CauseRenamingError();
        }

        #region Virtual table interop

        // void causeRenamingError()
        private static global::CSharp.Delegates.Action_IntPtr _CauseRenamingError_0DelegateInstance;

        private static void _CauseRenamingError_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasOverrideOfHasPropertyWithDerivedType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.CauseRenamingError();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _CauseRenamingError_0DelegateInstance += _CauseRenamingError_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_CauseRenamingError_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class MultiOverloadPtrToRef : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MultiOverloadPtrToRef;

            [FieldOffset(4)]
            public global::System.IntPtr arr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultiOverloadPtrToRef@@QAE@PAH@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, int* param);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultiOverloadPtrToRef@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?funcPrimitivePtrToRef@MultiOverloadPtrToRef@@QAEXPAHPADPAMPA_N@Z")]
            internal static extern void FuncPrimitivePtrToRef_0(global::System.IntPtr instance, int* pOne, sbyte* pTwo, float* pThree, bool* pFour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?funcPrimitivePtrToRefWithDefVal@MultiOverloadPtrToRef@@QAEXPAHPADPAVFoo@@0@Z")]
            internal static extern void FuncPrimitivePtrToRefWithDefVal_0(global::System.IntPtr instance, int* pOne, sbyte* pTwo, global::System.IntPtr pThree, int* pFour);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?ReturnPrimTypePtr@MultiOverloadPtrToRef@@QAEPAHXZ")]
            internal static extern int* ReturnPrimTypePtr_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?TakePrimTypePtr@MultiOverloadPtrToRef@@QAEXPAH@Z")]
            internal static extern void TakePrimTypePtr_0(global::System.IntPtr instance, int* ptr);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MultiOverloadPtrToRef> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MultiOverloadPtrToRef>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MultiOverloadPtrToRef __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MultiOverloadPtrToRef(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MultiOverloadPtrToRef __CreateInstance(global::CSharp.MultiOverloadPtrToRef.__Internal native, bool skipVTables = false)
        {
            return new MultiOverloadPtrToRef(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MultiOverloadPtrToRef.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MultiOverloadPtrToRef.__Internal));
            global::CSharp.MultiOverloadPtrToRef.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MultiOverloadPtrToRef(global::CSharp.MultiOverloadPtrToRef.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MultiOverloadPtrToRef(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MultiOverloadPtrToRef(ref int param)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultiOverloadPtrToRef.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            fixed (int* __refParamPtr0 = &param)
            {
                var __arg0 = __refParamPtr0;
                __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
            }
            SetupVTables(GetType().FullName == "CSharp.MultiOverloadPtrToRef");
        }

        public MultiOverloadPtrToRef(global::CSharp.MultiOverloadPtrToRef _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultiOverloadPtrToRef.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MultiOverloadPtrToRef");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.MultiOverloadPtrToRef __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.MultiOverloadPtrToRef.__Internal*) __Instance)->vfptr_MultiOverloadPtrToRef = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void FuncPrimitivePtrToRef(ref int pOne, char* pTwo, ref float pThree, ref bool pFour)
        {
            fixed (int* __refParamPtr0 = &pOne)
            {
                var __arg0 = __refParamPtr0;
                var __arg1 = (sbyte*) pTwo;
                fixed (float* __refParamPtr2 = &pThree)
                {
                    var __arg2 = __refParamPtr2;
                    fixed (bool* __refParamPtr3 = &pFour)
                    {
                        var __arg3 = __refParamPtr3;
                        __Internal.FuncPrimitivePtrToRef_0((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        public void FuncPrimitivePtrToRefWithDefVal(ref int pOne, char* pTwo, global::CSharp.Foo pThree, ref int pFour)
        {
            fixed (int* __refParamPtr0 = &pOne)
            {
                var __arg0 = __refParamPtr0;
                var __arg1 = (sbyte*) pTwo;
                var __arg2 = ReferenceEquals(pThree, null) ? global::System.IntPtr.Zero : pThree.__Instance;
                fixed (int* __refParamPtr3 = &pFour)
                {
                    var __arg3 = __refParamPtr3;
                    __Internal.FuncPrimitivePtrToRefWithDefVal_0((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
                }
            }
        }

        public virtual void FuncPrimitivePtrToRefWithMultiOverload(ref int pOne, char* pTwo, global::CSharp.Foo pThree, ref int pFour, ref int pFive)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___FuncPrimitivePtrToRefWithMultiOverload_0Delegate = (global::CSharp.Delegates.Action_IntPtr_intPtr_sbytePtr_IntPtr_intPtr_intPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_intPtr_sbytePtr_IntPtr_intPtr_intPtr));
            fixed (int* __refParamPtr0 = &pOne)
            {
                var __arg0 = __refParamPtr0;
                var __arg1 = (sbyte*) pTwo;
                var __arg2 = ReferenceEquals(pThree, null) ? global::System.IntPtr.Zero : pThree.__Instance;
                fixed (int* __refParamPtr3 = &pFour)
                {
                    var __arg3 = __refParamPtr3;
                    fixed (int* __refParamPtr4 = &pFive)
                    {
                        var __arg4 = __refParamPtr4;
                        ___FuncPrimitivePtrToRefWithMultiOverload_0Delegate((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public int* ReturnPrimTypePtr()
        {
            var __ret = __Internal.ReturnPrimTypePtr_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void TakePrimTypePtr(ref int ptr)
        {
            fixed (int* __refParamPtr0 = &ptr)
            {
                var __arg0 = __refParamPtr0;
                __Internal.TakePrimTypePtr_0((__Instance + __PointerAdjustment), __arg0);
            }
        }

        public static implicit operator global::CSharp.MultiOverloadPtrToRef(int* param)
        {
            return new global::CSharp.MultiOverloadPtrToRef(ref *param);
        }

        public void FuncPrimitivePtrToRef(ref int pOne, char* pTwo, ref float pThree)
        {
            bool param0 = false;
            FuncPrimitivePtrToRef(ref pOne, pTwo, ref pThree, ref param0);
        }

        public void FuncPrimitivePtrToRefWithDefVal(ref int pOne, char* pTwo, global::CSharp.Foo pThree)
        {
            int param0 = 0;
            FuncPrimitivePtrToRefWithDefVal(ref pOne, pTwo, pThree, ref param0);
        }

        public virtual void FuncPrimitivePtrToRefWithMultiOverload(ref int pOne, char* pTwo, global::CSharp.Foo pThree)
        {
            int param0 = 0;
            int param1 = 0;
            FuncPrimitivePtrToRefWithMultiOverload(ref pOne, pTwo, pThree, ref param0, ref param1);
        }

        public virtual void FuncPrimitivePtrToRefWithMultiOverload(ref int pOne, char* pTwo, global::CSharp.Foo pThree, ref int pFour)
        {
            int param0 = 0;
            FuncPrimitivePtrToRefWithMultiOverload(ref pOne, pTwo, pThree, ref pFour, ref param0);
        }

        #region Virtual table interop

        // void funcPrimitivePtrToRefWithMultiOverload(int* pOne, char* pTwo, Foo* pThree, int* pFour = 0, long* pFive = 0)
        private static global::CSharp.Delegates.Action_IntPtr_intPtr_sbytePtr_IntPtr_intPtr_intPtr _FuncPrimitivePtrToRefWithMultiOverload_0DelegateInstance;

        private static void _FuncPrimitivePtrToRefWithMultiOverload_0DelegateHook(global::System.IntPtr instance, int* pOne, sbyte* pTwo, global::System.IntPtr pThree, int* pFour, int* pFive)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MultiOverloadPtrToRef) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.Foo __result2;
            if (pThree == IntPtr.Zero) __result2 = null;
            else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(pThree))
                __result2 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[pThree];
            else __result2 = global::CSharp.Foo.__CreateInstance(pThree);
            __target.FuncPrimitivePtrToRefWithMultiOverload(ref *pOne, (char*) pTwo, __result2, ref *pFour, ref *pFive);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _FuncPrimitivePtrToRefWithMultiOverload_0DelegateInstance += _FuncPrimitivePtrToRefWithMultiOverload_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_FuncPrimitivePtrToRefWithMultiOverload_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class OverrideFromIndirectSecondaryBaseBase : global::CSharp.IOverrideFromIndirectSecondaryBaseBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverrideFromIndirectSecondaryBaseBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromIndirectSecondaryBaseBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromIndirectSecondaryBaseBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IOverrideFromIndirectSecondaryBaseBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IOverrideFromIndirectSecondaryBaseBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.OverrideFromIndirectSecondaryBaseBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverrideFromIndirectSecondaryBaseBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverrideFromIndirectSecondaryBaseBase __CreateInstance(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal native, bool skipVTables = false)
        {
            return new OverrideFromIndirectSecondaryBaseBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal));
            global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OverrideFromIndirectSecondaryBaseBase(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OverrideFromIndirectSecondaryBaseBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public OverrideFromIndirectSecondaryBaseBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.OverrideFromIndirectSecondaryBaseBase");
        }

        public OverrideFromIndirectSecondaryBaseBase(global::CSharp.IOverrideFromIndirectSecondaryBaseBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToOverrideFromIndirectSecondaryBaseBase;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverrideFromIndirectSecondaryBaseBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IOverrideFromIndirectSecondaryBaseBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.OverrideFromIndirectSecondaryBaseBase.__Internal*) __Instance)->vfptr_OverrideFromIndirectSecondaryBaseBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr __PointerToOverrideFromIndirectSecondaryBaseBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public virtual int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // int property()
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverrideFromIndirectSecondaryBaseBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class OverrideFromDirectSecondaryBase : global::CSharp.Foo, global::CSharp.IOverrideFromIndirectSecondaryBaseBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverrideFromIndirectSecondaryBaseBase;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromDirectSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromDirectSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.OverrideFromDirectSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverrideFromDirectSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverrideFromDirectSecondaryBase __CreateInstance(global::CSharp.OverrideFromDirectSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new OverrideFromDirectSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.OverrideFromDirectSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromDirectSecondaryBase.__Internal));
            global::CSharp.OverrideFromDirectSecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OverrideFromDirectSecondaryBase(global::CSharp.OverrideFromDirectSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OverrideFromDirectSecondaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public OverrideFromDirectSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromDirectSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.OverrideFromDirectSecondaryBase");
        }

        public OverrideFromDirectSecondaryBase(global::CSharp.OverrideFromDirectSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromDirectSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverrideFromDirectSecondaryBase");
        }

        public global::System.IntPtr __PointerToOverrideFromIndirectSecondaryBaseBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public virtual int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // int property()
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverrideFromDirectSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class OverrideFromIndirectSecondaryBase : global::CSharp.OverrideFromDirectSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverrideFromIndirectSecondaryBaseBase;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromIndirectSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverrideFromIndirectSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.OverrideFromIndirectSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverrideFromIndirectSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverrideFromIndirectSecondaryBase __CreateInstance(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new OverrideFromIndirectSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal));
            global::CSharp.OverrideFromIndirectSecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OverrideFromIndirectSecondaryBase(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OverrideFromIndirectSecondaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public OverrideFromIndirectSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.OverrideFromIndirectSecondaryBase");
        }

        public OverrideFromIndirectSecondaryBase(global::CSharp.OverrideFromIndirectSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverrideFromIndirectSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverrideFromIndirectSecondaryBase");
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // int property()
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverrideFromIndirectSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TestVariableWithFixedArrayType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestVariableWithFixedArrayType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestVariableWithFixedArrayType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestVariableWithFixedArrayType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestVariableWithFixedArrayType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestVariableWithFixedArrayType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestVariableWithFixedArrayType __CreateInstance(global::CSharp.TestVariableWithFixedArrayType.__Internal native, bool skipVTables = false)
        {
            return new TestVariableWithFixedArrayType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestVariableWithFixedArrayType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestVariableWithFixedArrayType.__Internal));
            *(global::CSharp.TestVariableWithFixedArrayType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestVariableWithFixedArrayType(global::CSharp.TestVariableWithFixedArrayType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestVariableWithFixedArrayType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestVariableWithFixedArrayType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestVariableWithFixedArrayType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestVariableWithFixedArrayType(global::CSharp.TestVariableWithFixedArrayType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestVariableWithFixedArrayType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestVariableWithFixedArrayType.__Internal*) __Instance) = *((global::CSharp.TestVariableWithFixedArrayType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestVariableWithFixedArrayType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static global::CSharp.Foo[] VariableWithFixedArrayType
        {
            get
            {
                var __ptr = (byte*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?variableWithFixedArrayType@TestVariableWithFixedArrayType@@2PAVFoo@@A");
                global::CSharp.Foo[] __value = null;
                if (__ptr != null)
                {
                    __value = new global::CSharp.Foo[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::CSharp.Foo.__CreateInstance(*((global::CSharp.Foo.__Internal*)&(__ptr[i * sizeof(global::CSharp.Foo.__Internal)])));
                }
                return __value;
            }
        }
    }

    public unsafe partial class TestOutTypeInterfaces : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestOutTypeInterfaces@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?funcTryInterfaceTypePtrOut@TestOutTypeInterfaces@@QAEXPAVTestParamToInterfacePassBaseTwo@@@Z")]
            internal static extern void FuncTryInterfaceTypePtrOut_0(global::System.IntPtr instance, global::System.IntPtr classTry);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?funcTryInterfaceTypeOut@TestOutTypeInterfaces@@QAEXVTestParamToInterfacePassBaseTwo@@@Z")]
            internal static extern void FuncTryInterfaceTypeOut_0(global::System.IntPtr instance, global::CSharp.TestParamToInterfacePassBaseTwo.__Internal classTry);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestOutTypeInterfaces> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestOutTypeInterfaces>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestOutTypeInterfaces __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestOutTypeInterfaces(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestOutTypeInterfaces __CreateInstance(global::CSharp.TestOutTypeInterfaces.__Internal native, bool skipVTables = false)
        {
            return new TestOutTypeInterfaces(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestOutTypeInterfaces.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOutTypeInterfaces.__Internal));
            *(global::CSharp.TestOutTypeInterfaces.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestOutTypeInterfaces(global::CSharp.TestOutTypeInterfaces.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestOutTypeInterfaces(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestOutTypeInterfaces()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOutTypeInterfaces.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public TestOutTypeInterfaces(global::CSharp.TestOutTypeInterfaces _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestOutTypeInterfaces.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestOutTypeInterfaces.__Internal*) __Instance) = *((global::CSharp.TestOutTypeInterfaces.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestOutTypeInterfaces __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public void FuncTryInterfaceTypePtrOut(out global::CSharp.ITestParamToInterfacePassBaseTwo classTry)
        {
            classTry = new global::CSharp.TestParamToInterfacePassBaseTwo();
            var __arg0 = ReferenceEquals(classTry, null) ? global::System.IntPtr.Zero : classTry.__PointerToTestParamToInterfacePassBaseTwo;
            __Internal.FuncTryInterfaceTypePtrOut_0((__Instance + __PointerAdjustment), __arg0);
            global::CSharp.ITestParamToInterfacePassBaseTwo __result0;
            if (__arg0 == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.TestParamToInterfacePassBaseTwo.NativeToManagedMap.ContainsKey(__arg0))
                __result0 = (global::CSharp.ITestParamToInterfacePassBaseTwo) global::CSharp.TestParamToInterfacePassBaseTwo.NativeToManagedMap[__arg0];
            else __result0 = global::CSharp.TestParamToInterfacePassBaseTwo.__CreateInstance(__arg0);
            classTry = __result0;
        }

        public void FuncTryInterfaceTypeOut(out global::CSharp.ITestParamToInterfacePassBaseTwo classTry)
        {
            classTry = new global::CSharp.TestParamToInterfacePassBaseTwo();
            var __arg0 = ReferenceEquals(classTry, null) ? new global::CSharp.TestParamToInterfacePassBaseTwo.__Internal() : *(global::CSharp.TestParamToInterfacePassBaseTwo.__Internal*) classTry.__PointerToTestParamToInterfacePassBaseTwo;
            __Internal.FuncTryInterfaceTypeOut_0((__Instance + __PointerAdjustment), __arg0);
            classTry = global::CSharp.TestParamToInterfacePassBaseTwo.__CreateInstance(__arg0);
        }
    }

    public unsafe partial class DerivesFromTemplateInstantiation : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int t;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivesFromTemplateInstantiation@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0DerivesFromTemplateInstantiation@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DerivesFromTemplateInstantiation> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.DerivesFromTemplateInstantiation>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.DerivesFromTemplateInstantiation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new DerivesFromTemplateInstantiation(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.DerivesFromTemplateInstantiation __CreateInstance(global::CSharp.DerivesFromTemplateInstantiation.__Internal native, bool skipVTables = false)
        {
            return new DerivesFromTemplateInstantiation(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.DerivesFromTemplateInstantiation.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.DerivesFromTemplateInstantiation.__Internal));
            *(global::CSharp.DerivesFromTemplateInstantiation.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DerivesFromTemplateInstantiation(global::CSharp.DerivesFromTemplateInstantiation.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DerivesFromTemplateInstantiation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DerivesFromTemplateInstantiation()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.DerivesFromTemplateInstantiation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public DerivesFromTemplateInstantiation(global::CSharp.DerivesFromTemplateInstantiation _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.DerivesFromTemplateInstantiation.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.DerivesFromTemplateInstantiation.__Internal*) __Instance) = *((global::CSharp.DerivesFromTemplateInstantiation.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.DerivesFromTemplateInstantiation __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class TestComparison : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int A;

            [FieldOffset(4)]
            public float B;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestComparison@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestComparison@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??8TestComparison@@QBE_NABV0@@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr other);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestComparison> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestComparison>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestComparison __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestComparison(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestComparison __CreateInstance(global::CSharp.TestComparison.__Internal native, bool skipVTables = false)
        {
            return new TestComparison(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestComparison.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestComparison.__Internal));
            *(global::CSharp.TestComparison.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestComparison(global::CSharp.TestComparison.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestComparison(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestComparison()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestComparison.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestComparison(global::CSharp.TestComparison _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestComparison.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestComparison.__Internal*) __Instance) = *((global::CSharp.TestComparison.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestComparison __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static bool operator !=(global::CSharp.TestComparison __op, global::CSharp.TestComparison other)
        {
            return !(__op == other);
        }

        public static bool operator ==(global::CSharp.TestComparison __op, global::CSharp.TestComparison other)
        {
            bool __opNull = ReferenceEquals(__op, null);
            bool otherNull = ReferenceEquals(other, null);
            if (__opNull || otherNull)
                return __opNull && otherNull;
            var __arg0 = __op.__Instance;
            var __arg1 = other.__Instance;
            var __ret = __Internal.OperatorEqualEqual_0(__arg0, __arg1);
            return __ret;
        }

        public override bool Equals(object obj)
        {
            return this == obj as TestComparison;
        }

        public override int GetHashCode()
        {
            if (__Instance == global::System.IntPtr.Zero)
                return global::System.IntPtr.Zero.GetHashCode();
            return (*(global::CSharp.TestComparison.__Internal*) __Instance).GetHashCode();
        }

        public int A
        {
            get
            {
                return ((global::CSharp.TestComparison.__Internal*) __Instance)->A;
            }

            set
            {
                ((global::CSharp.TestComparison.__Internal*) __Instance)->A = value;
            }
        }

        public float B
        {
            get
            {
                return ((global::CSharp.TestComparison.__Internal*) __Instance)->B;
            }

            set
            {
                ((global::CSharp.TestComparison.__Internal*) __Instance)->B = value;
            }
        }
    }

    public unsafe abstract partial class OverridePropertyFromIndirectPrimaryBaseBase : global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverridePropertyFromIndirectPrimaryBaseBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromIndirectPrimaryBaseBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromIndirectPrimaryBaseBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverridePropertyFromIndirectPrimaryBaseBaseInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase __CreateInstance(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal native, bool skipVTables = false)
        {
            return new OverridePropertyFromIndirectPrimaryBaseBaseInternal(native, skipVTables);
        }

        protected OverridePropertyFromIndirectPrimaryBaseBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected OverridePropertyFromIndirectPrimaryBaseBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromIndirectPrimaryBaseBase");
        }

        protected OverridePropertyFromIndirectPrimaryBaseBase(global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToOverridePropertyFromIndirectPrimaryBaseBase;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromIndirectPrimaryBaseBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal*) __Instance)->vfptr_OverridePropertyFromIndirectPrimaryBaseBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr __PointerToOverridePropertyFromIndirectPrimaryBaseBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public abstract int Property
        {
            get;

            set;
        }

        #region Virtual table interop

        // int property() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int value) = 0
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = value;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class OverridePropertyFromDirectPrimaryBase : global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverridePropertyFromIndirectPrimaryBaseBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromDirectPrimaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromDirectPrimaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.OverridePropertyFromDirectPrimaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverridePropertyFromDirectPrimaryBaseInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverridePropertyFromDirectPrimaryBase __CreateInstance(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal native, bool skipVTables = false)
        {
            return new OverridePropertyFromDirectPrimaryBaseInternal(native, skipVTables);
        }

        protected OverridePropertyFromDirectPrimaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected OverridePropertyFromDirectPrimaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromDirectPrimaryBase");
        }

        protected OverridePropertyFromDirectPrimaryBase(global::CSharp.OverridePropertyFromDirectPrimaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromDirectPrimaryBase");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal*) __Instance)->vfptr_OverridePropertyFromIndirectPrimaryBaseBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override int Property
        {
            get;

            set;
        }

        #region Virtual table interop

        // int property() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromDirectPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromDirectPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = value;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class OverridePropertyFromIndirectPrimaryBase : global::CSharp.OverridePropertyFromDirectPrimaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverridePropertyFromIndirectPrimaryBaseBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromIndirectPrimaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0OverridePropertyFromIndirectPrimaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.OverridePropertyFromIndirectPrimaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new OverridePropertyFromIndirectPrimaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.OverridePropertyFromIndirectPrimaryBase __CreateInstance(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal native, bool skipVTables = false)
        {
            return new OverridePropertyFromIndirectPrimaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal));
            global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private OverridePropertyFromIndirectPrimaryBase(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected OverridePropertyFromIndirectPrimaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public OverridePropertyFromIndirectPrimaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromIndirectPrimaryBase");
        }

        public OverridePropertyFromIndirectPrimaryBase(global::CSharp.OverridePropertyFromIndirectPrimaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.OverridePropertyFromIndirectPrimaryBase");
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetProperty_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProperty_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        #region Virtual table interop

        // int property()
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromIndirectPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.OverridePropertyFromIndirectPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = value;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class AbstractOverrideFromSecondaryBase : global::CSharp.Foo, global::CSharp.IOverridePropertyFromIndirectPrimaryBaseBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_OverridePropertyFromIndirectPrimaryBaseBase;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractOverrideFromSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractOverrideFromSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.AbstractOverrideFromSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractOverrideFromSecondaryBaseInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.AbstractOverrideFromSecondaryBase __CreateInstance(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new AbstractOverrideFromSecondaryBaseInternal(native, skipVTables);
        }

        protected AbstractOverrideFromSecondaryBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected AbstractOverrideFromSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.AbstractOverrideFromSecondaryBase");
        }

        protected AbstractOverrideFromSecondaryBase(global::CSharp.AbstractOverrideFromSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.AbstractOverrideFromSecondaryBase");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.AbstractOverrideFromSecondaryBase.__Internal*) __Instance)->vfptr_OverridePropertyFromIndirectPrimaryBaseBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr __PointerToOverridePropertyFromIndirectPrimaryBaseBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public abstract int Property
        {
            get;

            set;
        }

        #region Virtual table interop

        // int property() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractOverrideFromSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        // void setProperty(int value) = 0
        private static global::CSharp.Delegates.Action_IntPtr_int _SetProperty_0DelegateInstance;

        private static void _SetProperty_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractOverrideFromSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Property = value;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
                _SetProperty_0DelegateInstance += _SetProperty_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_SetProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class QObject : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_QObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QObject@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QObject@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QObject>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QObject __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QObject(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QObject __CreateInstance(global::CSharp.QObject.__Internal native, bool skipVTables = false)
        {
            return new QObject(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QObject.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QObject.__Internal));
            global::CSharp.QObject.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private QObject(global::CSharp.QObject.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public QObject()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.QObject");
        }

        public QObject(global::CSharp.QObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.QObject");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.QObject __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.QObject.__Internal*) __Instance)->vfptr_QObject = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void Event()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___Event_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___Event_0Delegate((__Instance + __PointerAdjustment));
        }

        #region Virtual table interop

        // virtual ~QObject()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void event()
        private static global::CSharp.Delegates.Action_IntPtr _Event_0DelegateInstance;

        private static void _Event_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QObject) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Event();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Event_0DelegateInstance += _Event_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Event_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class QPaintDevice : global::CSharp.IQPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_QPaintDevice;

            [FieldOffset(4)]
            public int test;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPaintDevice@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPaintDevice@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1QPaintDevice@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IQPaintDevice> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IQPaintDevice>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QPaintDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QPaintDevice(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QPaintDevice __CreateInstance(global::CSharp.QPaintDevice.__Internal native, bool skipVTables = false)
        {
            return new QPaintDevice(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QPaintDevice.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QPaintDevice.__Internal));
            global::CSharp.QPaintDevice.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private QPaintDevice(global::CSharp.QPaintDevice.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QPaintDevice(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public QPaintDevice()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QPaintDevice.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.QPaintDevice");
        }

        public QPaintDevice(global::CSharp.IQPaintDevice _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QPaintDevice.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToQPaintDevice;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.QPaintDevice");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IQPaintDevice __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.QPaintDevice.__Internal*) __Instance)->vfptr_QPaintDevice = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void ChangeVTableLayout()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___ChangeVTableLayout_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ChangeVTableLayout_0Delegate((__Instance));
        }

        public int Test
        {
            get
            {
                return ((global::CSharp.QPaintDevice.__Internal*) __Instance)->test;
            }

            set
            {
                ((global::CSharp.QPaintDevice.__Internal*) __Instance)->test = value;
            }
        }

        public global::System.IntPtr __PointerToQPaintDevice
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void changeVTableLayout()
        private static global::CSharp.Delegates.Action_IntPtr _ChangeVTableLayout_0DelegateInstance;

        private static void _ChangeVTableLayout_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QPaintDevice) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ChangeVTableLayout();
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _ChangeVTableLayout_0DelegateInstance += _ChangeVTableLayout_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ChangeVTableLayout_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class QWidget : global::CSharp.QObject, global::CSharp.IQPaintDevice, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_QObject;

            [FieldOffset(4)]
            public global::System.IntPtr vfptr_QPaintDevice;

            [FieldOffset(8)]
            public int test;

            [FieldOffset(12)]
            public global::CSharp.QObject.__Internal child;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QWidget@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QWidget@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.QWidget __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QWidget(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QWidget __CreateInstance(global::CSharp.QWidget.__Internal native, bool skipVTables = false)
        {
            return new QWidget(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QWidget.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QWidget.__Internal));
            global::CSharp.QWidget.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private QWidget(global::CSharp.QWidget.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QWidget(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };
            else
                SetupVTables(true);
        }

        public QWidget()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QWidget.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.QWidget");
        }

        public QWidget(global::CSharp.QWidget _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QWidget.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.QWidget");
        }

        public override void Event()
        {
            base.Event();
        }

        public virtual void ChangeVTableLayout()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[1] + 0 * 4);
            var ___ChangeVTableLayout_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ChangeVTableLayout_0Delegate((__Instance + 4));
        }

        public int Test
        {
            get
            {
                return ((global::CSharp.QWidget.__Internal*) __Instance)->test;
            }

            set
            {
                ((global::CSharp.QWidget.__Internal*) __Instance)->test = value;
            }
        }

        public global::System.IntPtr __PointerToQPaintDevice
        {
            get
            {
                return __Instance + 4;
            }
        }

        #region Virtual table interop

        // ~QWidget()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QWidget) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void event()
        private static global::CSharp.Delegates.Action_IntPtr _Event_0DelegateInstance;

        private static void _Event_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QWidget) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Event();
        }

        // void changeVTableLayout()
        private static global::CSharp.Delegates.Action_IntPtr _ChangeVTableLayout_0DelegateInstance;

        private static void _ChangeVTableLayout_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QWidget) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ChangeVTableLayout();
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Event_0DelegateInstance += _Event_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Event_0DelegateInstance).ToPointer();
                _ChangeVTableLayout_0DelegateInstance += _ChangeVTableLayout_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ChangeVTableLayout_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    var vfptr1 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 4 + 0);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 4) = __ManagedVTablesDtorOnly[1];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                    var vfptr1 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 4) = __ManagedVTables[1];
            }
        }

        #endregion
    }

    public unsafe partial class QPainter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPainter@@QAE@AAVQPaintDevice@@@Z")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, global::System.IntPtr paintDevice);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QPainter@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1QPainter@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QPainter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.QPainter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.QPainter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QPainter(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QPainter __CreateInstance(global::CSharp.QPainter.__Internal native, bool skipVTables = false)
        {
            return new QPainter(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QPainter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QPainter.__Internal));
            *(global::CSharp.QPainter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QPainter(global::CSharp.QPainter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QPainter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public QPainter(global::CSharp.IQPaintDevice paintDevice)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QPainter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(paintDevice, null))
                throw new global::System.ArgumentNullException("paintDevice", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = paintDevice.__PointerToQPaintDevice;
            __Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
        }

        public QPainter(global::CSharp.QPainter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QPainter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.QPainter.__Internal*) __Instance) = *((global::CSharp.QPainter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.QPainter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static implicit operator global::CSharp.QPainter(global::CSharp.QPaintDevice paintDevice)
        {
            return new global::CSharp.QPainter((IQPaintDevice) paintDevice);
        }
    }

    public unsafe partial class QApplication : global::CSharp.QObject, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_QObject;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QApplication@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0QApplication@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.QApplication __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new QApplication(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.QApplication __CreateInstance(global::CSharp.QApplication.__Internal native, bool skipVTables = false)
        {
            return new QApplication(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.QApplication.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.QApplication.__Internal));
            global::CSharp.QApplication.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private QApplication(global::CSharp.QApplication.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QApplication(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public QApplication()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QApplication.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.QApplication");
        }

        public QApplication(global::CSharp.QApplication _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.QApplication.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.QApplication");
        }

        public virtual void Notify(global::CSharp.QObject receiver)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___Notify_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr));
            var __arg0 = ReferenceEquals(receiver, null) ? global::System.IntPtr.Zero : receiver.__Instance;
            ___Notify_0Delegate((__Instance + __PointerAdjustment), __arg0);
        }

        public static global::CSharp.QApplication Instance
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?instance@QApplication@@2PAV1@A");
                global::CSharp.QApplication __result0;
                if (*__ptr == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.QApplication.NativeToManagedMap.ContainsKey(*__ptr))
                    __result0 = (global::CSharp.QApplication) global::CSharp.QApplication.NativeToManagedMap[*__ptr];
                else global::CSharp.QApplication.NativeToManagedMap[*__ptr] = __result0 = (global::CSharp.QApplication) global::CSharp.QApplication.__CreateInstance(*__ptr);
                return __result0;
            }

            set
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?instance@QApplication@@2PAV1@A");
                *__ptr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        #region Virtual table interop

        // QApplication
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QApplication) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // void event()
        private static global::CSharp.Delegates.Action_IntPtr _Event_0DelegateInstance;

        private static void _Event_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QApplication) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Event();
        }

        // void notify(QObject* receiver)
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr _Notify_0DelegateInstance;

        private static void _Notify_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr receiver)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.QApplication) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.QObject __result0;
            if (receiver == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.QObject.NativeToManagedMap.ContainsKey(receiver))
                __result0 = (global::CSharp.QObject) global::CSharp.QObject.NativeToManagedMap[receiver];
            else __result0 = (global::CSharp.QObject) global::CSharp.QObject.__CreateInstance(receiver, skipVTables: true);
            __target.Notify(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _Event_0DelegateInstance += _Event_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Event_0DelegateInstance).ToPointer();
                _Notify_0DelegateInstance += _Notify_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_Notify_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                    *(void**) (vfptr0 + 8) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class HasSamePropertyInDerivedAbstractType : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSamePropertyInDerivedAbstractType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSamePropertyInDerivedAbstractType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?property@HasSamePropertyInDerivedAbstractType@@QAEPADXZ")]
            internal static extern sbyte* Property_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasSamePropertyInDerivedAbstractType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasSamePropertyInDerivedAbstractType>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasSamePropertyInDerivedAbstractType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasSamePropertyInDerivedAbstractType(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasSamePropertyInDerivedAbstractType __CreateInstance(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal native, bool skipVTables = false)
        {
            return new HasSamePropertyInDerivedAbstractType(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal));
            *(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasSamePropertyInDerivedAbstractType(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasSamePropertyInDerivedAbstractType(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasSamePropertyInDerivedAbstractType()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public HasSamePropertyInDerivedAbstractType(global::CSharp.HasSamePropertyInDerivedAbstractType _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal*) __Instance) = *((global::CSharp.HasSamePropertyInDerivedAbstractType.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasSamePropertyInDerivedAbstractType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public char* Property
        {
            get
            {
                var __ret = __Internal.Property_0((__Instance + __PointerAdjustment));
                return (char*) __ret;
            }
        }
    }

    public unsafe abstract partial class InheritsFromHasSamePropertyInDerivedAbstractType : global::CSharp.HasSamePropertyInDerivedAbstractType, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_InheritsFromHasSamePropertyInDerivedAbstractType;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritsFromHasSamePropertyInDerivedAbstractType@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0InheritsFromHasSamePropertyInDerivedAbstractType@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new InheritsFromHasSamePropertyInDerivedAbstractTypeInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType __CreateInstance(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal native, bool skipVTables = false)
        {
            return new InheritsFromHasSamePropertyInDerivedAbstractTypeInternal(native, skipVTables);
        }

        protected InheritsFromHasSamePropertyInDerivedAbstractType(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected InheritsFromHasSamePropertyInDerivedAbstractType()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.InheritsFromHasSamePropertyInDerivedAbstractType");
        }

        protected InheritsFromHasSamePropertyInDerivedAbstractType(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.InheritsFromHasSamePropertyInDerivedAbstractType");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.HasSamePropertyInDerivedAbstractType __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal*) __Instance)->vfptr_InheritsFromHasSamePropertyInDerivedAbstractType = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract int Property
        {
            get;
        }

        #region Virtual table interop

        // int property() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _Property_0DelegateInstance;

        private static int _Property_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.Property;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Property_0DelegateInstance += _Property_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Property_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class MultipleInheritanceFieldOffsetsSecondaryBase : global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int secondary;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsetsSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsetsSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsetsSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase __CreateInstance(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsetsSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal));
            *(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MultipleInheritanceFieldOffsetsSecondaryBase(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MultipleInheritanceFieldOffsetsSecondaryBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MultipleInheritanceFieldOffsetsSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
        }

        public MultipleInheritanceFieldOffsetsSecondaryBase(global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal*) __Instance) = *((global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Secondary
        {
            get
            {
                return ((global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal*) __Instance)->secondary;
            }

            set
            {
                ((global::CSharp.MultipleInheritanceFieldOffsetsSecondaryBase.__Internal*) __Instance)->secondary = value;
            }
        }

        public global::System.IntPtr __PointerToMultipleInheritanceFieldOffsetsSecondaryBase
        {
            get
            {
                return __Instance + 0;
            }
        }
    }

    public unsafe partial class MultipleInheritanceFieldOffsetsPrimaryBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int primary;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsetsPrimaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsetsPrimaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsetsPrimaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase __CreateInstance(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsetsPrimaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal));
            *(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MultipleInheritanceFieldOffsetsPrimaryBase(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MultipleInheritanceFieldOffsetsPrimaryBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MultipleInheritanceFieldOffsetsPrimaryBase()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public MultipleInheritanceFieldOffsetsPrimaryBase(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal*) __Instance) = *((global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int Primary
        {
            get
            {
                return ((global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal*) __Instance)->primary;
            }

            set
            {
                ((global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase.__Internal*) __Instance)->primary = value;
            }
        }
    }

    public unsafe partial class MultipleInheritanceFieldOffsets : global::CSharp.MultipleInheritanceFieldOffsetsPrimaryBase, global::CSharp.IMultipleInheritanceFieldOffsetsSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public int primary;

            [FieldOffset(4)]
            public int secondary;

            [FieldOffset(8)]
            public int own;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsets@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MultipleInheritanceFieldOffsets@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.MultipleInheritanceFieldOffsets __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsets(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MultipleInheritanceFieldOffsets __CreateInstance(global::CSharp.MultipleInheritanceFieldOffsets.__Internal native, bool skipVTables = false)
        {
            return new MultipleInheritanceFieldOffsets(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MultipleInheritanceFieldOffsets.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsets.__Internal));
            *(global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MultipleInheritanceFieldOffsets(global::CSharp.MultipleInheritanceFieldOffsets.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MultipleInheritanceFieldOffsets(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MultipleInheritanceFieldOffsets()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsets.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public MultipleInheritanceFieldOffsets(global::CSharp.MultipleInheritanceFieldOffsets _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MultipleInheritanceFieldOffsets.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) __Instance) = *((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) _0.__Instance);
        }

        public int Own
        {
            get
            {
                return ((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) __Instance)->own;
            }

            set
            {
                ((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) __Instance)->own = value;
            }
        }

        public int Secondary
        {
            get
            {
                return ((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) __Instance)->secondary;
            }

            set
            {
                ((global::CSharp.MultipleInheritanceFieldOffsets.__Internal*) __Instance)->secondary = value;
            }
        }

        public global::System.IntPtr __PointerToMultipleInheritanceFieldOffsetsSecondaryBase
        {
            get
            {
                return __Instance + 4;
            }
        }
    }

    public unsafe partial class VirtualDtorAddedInDerived : global::CSharp.Foo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_VirtualDtorAddedInDerived;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0VirtualDtorAddedInDerived@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0VirtualDtorAddedInDerived@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.VirtualDtorAddedInDerived __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new VirtualDtorAddedInDerived(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.VirtualDtorAddedInDerived __CreateInstance(global::CSharp.VirtualDtorAddedInDerived.__Internal native, bool skipVTables = false)
        {
            return new VirtualDtorAddedInDerived(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.VirtualDtorAddedInDerived.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.VirtualDtorAddedInDerived.__Internal));
            global::CSharp.VirtualDtorAddedInDerived.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private VirtualDtorAddedInDerived(global::CSharp.VirtualDtorAddedInDerived.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VirtualDtorAddedInDerived(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        public VirtualDtorAddedInDerived()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.VirtualDtorAddedInDerived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
            SetupVTables(GetType().FullName == "CSharp.VirtualDtorAddedInDerived");
        }

        public VirtualDtorAddedInDerived(global::CSharp.VirtualDtorAddedInDerived _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.VirtualDtorAddedInDerived.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
            SetupVTables(GetType().FullName == "CSharp.VirtualDtorAddedInDerived");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.Foo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.VirtualDtorAddedInDerived.__Internal*) __Instance)->vfptr_VirtualDtorAddedInDerived = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___dtor_0Delegate((__Instance + __PointerAdjustment - 4), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public static bool DtorCalled
        {
            get
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?dtorCalled@VirtualDtorAddedInDerived@@2_NA");
                return *__ptr;
            }

            set
            {
                var __ptr = (bool*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?dtorCalled@VirtualDtorAddedInDerived@@2_NA");
                *__ptr = value;
            }
        }

        #region Virtual table interop

        // virtual ~VirtualDtorAddedInDerived()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.VirtualDtorAddedInDerived) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ClassWithVirtualBase : global::CSharp.Foo, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vbptr_ClassWithVirtualBase;

            [FieldOffset(4)]
            public int A;

            [FieldOffset(8)]
            public global::System.IntPtr functionPtrReturnsPtrParam;

            [FieldOffset(12)]
            public global::System.IntPtr attributedFunctionPtr;

            [FieldOffset(16)]
            public int P;

            [FieldOffset(20)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__I templateInAnotherUnit;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassWithVirtualBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ClassWithVirtualBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.ClassWithVirtualBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ClassWithVirtualBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ClassWithVirtualBase __CreateInstance(global::CSharp.ClassWithVirtualBase.__Internal native, bool skipVTables = false)
        {
            return new ClassWithVirtualBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ClassWithVirtualBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ClassWithVirtualBase.__Internal));
            global::CSharp.ClassWithVirtualBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ClassWithVirtualBase(global::CSharp.ClassWithVirtualBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ClassWithVirtualBase(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 4;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ClassWithVirtualBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ClassWithVirtualBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment - 4));
        }

        public ClassWithVirtualBase(global::CSharp.ClassWithVirtualBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ClassWithVirtualBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment - 4), __arg0);
        }
    }

    public unsafe abstract partial class HasPrivateVirtualProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasPrivateVirtualProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPrivateVirtualProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPrivateVirtualProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasPrivateVirtualProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasPrivateVirtualProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasPrivateVirtualProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasPrivateVirtualPropertyInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasPrivateVirtualProperty __CreateInstance(global::CSharp.HasPrivateVirtualProperty.__Internal native, bool skipVTables = false)
        {
            return new HasPrivateVirtualPropertyInternal(native, skipVTables);
        }

        protected HasPrivateVirtualProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        protected HasPrivateVirtualProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateVirtualProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        protected HasPrivateVirtualProperty(global::CSharp.HasPrivateVirtualProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateVirtualProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasPrivateVirtualProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasPrivateOverriddenProperty : global::CSharp.HasPrivateVirtualProperty, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasPrivateVirtualProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPrivateOverriddenProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasPrivateOverriddenProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.HasPrivateOverriddenProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasPrivateOverriddenProperty(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasPrivateOverriddenProperty __CreateInstance(global::CSharp.HasPrivateOverriddenProperty.__Internal native, bool skipVTables = false)
        {
            return new HasPrivateOverriddenProperty(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasPrivateOverriddenProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateOverriddenProperty.__Internal));
            global::CSharp.HasPrivateOverriddenProperty.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasPrivateOverriddenProperty(global::CSharp.HasPrivateOverriddenProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasPrivateOverriddenProperty(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasPrivateOverriddenProperty()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateOverriddenProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasPrivateOverriddenProperty");
        }

        public HasPrivateOverriddenProperty(global::CSharp.HasPrivateOverriddenProperty _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateOverriddenProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasPrivateOverriddenProperty");
        }

        protected virtual void ProtectedAbstractMethod()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___ProtectedAbstractMethod_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ProtectedAbstractMethod_0Delegate((__Instance + __PointerAdjustment));
        }

        protected virtual void ProtectedMethod()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
            var ___ProtectedMethod_0Delegate = (global::CSharp.Delegates.Action_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr));
            ___ProtectedMethod_0Delegate((__Instance + __PointerAdjustment));
        }

        protected virtual int ProtectedProperty
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
                var ___ProtectedProperty_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___ProtectedProperty_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void protectedAbstractMethod()
        private static global::CSharp.Delegates.Action_IntPtr _ProtectedAbstractMethod_0DelegateInstance;

        private static void _ProtectedAbstractMethod_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasPrivateOverriddenProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ProtectedAbstractMethod();
        }

        // void protectedMethod()
        private static global::CSharp.Delegates.Action_IntPtr _ProtectedMethod_0DelegateInstance;

        private static void _ProtectedMethod_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasPrivateOverriddenProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.ProtectedMethod();
        }

        // int protectedProperty()
        private static global::CSharp.Delegates.Func_int_IntPtr _ProtectedProperty_0DelegateInstance;

        private static int _ProtectedProperty_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasPrivateOverriddenProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.ProtectedProperty;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _ProtectedAbstractMethod_0DelegateInstance += _ProtectedAbstractMethod_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_ProtectedAbstractMethod_0DelegateInstance).ToPointer();
                _ProtectedMethod_0DelegateInstance += _ProtectedMethod_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ProtectedMethod_0DelegateInstance).ToPointer();
                _ProtectedProperty_0DelegateInstance += _ProtectedProperty_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ProtectedProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(4 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 0);
                *(void**) (vfptr0 + 4) = _Thunks[0];
                *(void**) (vfptr0 + 8) = _Thunks[1];
                *(void**) (vfptr0 + 12) = _Thunks[2];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasConflictWithProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasConflictWithProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?getConflictWithProperty@HasConflictWithProperty@@QAEHXZ")]
            internal static extern int GetConflictWithProperty_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?conflictWithProperty@HasConflictWithProperty@@QAEHXZ")]
            internal static extern int ConflictWithProperty_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasConflictWithProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasConflictWithProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasConflictWithProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasConflictWithProperty(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasConflictWithProperty __CreateInstance(global::CSharp.HasConflictWithProperty.__Internal native, bool skipVTables = false)
        {
            return new HasConflictWithProperty(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasConflictWithProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithProperty.__Internal));
            *(global::CSharp.HasConflictWithProperty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasConflictWithProperty(global::CSharp.HasConflictWithProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasConflictWithProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasConflictWithProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HasConflictWithProperty(global::CSharp.HasConflictWithProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.HasConflictWithProperty.__Internal*) __Instance) = *((global::CSharp.HasConflictWithProperty.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasConflictWithProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int GetConflictWithProperty()
        {
            var __ret = __Internal.GetConflictWithProperty_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public int ConflictWithProperty
        {
            get
            {
                var __ret = __Internal.ConflictWithProperty_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe abstract partial class HasConflictWithAbstractProperty : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasConflictWithAbstractProperty;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasConflictWithAbstractProperty@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasConflictWithAbstractProperty@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?conflictWithProperty@HasConflictWithAbstractProperty@@QAEHXZ")]
            internal static extern int ConflictWithProperty_0(global::System.IntPtr instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasConflictWithAbstractProperty> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasConflictWithAbstractProperty>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasConflictWithAbstractProperty __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasConflictWithAbstractPropertyInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasConflictWithAbstractProperty __CreateInstance(global::CSharp.HasConflictWithAbstractProperty.__Internal native, bool skipVTables = false)
        {
            return new HasConflictWithAbstractPropertyInternal(native, skipVTables);
        }

        protected HasConflictWithAbstractProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected HasConflictWithAbstractProperty()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithAbstractProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasConflictWithAbstractProperty");
        }

        protected HasConflictWithAbstractProperty(global::CSharp.HasConflictWithAbstractProperty _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithAbstractProperty.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasConflictWithAbstractProperty");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasConflictWithAbstractProperty __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasConflictWithAbstractProperty.__Internal*) __Instance)->vfptr_HasConflictWithAbstractProperty = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract int GetConflictWithProperty();

        public int ConflictWithProperty
        {
            get
            {
                var __ret = __Internal.ConflictWithProperty_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // int getConflictWithProperty() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _GetConflictWithProperty_0DelegateInstance;

        private static int _GetConflictWithProperty_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasConflictWithAbstractProperty) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.GetConflictWithProperty();
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _GetConflictWithProperty_0DelegateInstance += _GetConflictWithProperty_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_GetConflictWithProperty_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasFieldsOfLowerCaseTemplate : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CSharp.LowerCase.__Internal i;

            [FieldOffset(1)]
            internal global::CSharp.LowerCase.__Internal l;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasFieldsOfLowerCaseTemplate@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasFieldsOfLowerCaseTemplate> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasFieldsOfLowerCaseTemplate>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasFieldsOfLowerCaseTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasFieldsOfLowerCaseTemplate(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasFieldsOfLowerCaseTemplate __CreateInstance(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal native, bool skipVTables = false)
        {
            return new HasFieldsOfLowerCaseTemplate(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal));
            *(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasFieldsOfLowerCaseTemplate(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasFieldsOfLowerCaseTemplate(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasFieldsOfLowerCaseTemplate()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HasFieldsOfLowerCaseTemplate(global::CSharp.HasFieldsOfLowerCaseTemplate _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal*) __Instance) = *((global::CSharp.HasFieldsOfLowerCaseTemplate.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasFieldsOfLowerCaseTemplate __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class HasVirtualTakesReturnsProblematicTypes : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualTakesReturnsProblematicTypes;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualTakesReturnsProblematicTypes@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasVirtualTakesReturnsProblematicTypes@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasVirtualTakesReturnsProblematicTypes@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?callsVirtualToReturnString@HasVirtualTakesReturnsProblematicTypes@@QAEPBDPBD@Z")]
            internal static extern global::System.IntPtr CallsVirtualToReturnString_0(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?callsVirtualToReturnBool@HasVirtualTakesReturnsProblematicTypes@@QAE_N_N@Z")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CallsVirtualToReturnBool_0(global::System.IntPtr instance, sbyte b);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualTakesReturnsProblematicTypes> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasVirtualTakesReturnsProblematicTypes>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasVirtualTakesReturnsProblematicTypes __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasVirtualTakesReturnsProblematicTypes(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasVirtualTakesReturnsProblematicTypes __CreateInstance(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal native, bool skipVTables = false)
        {
            return new HasVirtualTakesReturnsProblematicTypes(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal));
            global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasVirtualTakesReturnsProblematicTypes(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasVirtualTakesReturnsProblematicTypes(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasVirtualTakesReturnsProblematicTypes()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasVirtualTakesReturnsProblematicTypes");
        }

        public HasVirtualTakesReturnsProblematicTypes(global::CSharp.HasVirtualTakesReturnsProblematicTypes _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasVirtualTakesReturnsProblematicTypes");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasVirtualTakesReturnsProblematicTypes __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasVirtualTakesReturnsProblematicTypes.__Internal*) __Instance)->vfptr_HasVirtualTakesReturnsProblematicTypes = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual string VirtualTakesAndReturnsString(string c)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___VirtualTakesAndReturnsString_0Delegate = (global::CSharp.Delegates.Func_string_IntPtr_string) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_string_IntPtr_string));
            var __ret = ___VirtualTakesAndReturnsString_0Delegate((__Instance + __PointerAdjustment), c);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public string CallsVirtualToReturnString(string c)
        {
            var __ret = __Internal.CallsVirtualToReturnString_0((__Instance + __PointerAdjustment), c);
            return Marshal.PtrToStringAnsi(__ret);
        }

        public virtual bool VirtualTakesAndReturnsBool(bool b)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
            var ___VirtualTakesAndReturnsBool_0Delegate = (global::CSharp.Delegates.Func_bool_IntPtr_bool) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_bool_IntPtr_bool));
            var __ret = ___VirtualTakesAndReturnsBool_0Delegate((__Instance + __PointerAdjustment), b ? (sbyte)1: (sbyte)0);
            return __ret;
        }

        public bool CallsVirtualToReturnBool(bool b)
        {
            var __ret = __Internal.CallsVirtualToReturnBool_0((__Instance + __PointerAdjustment), b ? (sbyte)1: (sbyte)0);
            return __ret;
        }

        #region Virtual table interop

        // char* virtualTakesAndReturnsString(const char* c)
        private static global::CSharp.Delegates.Func_string_IntPtr_string _VirtualTakesAndReturnsString_0DelegateInstance;

        private static global::System.IntPtr _VirtualTakesAndReturnsString_0DelegateHook(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string c)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasVirtualTakesReturnsProblematicTypes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VirtualTakesAndReturnsString((string) c);
            return Marshal.StringToHGlobalAnsi(__ret);
        }

        // bool virtualTakesAndReturnsBool(bool b)
        private static global::CSharp.Delegates.Func_bool_IntPtr_bool _VirtualTakesAndReturnsBool_0DelegateInstance;

        private static bool _VirtualTakesAndReturnsBool_0DelegateHook(global::System.IntPtr instance, sbyte b)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasVirtualTakesReturnsProblematicTypes) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.VirtualTakesAndReturnsBool(b != 0);
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _VirtualTakesAndReturnsString_0DelegateInstance += _VirtualTakesAndReturnsString_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_VirtualTakesAndReturnsString_0DelegateInstance).ToPointer();
                _VirtualTakesAndReturnsBool_0DelegateInstance += _VirtualTakesAndReturnsBool_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_VirtualTakesAndReturnsBool_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                *(void**) (vfptr0 + 4) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class TestString : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr unicodeConst;

            [FieldOffset(4)]
            public global::System.IntPtr unicode;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestString@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TestString@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1TestString@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestString> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TestString>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TestString __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TestString(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TestString __CreateInstance(global::CSharp.TestString.__Internal native, bool skipVTables = false)
        {
            return new TestString(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TestString.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TestString.__Internal));
            *(global::CSharp.TestString.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TestString(global::CSharp.TestString.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TestString(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TestString()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TestString(global::CSharp.TestString _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TestString.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TestString.__Internal*) __Instance) = *((global::CSharp.TestString.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TestString __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public string UnicodeConst
        {
            get
            {
                return Marshal.PtrToStringUni(((global::CSharp.TestString.__Internal*) __Instance)->unicodeConst);
            }

            set
            {
                ((global::CSharp.TestString.__Internal*) __Instance)->unicodeConst = Marshal.StringToHGlobalAnsi(value);
            }
        }

        public char* Unicode
        {
            get
            {
                return (char*) ((global::CSharp.TestString.__Internal*) __Instance)->unicode;
            }

            set
            {
                ((global::CSharp.TestString.__Internal*) __Instance)->unicode = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe abstract partial class PrimaryBaseWithAbstractWithDefaultArg : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_PrimaryBaseWithAbstractWithDefaultArg;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0PrimaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0PrimaryBaseWithAbstractWithDefaultArg@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1PrimaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.PrimaryBaseWithAbstractWithDefaultArg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.PrimaryBaseWithAbstractWithDefaultArg>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.PrimaryBaseWithAbstractWithDefaultArg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new PrimaryBaseWithAbstractWithDefaultArgInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.PrimaryBaseWithAbstractWithDefaultArg __CreateInstance(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
        {
            return new PrimaryBaseWithAbstractWithDefaultArgInternal(native, skipVTables);
        }

        protected PrimaryBaseWithAbstractWithDefaultArg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected PrimaryBaseWithAbstractWithDefaultArg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.PrimaryBaseWithAbstractWithDefaultArg");
        }

        protected PrimaryBaseWithAbstractWithDefaultArg(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.PrimaryBaseWithAbstractWithDefaultArg");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.PrimaryBaseWithAbstractWithDefaultArg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal*) __Instance)->vfptr_PrimaryBaseWithAbstractWithDefaultArg = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract void AbstractWithNoDefaultArg(global::CSharp.Foo foo);

        #region Virtual table interop

        // void abstractWithNoDefaultArg(const Foo& foo) = 0
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr _AbstractWithNoDefaultArg_0DelegateInstance;

        private static void _AbstractWithNoDefaultArg_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.PrimaryBaseWithAbstractWithDefaultArg) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[foo];
            else __result0 = global::CSharp.Foo.__CreateInstance(foo);
            __target.AbstractWithNoDefaultArg(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _AbstractWithNoDefaultArg_0DelegateInstance += _AbstractWithNoDefaultArg_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AbstractWithNoDefaultArg_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe abstract partial class SecondaryBaseWithAbstractWithDefaultArg : global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_SecondaryBaseWithAbstractWithDefaultArg;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SecondaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0SecondaryBaseWithAbstractWithDefaultArg@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1SecondaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.SecondaryBaseWithAbstractWithDefaultArg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SecondaryBaseWithAbstractWithDefaultArgInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.SecondaryBaseWithAbstractWithDefaultArg __CreateInstance(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
        {
            return new SecondaryBaseWithAbstractWithDefaultArgInternal(native, skipVTables);
        }

        protected SecondaryBaseWithAbstractWithDefaultArg(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        protected SecondaryBaseWithAbstractWithDefaultArg()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.SecondaryBaseWithAbstractWithDefaultArg");
        }

        protected SecondaryBaseWithAbstractWithDefaultArg(global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToSecondaryBaseWithAbstractWithDefaultArg;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.SecondaryBaseWithAbstractWithDefaultArg");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal*) __Instance)->vfptr_SecondaryBaseWithAbstractWithDefaultArg = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract void Abstract(global::CSharp.Foo foo);

        public abstract void Abstract();

        public global::System.IntPtr __PointerToSecondaryBaseWithAbstractWithDefaultArg
        {
            get
            {
                return __Instance + 0;
            }
        }

        #region Virtual table interop

        // void abstract(const Foo& foo = Foo()) = 0
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr _Abstract_0DelegateInstance;

        private static void _Abstract_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.SecondaryBaseWithAbstractWithDefaultArg) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[foo];
            else __result0 = global::CSharp.Foo.__CreateInstance(foo);
            __target.Abstract(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _Abstract_0DelegateInstance += _Abstract_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_Abstract_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasSecondaryBaseWithAbstractWithDefaultArg : global::CSharp.PrimaryBaseWithAbstractWithDefaultArg, global::CSharp.ISecondaryBaseWithAbstractWithDefaultArg, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_PrimaryBaseWithAbstractWithDefaultArg;

            [FieldOffset(4)]
            public global::System.IntPtr vfptr_SecondaryBaseWithAbstractWithDefaultArg;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSecondaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasSecondaryBaseWithAbstractWithDefaultArg@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasSecondaryBaseWithAbstractWithDefaultArg@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        internal static new global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasSecondaryBaseWithAbstractWithDefaultArg(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg __CreateInstance(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
        {
            return new HasSecondaryBaseWithAbstractWithDefaultArg(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal));
            global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasSecondaryBaseWithAbstractWithDefaultArg(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasSecondaryBaseWithAbstractWithDefaultArg(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };
        }

        public HasSecondaryBaseWithAbstractWithDefaultArg()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasSecondaryBaseWithAbstractWithDefaultArg");
        }

        public HasSecondaryBaseWithAbstractWithDefaultArg(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasSecondaryBaseWithAbstractWithDefaultArg");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.PrimaryBaseWithAbstractWithDefaultArg __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal*) __Instance)->vfptr_PrimaryBaseWithAbstractWithDefaultArg = new global::System.IntPtr(__OriginalVTables[0]);
            ((global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg.__Internal*) __Instance)->vfptr_SecondaryBaseWithAbstractWithDefaultArg = new global::System.IntPtr(__OriginalVTables[1]);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void Abstract(global::CSharp.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[1] + 0 * 4);
            var ___Abstract_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            ___Abstract_0Delegate((__Instance + 4), __arg0);
        }

        public override void AbstractWithNoDefaultArg(global::CSharp.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___AbstractWithNoDefaultArg_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            ___AbstractWithNoDefaultArg_0Delegate((__Instance + __PointerAdjustment), __arg0);
        }

        public virtual void Abstract()
        {
            Abstract(new global::CSharp.Foo(null));
        }

        public global::System.IntPtr __PointerToSecondaryBaseWithAbstractWithDefaultArg
        {
            get
            {
                return __Instance + 4;
            }
        }

        #region Virtual table interop

        // void abstractWithNoDefaultArg(const Foo& foo = Foo())
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr _AbstractWithNoDefaultArg_0DelegateInstance;

        private static void _AbstractWithNoDefaultArg_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[foo];
            else __result0 = global::CSharp.Foo.__CreateInstance(foo);
            __target.AbstractWithNoDefaultArg(__result0);
        }

        // void abstract(const Foo& foo = Foo())
        private static global::CSharp.Delegates.Action_IntPtr_IntPtr _Abstract_0DelegateInstance;

        private static void _Abstract_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr foo)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasSecondaryBaseWithAbstractWithDefaultArg) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            global::CSharp.Foo __result0;
            if (foo == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(foo))
                __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[foo];
            else __result0 = global::CSharp.Foo.__CreateInstance(foo);
            __target.Abstract(__result0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _AbstractWithNoDefaultArg_0DelegateInstance += _AbstractWithNoDefaultArg_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_AbstractWithNoDefaultArg_0DelegateInstance).ToPointer();
                _Abstract_0DelegateInstance += _Abstract_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Abstract_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[2];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
                var vfptr1 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[1] = vfptr1.ToPointer();
                *(void**) (vfptr1 + 0) = _Thunks[1];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
            *(void**) (__Instance + 4) = __ManagedVTables[1];
        }

        #endregion
    }

    public unsafe partial class MissingObjectOnVirtualCallSecondaryBase : global::CSharp.IMissingObjectOnVirtualCallSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MissingObjectOnVirtualCallSecondaryBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MissingObjectOnVirtualCallSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MissingObjectOnVirtualCallSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMissingObjectOnVirtualCallSecondaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IMissingObjectOnVirtualCallSecondaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MissingObjectOnVirtualCallSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MissingObjectOnVirtualCallSecondaryBase(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MissingObjectOnVirtualCallSecondaryBase __CreateInstance(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new MissingObjectOnVirtualCallSecondaryBase(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal));
            global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MissingObjectOnVirtualCallSecondaryBase(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MissingObjectOnVirtualCallSecondaryBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MissingObjectOnVirtualCallSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.MissingObjectOnVirtualCallSecondaryBase");
        }

        public MissingObjectOnVirtualCallSecondaryBase(global::CSharp.IMissingObjectOnVirtualCallSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToMissingObjectOnVirtualCallSecondaryBase;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MissingObjectOnVirtualCallSecondaryBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IMissingObjectOnVirtualCallSecondaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.MissingObjectOnVirtualCallSecondaryBase.__Internal*) __Instance)->vfptr_MissingObjectOnVirtualCallSecondaryBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr __PointerToMissingObjectOnVirtualCallSecondaryBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public virtual int F
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___F_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___F_0Delegate((__Instance));
                return __ret;
            }
        }

        #region Virtual table interop

        // int f()
        private static global::CSharp.Delegates.Func_int_IntPtr _F_0DelegateInstance;

        private static int _F_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MissingObjectOnVirtualCallSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.F;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _F_0DelegateInstance += _F_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_F_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class MissingObjectOnVirtualCall : global::CSharp.HasVirtualDtor1, global::CSharp.IMissingObjectOnVirtualCallSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasVirtualDtor1;

            [FieldOffset(4)]
            public int testField;

            [FieldOffset(8)]
            public global::System.IntPtr vfptr_MissingObjectOnVirtualCallSecondaryBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MissingObjectOnVirtualCall@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MissingObjectOnVirtualCall@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.MissingObjectOnVirtualCall __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MissingObjectOnVirtualCall(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MissingObjectOnVirtualCall __CreateInstance(global::CSharp.MissingObjectOnVirtualCall.__Internal native, bool skipVTables = false)
        {
            return new MissingObjectOnVirtualCall(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MissingObjectOnVirtualCall.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCall.__Internal));
            global::CSharp.MissingObjectOnVirtualCall.__Internal.cctor_2(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MissingObjectOnVirtualCall(global::CSharp.MissingObjectOnVirtualCall.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MissingObjectOnVirtualCall(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };
            else
                SetupVTables(true);
        }

        public MissingObjectOnVirtualCall()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCall.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.MissingObjectOnVirtualCall");
        }

        public MissingObjectOnVirtualCall(global::CSharp.MissingObjectOnVirtualCall _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MissingObjectOnVirtualCall.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MissingObjectOnVirtualCall");
        }

        public global::System.IntPtr __PointerToMissingObjectOnVirtualCallSecondaryBase
        {
            get
            {
                return __Instance + 8;
            }
        }

        public virtual int F
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[1] + 0 * 4);
                var ___F_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___F_0Delegate((__Instance + 8));
                return __ret;
            }
        }

        #region Virtual table interop

        // MissingObjectOnVirtualCall
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MissingObjectOnVirtualCall) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int f()
        private static global::CSharp.Delegates.Func_int_IntPtr _F_0DelegateInstance;

        private static int _F_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MissingObjectOnVirtualCall) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.F;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 8) };

            if (_Thunks == null)
            {
                _Thunks = new void*[2];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _F_0DelegateInstance += _F_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_F_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    var vfptr1 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = *(void**) (new IntPtr(*(void**) __Instance) + 8 + 0);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 8) = __ManagedVTablesDtorOnly[1];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    var vfptr1 = Marshal.AllocHGlobal(1 * 4);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = _Thunks[1];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 8) = __ManagedVTables[1];
            }
        }

        #endregion
    }

    public unsafe partial class HasMissingObjectOnVirtualCall : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr stackOverflowOnVirtualCall;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasMissingObjectOnVirtualCall@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasMissingObjectOnVirtualCall@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?makeMissingObjectOnVirtualCall@HasMissingObjectOnVirtualCall@@QAEHXZ")]
            internal static extern int MakeMissingObjectOnVirtualCall_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?setMissingObjectOnVirtualCall@HasMissingObjectOnVirtualCall@@QAEXPAVMissingObjectOnVirtualCall@@@Z")]
            internal static extern void SetMissingObjectOnVirtualCall_0(global::System.IntPtr instance, global::System.IntPtr value);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasMissingObjectOnVirtualCall> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasMissingObjectOnVirtualCall>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasMissingObjectOnVirtualCall __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasMissingObjectOnVirtualCall(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasMissingObjectOnVirtualCall __CreateInstance(global::CSharp.HasMissingObjectOnVirtualCall.__Internal native, bool skipVTables = false)
        {
            return new HasMissingObjectOnVirtualCall(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasMissingObjectOnVirtualCall.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasMissingObjectOnVirtualCall.__Internal));
            *(global::CSharp.HasMissingObjectOnVirtualCall.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HasMissingObjectOnVirtualCall(global::CSharp.HasMissingObjectOnVirtualCall.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasMissingObjectOnVirtualCall(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HasMissingObjectOnVirtualCall()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasMissingObjectOnVirtualCall.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public HasMissingObjectOnVirtualCall(global::CSharp.HasMissingObjectOnVirtualCall _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasMissingObjectOnVirtualCall.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.HasMissingObjectOnVirtualCall.__Internal*) __Instance) = *((global::CSharp.HasMissingObjectOnVirtualCall.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasMissingObjectOnVirtualCall __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int MakeMissingObjectOnVirtualCall()
        {
            var __ret = __Internal.MakeMissingObjectOnVirtualCall_0((__Instance + __PointerAdjustment));
            return __ret;
        }

        public void SetMissingObjectOnVirtualCall(global::CSharp.MissingObjectOnVirtualCall value)
        {
            var __arg0 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            __Internal.SetMissingObjectOnVirtualCall_0((__Instance + __PointerAdjustment), __arg0);
        }
    }

    public unsafe abstract partial class AbstractPrimaryBase : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractPrimaryBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractPrimaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractPrimaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1AbstractPrimaryBase@@UAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractPrimaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.AbstractPrimaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.AbstractPrimaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractPrimaryBaseInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.AbstractPrimaryBase __CreateInstance(global::CSharp.AbstractPrimaryBase.__Internal native, bool skipVTables = false)
        {
            return new AbstractPrimaryBaseInternal(native, skipVTables);
        }

        protected AbstractPrimaryBase(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected AbstractPrimaryBase()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.AbstractPrimaryBase");
        }

        protected AbstractPrimaryBase(global::CSharp.AbstractPrimaryBase _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractPrimaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.AbstractPrimaryBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.AbstractPrimaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.AbstractPrimaryBase.__Internal*) __Instance)->vfptr_AbstractPrimaryBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                if (__slot != null)
                {
                    var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                    ___dtor_0Delegate((__Instance + __PointerAdjustment), 0);
                }
                else
                    __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public abstract int AbstractInPrimaryBase
        {
            get;
        }

        public abstract int AbstractReturnsFieldInPrimaryBase
        {
            get;
        }

        #region Virtual table interop

        // virtual ~AbstractPrimaryBase()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int abstractInPrimaryBase() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractInPrimaryBase_0DelegateInstance;

        private static int _AbstractInPrimaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractInPrimaryBase;
            return __ret;
        }

        // int abstractReturnsFieldInPrimaryBase() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractReturnsFieldInPrimaryBase_0DelegateInstance;

        private static int _AbstractReturnsFieldInPrimaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractPrimaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractReturnsFieldInPrimaryBase;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _AbstractInPrimaryBase_0DelegateInstance += _AbstractInPrimaryBase_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AbstractInPrimaryBase_0DelegateInstance).ToPointer();
                _AbstractReturnsFieldInPrimaryBase_0DelegateInstance += _AbstractReturnsFieldInPrimaryBase_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AbstractReturnsFieldInPrimaryBase_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                    *(void**) (vfptr0 + 8) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe abstract partial class AbstractSecondaryBase : global::CSharp.IAbstractSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractSecondaryBase;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractSecondaryBase@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0AbstractSecondaryBase@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1AbstractSecondaryBase@@UAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IAbstractSecondaryBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.IAbstractSecondaryBase>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.AbstractSecondaryBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new AbstractSecondaryBaseInternal(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.AbstractSecondaryBase __CreateInstance(global::CSharp.AbstractSecondaryBase.__Internal native, bool skipVTables = false)
        {
            return new AbstractSecondaryBaseInternal(native, skipVTables);
        }

        protected AbstractSecondaryBase(void* native, bool skipVTables = false)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
            else
                SetupVTables(true);
        }

        protected AbstractSecondaryBase()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance));
            SetupVTables(GetType().FullName == "CSharp.AbstractSecondaryBase");
        }

        protected AbstractSecondaryBase(global::CSharp.IAbstractSecondaryBase _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractSecondaryBase.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__PointerToAbstractSecondaryBase;
            __Internal.cctor_1((__Instance), __arg0);
            SetupVTables(GetType().FullName == "CSharp.AbstractSecondaryBase");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.IAbstractSecondaryBase __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.AbstractSecondaryBase.__Internal*) __Instance)->vfptr_AbstractSecondaryBase = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                if (__slot != null)
                {
                    var ___dtor_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                    ___dtor_0Delegate((__Instance), 0);
                }
                else
                    __Internal.dtor_0((__Instance), 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public global::System.IntPtr __PointerToAbstractSecondaryBase
        {
            get
            {
                return __Instance + 0;
            }
        }

        public abstract int AbstractInSecondaryBase
        {
            get;
        }

        public abstract int AbstractReturnsFieldInSecondaryBase
        {
            get;
        }

        #region Virtual table interop

        // virtual ~AbstractSecondaryBase()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int abstractInSecondaryBase() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractInSecondaryBase_0DelegateInstance;

        private static int _AbstractInSecondaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractInSecondaryBase;
            return __ret;
        }

        // int abstractReturnsFieldInSecondaryBase() = 0
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractReturnsFieldInSecondaryBase_0DelegateInstance;

        private static int _AbstractReturnsFieldInSecondaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.AbstractSecondaryBase) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractReturnsFieldInSecondaryBase;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (_Thunks == null)
            {
                _Thunks = new void*[3];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _AbstractInSecondaryBase_0DelegateInstance += _AbstractInSecondaryBase_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AbstractInSecondaryBase_0DelegateInstance).ToPointer();
                _AbstractReturnsFieldInSecondaryBase_0DelegateInstance += _AbstractReturnsFieldInSecondaryBase_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AbstractReturnsFieldInSecondaryBase_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                    *(void**) (vfptr0 + 8) = _Thunks[2];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
            }
        }

        #endregion
    }

    public unsafe partial class ImplementsAbstractsFromPrimaryAndSecondary : global::CSharp.AbstractPrimaryBase, global::CSharp.IAbstractSecondaryBase, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_AbstractPrimaryBase;

            [FieldOffset(4)]
            public global::System.IntPtr vfptr_AbstractSecondaryBase;

            [FieldOffset(8)]
            public int field;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ImplementsAbstractsFromPrimaryAndSecondary@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ImplementsAbstractsFromPrimaryAndSecondary@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        internal static new global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ImplementsAbstractsFromPrimaryAndSecondary(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary __CreateInstance(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal native, bool skipVTables = false)
        {
            return new ImplementsAbstractsFromPrimaryAndSecondary(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal));
            global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private ImplementsAbstractsFromPrimaryAndSecondary(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImplementsAbstractsFromPrimaryAndSecondary(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            if (skipVTables)
                __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };
            else
                SetupVTables(true);
        }

        public ImplementsAbstractsFromPrimaryAndSecondary()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.ImplementsAbstractsFromPrimaryAndSecondary");
        }

        public ImplementsAbstractsFromPrimaryAndSecondary(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.ImplementsAbstractsFromPrimaryAndSecondary");
        }

        public global::System.IntPtr __PointerToAbstractSecondaryBase
        {
            get
            {
                return __Instance + 4;
            }
        }

        public override int AbstractInPrimaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___AbstractInPrimaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractInPrimaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public virtual int AbstractInSecondaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[1] + 1 * 4);
                var ___AbstractInSecondaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractInSecondaryBase_0Delegate((__Instance + 4));
                return __ret;
            }
        }

        public override int AbstractReturnsFieldInPrimaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                var ___AbstractReturnsFieldInPrimaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractReturnsFieldInPrimaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public virtual int AbstractReturnsFieldInSecondaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[1] + 2 * 4);
                var ___AbstractReturnsFieldInSecondaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractReturnsFieldInSecondaryBase_0Delegate((__Instance + 4));
                return __ret;
            }
        }

        #region Virtual table interop

        // virtual ~ImplementsAbstractsFromPrimaryAndSecondary()
        private static global::CSharp.Delegates.Action_IntPtr_int _dtor_0DelegateInstance;

        private static void _dtor_0DelegateHook(global::System.IntPtr instance, int delete)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.Dispose(true);
        }

        // int abstractInPrimaryBase()
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractInPrimaryBase_0DelegateInstance;

        private static int _AbstractInPrimaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractInPrimaryBase;
            return __ret;
        }

        // int abstractReturnsFieldInPrimaryBase()
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractReturnsFieldInPrimaryBase_0DelegateInstance;

        private static int _AbstractReturnsFieldInPrimaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractReturnsFieldInPrimaryBase;
            return __ret;
        }

        // int abstractInSecondaryBase()
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractInSecondaryBase_0DelegateInstance;

        private static int _AbstractInSecondaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractInSecondaryBase;
            return __ret;
        }

        // int abstractReturnsFieldInSecondaryBase()
        private static global::CSharp.Delegates.Func_int_IntPtr _AbstractReturnsFieldInSecondaryBase_0DelegateInstance;

        private static int _AbstractReturnsFieldInSecondaryBase_0DelegateHook(global::System.IntPtr instance)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.ImplementsAbstractsFromPrimaryAndSecondary) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            var __ret = __target.AbstractReturnsFieldInSecondaryBase;
            return __ret;
        }

        private static void*[] __ManagedVTables;
        private static void*[] __ManagedVTablesDtorOnly;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0), *(void**) (__Instance + 4) };

            if (_Thunks == null)
            {
                _Thunks = new void*[5];
                _dtor_0DelegateInstance += _dtor_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                _AbstractInPrimaryBase_0DelegateInstance += _AbstractInPrimaryBase_0DelegateHook;
                _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AbstractInPrimaryBase_0DelegateInstance).ToPointer();
                _AbstractReturnsFieldInPrimaryBase_0DelegateInstance += _AbstractReturnsFieldInPrimaryBase_0DelegateHook;
                _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_AbstractReturnsFieldInPrimaryBase_0DelegateInstance).ToPointer();
                _AbstractInSecondaryBase_0DelegateInstance += _AbstractInSecondaryBase_0DelegateHook;
                _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_AbstractInSecondaryBase_0DelegateInstance).ToPointer();
                _AbstractReturnsFieldInSecondaryBase_0DelegateInstance += _AbstractReturnsFieldInSecondaryBase_0DelegateHook;
                _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_AbstractReturnsFieldInSecondaryBase_0DelegateInstance).ToPointer();
            }

            if (destructorOnly)
            {
                if (__ManagedVTablesDtorOnly == null)
                {
                    __ManagedVTablesDtorOnly = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTablesDtorOnly[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 4);
                    *(void**) (vfptr0 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 0 + 8);
                    var vfptr1 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTablesDtorOnly[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = _Thunks[0];
                    *(void**) (vfptr1 + 4) = *(void**) (new IntPtr(*(void**) __Instance) + 4 + 4);
                    *(void**) (vfptr1 + 8) = *(void**) (new IntPtr(*(void**) __Instance) + 4 + 8);
                }

                *(void**) (__Instance + 0) = __ManagedVTablesDtorOnly[0];
                *(void**) (__Instance + 4) = __ManagedVTablesDtorOnly[1];
            }
            else
            {
                if (__ManagedVTables == null)
                {
                    __ManagedVTables = new void*[2];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTables[0] = vfptr0.ToPointer();
                    *(void**) (vfptr0 + 0) = _Thunks[0];
                    *(void**) (vfptr0 + 4) = _Thunks[1];
                    *(void**) (vfptr0 + 8) = _Thunks[2];
                    var vfptr1 = Marshal.AllocHGlobal(3 * 4);
                    __ManagedVTables[1] = vfptr1.ToPointer();
                    *(void**) (vfptr1 + 0) = _Thunks[0];
                    *(void**) (vfptr1 + 4) = _Thunks[3];
                    *(void**) (vfptr1 + 8) = _Thunks[4];
                }

                *(void**) (__Instance + 0) = __ManagedVTables[0];
                *(void**) (__Instance + 4) = __ManagedVTables[1];
            }
        }

        #endregion
    }

    public unsafe partial class HasBaseSetter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasBaseSetter;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasBaseSetter@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasBaseSetter@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasBaseSetter@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasBaseSetter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.HasBaseSetter>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.HasBaseSetter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasBaseSetter(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasBaseSetter __CreateInstance(global::CSharp.HasBaseSetter.__Internal native, bool skipVTables = false)
        {
            return new HasBaseSetter(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasBaseSetter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasBaseSetter.__Internal));
            global::CSharp.HasBaseSetter.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasBaseSetter(global::CSharp.HasBaseSetter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasBaseSetter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasBaseSetter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasBaseSetter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasBaseSetter");
        }

        public HasBaseSetter(global::CSharp.HasBaseSetter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasBaseSetter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasBaseSetter");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.HasBaseSetter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasBaseSetter.__Internal*) __Instance)->vfptr_HasBaseSetter = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void SetBaseSetter(int value)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___SetBaseSetter_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
            ___SetBaseSetter_0Delegate((__Instance + __PointerAdjustment), value);
        }

        #region Virtual table interop

        // void setBaseSetter(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetBaseSetter_0DelegateInstance;

        private static void _SetBaseSetter_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasBaseSetter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.SetBaseSetter(value);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _SetBaseSetter_0DelegateInstance += _SetBaseSetter_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetBaseSetter_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class HasGetterAndOverriddenSetter : global::CSharp.HasBaseSetter, IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public new partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_HasBaseSetter;

            [FieldOffset(4)]
            public int field;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasGetterAndOverriddenSetter@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0HasGetterAndOverriddenSetter@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??1HasGetterAndOverriddenSetter@@QAE@XZ")]
            internal static extern void dtor_0(global::System.IntPtr instance, int delete);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="?baseSetter@HasGetterAndOverriddenSetter@@QAEHXZ")]
            internal static extern int BaseSetter_0(global::System.IntPtr instance);
        }

        internal static new global::CSharp.HasGetterAndOverriddenSetter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new HasGetterAndOverriddenSetter(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.HasGetterAndOverriddenSetter __CreateInstance(global::CSharp.HasGetterAndOverriddenSetter.__Internal native, bool skipVTables = false)
        {
            return new HasGetterAndOverriddenSetter(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.HasGetterAndOverriddenSetter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasGetterAndOverriddenSetter.__Internal));
            global::CSharp.HasGetterAndOverriddenSetter.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private HasGetterAndOverriddenSetter(global::CSharp.HasGetterAndOverriddenSetter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HasGetterAndOverriddenSetter(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public HasGetterAndOverriddenSetter()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasGetterAndOverriddenSetter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.HasGetterAndOverriddenSetter");
        }

        public HasGetterAndOverriddenSetter(global::CSharp.HasGetterAndOverriddenSetter _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.HasGetterAndOverriddenSetter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.HasGetterAndOverriddenSetter");
        }

        public override void Dispose(bool disposing)
        {
            global::CSharp.HasBaseSetter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.HasGetterAndOverriddenSetter.__Internal*) __Instance)->vfptr_HasBaseSetter = new global::System.IntPtr(__OriginalVTables[0]);
            if (disposing)
                __Internal.dtor_0((__Instance + __PointerAdjustment), 0);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public override void SetBaseSetter(int value)
        {
            base.SetBaseSetter(value);
        }

        protected int Field
        {
            get
            {
                return ((global::CSharp.HasGetterAndOverriddenSetter.__Internal*) __Instance)->field;
            }

            set
            {
                ((global::CSharp.HasGetterAndOverriddenSetter.__Internal*) __Instance)->field = value;
            }
        }

        public int BaseSetter
        {
            get
            {
                var __ret = __Internal.BaseSetter_0((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        #region Virtual table interop

        // void setBaseSetter(int value)
        private static global::CSharp.Delegates.Action_IntPtr_int _SetBaseSetter_0DelegateInstance;

        private static void _SetBaseSetter_0DelegateHook(global::System.IntPtr instance, int value)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.HasGetterAndOverriddenSetter) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.SetBaseSetter(value);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _SetBaseSetter_0DelegateInstance += _SetBaseSetter_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_SetBaseSetter_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class ForwardDeclaredStruct : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int i;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ForwardDeclaredStruct@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0ForwardDeclaredStruct@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ForwardDeclaredStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.ForwardDeclaredStruct>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.ForwardDeclaredStruct __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new ForwardDeclaredStruct(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.ForwardDeclaredStruct __CreateInstance(global::CSharp.ForwardDeclaredStruct.__Internal native, bool skipVTables = false)
        {
            return new ForwardDeclaredStruct(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.ForwardDeclaredStruct.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardDeclaredStruct.__Internal));
            *(global::CSharp.ForwardDeclaredStruct.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ForwardDeclaredStruct(global::CSharp.ForwardDeclaredStruct.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ForwardDeclaredStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ForwardDeclaredStruct()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardDeclaredStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public ForwardDeclaredStruct(global::CSharp.ForwardDeclaredStruct _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.ForwardDeclaredStruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.ForwardDeclaredStruct.__Internal*) __Instance) = *((global::CSharp.ForwardDeclaredStruct.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.ForwardDeclaredStruct __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int I
        {
            get
            {
                return ((global::CSharp.ForwardDeclaredStruct.__Internal*) __Instance)->i;
            }

            set
            {
                ((global::CSharp.ForwardDeclaredStruct.__Internal*) __Instance)->i = value;
            }
        }
    }

    public unsafe partial struct StructTestArrayTypeFromTypedef
    {
        [StructLayout(LayoutKind.Explicit, Size = 13)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public fixed sbyte arr[13];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0StructTestArrayTypeFromTypedef@@QAE@ABU0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        private StructTestArrayTypeFromTypedef.__Internal __instance;
        internal StructTestArrayTypeFromTypedef.__Internal __Instance { get { return __instance; } }

        internal static global::CSharp.StructTestArrayTypeFromTypedef __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new StructTestArrayTypeFromTypedef(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.StructTestArrayTypeFromTypedef __CreateInstance(global::CSharp.StructTestArrayTypeFromTypedef.__Internal native, bool skipVTables = false)
        {
            return new StructTestArrayTypeFromTypedef(native, skipVTables);
        }

        private StructTestArrayTypeFromTypedef(global::CSharp.StructTestArrayTypeFromTypedef.__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private StructTestArrayTypeFromTypedef(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::CSharp.StructTestArrayTypeFromTypedef.__Internal*) native;
        }

        public StructTestArrayTypeFromTypedef(global::CSharp.StructTestArrayTypeFromTypedef _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new global::System.IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
            }
        }

        public char[] Arr
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.arr)
                {
                    char[] __value = null;
                    if (__arrPtr != null)
                    {
                        __value = new char[13];
                        for (int i = 0; i < 13; i++)
                            __value[i] = global::System.Convert.ToChar(__arrPtr[i]);
                    }
                    return __value;
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.arr)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 13; i++)
                            __arrPtr[i] = global::System.Convert.ToSByte(value[i]);
                    }
                }
            }
        }
    }

    public unsafe partial class MyBaseClass : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr vfptr_MyBaseClass;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MyBaseClass@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0MyBaseClass@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MyBaseClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.MyBaseClass>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.MyBaseClass __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new MyBaseClass(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.MyBaseClass __CreateInstance(global::CSharp.MyBaseClass.__Internal native, bool skipVTables = false)
        {
            return new MyBaseClass(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.MyBaseClass.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.MyBaseClass.__Internal));
            global::CSharp.MyBaseClass.__Internal.cctor_1(ret, new global::System.IntPtr(&native));
            return ret.ToPointer();
        }

        private MyBaseClass(global::CSharp.MyBaseClass.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MyBaseClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public MyBaseClass()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MyBaseClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
            SetupVTables(GetType().FullName == "CSharp.MyBaseClass");
        }

        public MyBaseClass(global::CSharp.MyBaseClass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.MyBaseClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
            SetupVTables(GetType().FullName == "CSharp.MyBaseClass");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.MyBaseClass __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            ((global::CSharp.MyBaseClass.__Internal*) __Instance)->vfptr_MyBaseClass = new global::System.IntPtr(__OriginalVTables[0]);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public virtual void OnSomthingHappen(bool iAmBool)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___OnSomthingHappen_0Delegate = (global::CSharp.Delegates.Action_IntPtr_bool) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_bool));
            ___OnSomthingHappen_0Delegate((__Instance + __PointerAdjustment), iAmBool ? (sbyte)1: (sbyte)0);
        }

        #region Virtual table interop

        // void OnSomthingHappen(bool iAmBool) {}
        private static global::CSharp.Delegates.Action_IntPtr_bool _OnSomthingHappen_0DelegateInstance;

        private static void _OnSomthingHappen_0DelegateHook(global::System.IntPtr instance, sbyte iAmBool)
        {
            if (!NativeToManagedMap.ContainsKey(instance))
                throw new global::System.Exception("No managed instance was found");

            var __target = (global::CSharp.MyBaseClass) NativeToManagedMap[instance];
            if (__target.__ownsNativeInstance)
                __target.SetupVTables();
            __target.OnSomthingHappen(iAmBool != 0);
        }

        private static void*[] __ManagedVTables;
        private static void*[] _Thunks;

        private void SetupVTables(bool destructorOnly = false)
        {
            if (__OriginalVTables != null)
                return;
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };

            if (destructorOnly)
                return;
            if (_Thunks == null)
            {
                _Thunks = new void*[1];
                _OnSomthingHappen_0DelegateInstance += _OnSomthingHappen_0DelegateHook;
                _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_OnSomthingHappen_0DelegateInstance).ToPointer();
            }

            if (__ManagedVTables == null)
            {
                __ManagedVTables = new void*[1];
                var vfptr0 = Marshal.AllocHGlobal(1 * 4);
                __ManagedVTables[0] = vfptr0.ToPointer();
                *(void**) (vfptr0 + 0) = _Thunks[0];
            }

            *(void**) (__Instance + 0) = __ManagedVTables[0];
        }

        #endregion
    }

    public unsafe partial class AbstractProprietorInternal : global::CSharp.AbstractProprietor, IDisposable
    {
        private static void* __CopyValue(global::CSharp.AbstractProprietor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractProprietor.__Internal));
            *(global::CSharp.AbstractProprietor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractProprietorInternal(global::CSharp.AbstractProprietor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractProprietorInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Value
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Value_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Value_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetValue_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetValue_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        public override int Prop
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                var ___Prop_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Prop_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 3 * 4);
                var ___SetProp_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProp_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }

        public override global::CSharp.Foo Covariant
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 6 * 4);
                var ___Covariant_0Delegate = (global::CSharp.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_IntPtr_IntPtr));
                var __ret = ___Covariant_0Delegate((__Instance + __PointerAdjustment));
                global::CSharp.Foo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CSharp.Foo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CSharp.Foo) global::CSharp.Foo.NativeToManagedMap[__ret];
                else __result0 = global::CSharp.Foo.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public unsafe partial class AbstractWithPropertyInternal : global::CSharp.AbstractWithProperty, IDisposable
    {
        private static void* __CopyValue(global::CSharp.AbstractWithProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractWithProperty.__Internal));
            *(global::CSharp.AbstractWithProperty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractWithPropertyInternal(global::CSharp.AbstractWithProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractWithPropertyInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class OverridePropertyFromIndirectPrimaryBaseBaseInternal : global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase, IDisposable
    {
        private static void* __CopyValue(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal));
            *(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal OverridePropertyFromIndirectPrimaryBaseBaseInternal(global::CSharp.OverridePropertyFromIndirectPrimaryBaseBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal OverridePropertyFromIndirectPrimaryBaseBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetProperty_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProperty_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class OverridePropertyFromDirectPrimaryBaseInternal : global::CSharp.OverridePropertyFromDirectPrimaryBase, IDisposable
    {
        private static void* __CopyValue(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal));
            *(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal OverridePropertyFromDirectPrimaryBaseInternal(global::CSharp.OverridePropertyFromDirectPrimaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal OverridePropertyFromDirectPrimaryBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetProperty_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProperty_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class AbstractOverrideFromSecondaryBaseInternal : global::CSharp.AbstractOverrideFromSecondaryBase, IDisposable
    {
        private static void* __CopyValue(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal));
            *(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractOverrideFromSecondaryBaseInternal(global::CSharp.AbstractOverrideFromSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractOverrideFromSecondaryBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance));
                return __ret;
            }

            set
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___SetProperty_0Delegate = (global::CSharp.Delegates.Action_IntPtr_int) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_int));
                ___SetProperty_0Delegate((__Instance + __PointerAdjustment), value);
            }
        }
    }

    public unsafe partial class InheritsFromHasSamePropertyInDerivedAbstractTypeInternal : global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType, IDisposable
    {
        private static void* __CopyValue(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal));
            *(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal InheritsFromHasSamePropertyInDerivedAbstractTypeInternal(global::CSharp.InheritsFromHasSamePropertyInDerivedAbstractType.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal InheritsFromHasSamePropertyInDerivedAbstractTypeInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int Property
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
                var ___Property_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___Property_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class HasPrivateVirtualPropertyInternal : global::CSharp.HasPrivateVirtualProperty, IDisposable
    {
        private static void* __CopyValue(global::CSharp.HasPrivateVirtualProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasPrivateVirtualProperty.__Internal));
            *(global::CSharp.HasPrivateVirtualProperty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal HasPrivateVirtualPropertyInternal(global::CSharp.HasPrivateVirtualProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal HasPrivateVirtualPropertyInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }
    }

    public unsafe partial class HasConflictWithAbstractPropertyInternal : global::CSharp.HasConflictWithAbstractProperty, IDisposable
    {
        private static void* __CopyValue(global::CSharp.HasConflictWithAbstractProperty.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.HasConflictWithAbstractProperty.__Internal));
            *(global::CSharp.HasConflictWithAbstractProperty.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal HasConflictWithAbstractPropertyInternal(global::CSharp.HasConflictWithAbstractProperty.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal HasConflictWithAbstractPropertyInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int GetConflictWithProperty()
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___GetConflictWithProperty_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
            var __ret = ___GetConflictWithProperty_0Delegate((__Instance + __PointerAdjustment));
            return __ret;
        }
    }

    public unsafe partial class PrimaryBaseWithAbstractWithDefaultArgInternal : global::CSharp.PrimaryBaseWithAbstractWithDefaultArg, IDisposable
    {
        private static void* __CopyValue(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal));
            *(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal PrimaryBaseWithAbstractWithDefaultArgInternal(global::CSharp.PrimaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal PrimaryBaseWithAbstractWithDefaultArgInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void AbstractWithNoDefaultArg(global::CSharp.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___AbstractWithNoDefaultArg_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            ___AbstractWithNoDefaultArg_0Delegate((__Instance + __PointerAdjustment), __arg0);
        }
    }

    public unsafe partial class SecondaryBaseWithAbstractWithDefaultArgInternal : global::CSharp.SecondaryBaseWithAbstractWithDefaultArg, IDisposable
    {
        private static void* __CopyValue(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal));
            *(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal SecondaryBaseWithAbstractWithDefaultArgInternal(global::CSharp.SecondaryBaseWithAbstractWithDefaultArg.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal SecondaryBaseWithAbstractWithDefaultArgInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override void Abstract(global::CSharp.Foo foo)
        {
            var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 0 * 4);
            var ___Abstract_0Delegate = (global::CSharp.Delegates.Action_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Action_IntPtr_IntPtr));
            if (ReferenceEquals(foo, null))
                throw new global::System.ArgumentNullException("foo", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = foo.__Instance;
            ___Abstract_0Delegate((__Instance + __PointerAdjustment), __arg0);
        }

        public override void Abstract()
        {
            Abstract(new global::CSharp.Foo(null));
        }
    }

    public unsafe partial class AbstractPrimaryBaseInternal : global::CSharp.AbstractPrimaryBase, IDisposable
    {
        private static void* __CopyValue(global::CSharp.AbstractPrimaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractPrimaryBase.__Internal));
            *(global::CSharp.AbstractPrimaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractPrimaryBaseInternal(global::CSharp.AbstractPrimaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractPrimaryBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int AbstractInPrimaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___AbstractInPrimaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractInPrimaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override int AbstractReturnsFieldInPrimaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                var ___AbstractReturnsFieldInPrimaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractReturnsFieldInPrimaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial class AbstractSecondaryBaseInternal : global::CSharp.AbstractSecondaryBase, IDisposable
    {
        private static void* __CopyValue(global::CSharp.AbstractSecondaryBase.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.AbstractSecondaryBase.__Internal));
            *(global::CSharp.AbstractSecondaryBase.__Internal*) ret = native;
            return ret.ToPointer();
        }

        internal AbstractSecondaryBaseInternal(global::CSharp.AbstractSecondaryBase.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        internal AbstractSecondaryBaseInternal(void* native, bool skipVTables = false)
            : base((void*) null)
        {
            __PointerAdjustment = 0;
            __Instance = new global::System.IntPtr(native);
            __OriginalVTables = new void*[] { *(void**) (__Instance + 0) };
        }

        public override int AbstractInSecondaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 1 * 4);
                var ___AbstractInSecondaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractInSecondaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }

        public override int AbstractReturnsFieldInSecondaryBase
        {
            get
            {
                var __slot = *(void**) ((IntPtr) __OriginalVTables[0] + 2 * 4);
                var ___AbstractReturnsFieldInSecondaryBase_0Delegate = (global::CSharp.Delegates.Func_int_IntPtr) Marshal.GetDelegateForFunctionPointer(new IntPtr(__slot), typeof(global::CSharp.Delegates.Func_int_IntPtr));
                var __ret = ___AbstractReturnsFieldInSecondaryBase_0Delegate((__Instance + __PointerAdjustment));
                return __ret;
            }
        }
    }

    public unsafe partial interface IQux
    {
        void Obsolete();

        void V();

        int[] Array { get; set; }

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToQux { get; }

        global::CSharp.IQux Interface { get; set; }

        int FarAwayFunc { get; }
    }

    public unsafe partial interface IBar : global::CSharp.IQux
    {
        global::CSharp.Foo this[int i] { get; set; }

        global::System.IntPtr[] ArrayOfPrimitivePointers { get; set; }

        global::CSharp.Foo[] Foos { get; set; }

        global::System.IntPtr __PointerToBar { get; }

        int Method { get; }
    }

    public unsafe partial interface IMI_A
    {
        void V(int i = 5);

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToMI_A { get; }
    }

    public unsafe partial interface IMI_B : global::CSharp.IMI_A
    {
        global::System.IntPtr __PointerToMI_B { get; }
    }

    public unsafe partial interface ISecondaryBase
    {
        void VirtualMember();

        void function(ref bool ok);

        void function();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToSecondaryBase { get; }

        int property { get; set; }
    }

    public unsafe partial interface ITestParamToInterfacePassBaseTwo
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToTestParamToInterfacePassBaseTwo { get; }

        int M { get; set; }
    }

    public unsafe partial interface IHasProtectedVirtual
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToHasProtectedVirtual { get; }
    }

    public unsafe partial interface IOverrideFromIndirectSecondaryBaseBase
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToOverrideFromIndirectSecondaryBaseBase { get; }

        int Property { get; }
    }

    public unsafe partial interface IOverridePropertyFromIndirectPrimaryBaseBase
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToOverridePropertyFromIndirectPrimaryBaseBase { get; }

        int Property { get; set; }
    }

    public unsafe partial interface IQPaintDevice
    {
        void ChangeVTableLayout();

        int Test { get; set; }

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToQPaintDevice { get; }
    }

    public unsafe partial interface IMultipleInheritanceFieldOffsetsSecondaryBase
    {
        int Secondary { get; set; }

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToMultipleInheritanceFieldOffsetsSecondaryBase { get; }
    }

    public unsafe partial interface ISecondaryBaseWithAbstractWithDefaultArg
    {
        void Abstract(global::CSharp.Foo foo);

        void Abstract();

        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToSecondaryBaseWithAbstractWithDefaultArg { get; }
    }

    public unsafe partial interface IMissingObjectOnVirtualCallSecondaryBase
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToMissingObjectOnVirtualCallSecondaryBase { get; }

        int F { get; }
    }

    public unsafe partial interface IAbstractSecondaryBase
    {
        global::System.IntPtr __Instance { get; }

        global::System.IntPtr __PointerToAbstractSecondaryBase { get; }

        int AbstractInSecondaryBase { get; }

        int AbstractReturnsFieldInSecondaryBase { get; }
    }

    public unsafe partial class CSharp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?freeFunctionWithUnsupportedDefaultArg@@YAXVFoo@@@Z")]
            internal static extern void FreeFunctionWithUnsupportedDefaultArg_0(global::CSharp.Foo.__Internal foo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?PassConstantArrayRef@@YAHAAY01H@Z")]
            internal static extern int PassConstantArrayRef_0(global::System.IntPtr arr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?decltypeFunctionPointer@@YAXXZ")]
            internal static extern void DecltypeFunctionPointer_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?usesDecltypeFunctionPointer@@YAXP6AXXZ@Z")]
            internal static extern void UsesDecltypeFunctionPointer_0(global::System.IntPtr func);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?hasArrayOfConstChar@@YAXQBQBD@Z")]
            internal static extern void HasArrayOfConstChar_0(char** arrayOfConstChar);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?createIncompleteStruct@@YAPAUIncompleteStruct@@XZ")]
            internal static extern global::System.IntPtr CreateIncompleteStruct_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?useIncompleteStruct@@YAXPAUIncompleteStruct@@@Z")]
            internal static extern void UseIncompleteStruct_0(global::System.IntPtr a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?createDuplicateDeclaredStruct@@YAPAUDuplicateDeclaredStruct@@H@Z")]
            internal static extern global::System.IntPtr CreateDuplicateDeclaredStruct_0(int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?useDuplicateDeclaredStruct@@YAHPAUDuplicateDeclaredStruct@@@Z")]
            internal static extern int UseDuplicateDeclaredStruct_0(global::System.IntPtr s);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?createForwardDeclaredStruct@@YAPAUForwardDeclaredStruct@@H@Z")]
            internal static extern global::System.IntPtr CreateForwardDeclaredStruct_0(int i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?useForwardDeclaredStruct@@YAHPAUForwardDeclaredStruct@@@Z")]
            internal static extern int UseForwardDeclaredStruct_0(global::System.IntPtr s);
        }

        public static void FreeFunctionWithUnsupportedDefaultArg(global::CSharp.Foo foo)
        {
            var __arg0 = ReferenceEquals(foo, null) ? new global::CSharp.Foo.__Internal() : *(global::CSharp.Foo.__Internal*) foo.__Instance;
            __Internal.FreeFunctionWithUnsupportedDefaultArg_0(__arg0);
        }

        public static int PassConstantArrayRef(int[] arr)
        {
            if (arr == null || arr.Length != 2)
                throw new ArgumentOutOfRangeException("arr", "The dimensions of the provided array don't match the required size.");
            fixed (int* __ptr0 = arr)
            {
                var __arg0 = new global::System.IntPtr(__ptr0);
                var __ret = __Internal.PassConstantArrayRef_0(__arg0);
                return __ret;
            }
        }

        public static void DecltypeFunctionPointer()
        {
            __Internal.DecltypeFunctionPointer_0();
        }

        public static void UsesDecltypeFunctionPointer(global::CSharp.funcPtr func)
        {
            var __arg0 = func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(func);
            __Internal.UsesDecltypeFunctionPointer_0(__arg0);
        }

        public static void HasArrayOfConstChar(char** arrayOfConstChar)
        {
            __Internal.HasArrayOfConstChar_0(arrayOfConstChar);
        }

        public static global::CSharp.IncompleteStruct CreateIncompleteStruct()
        {
            var __ret = __Internal.CreateIncompleteStruct_0();
            global::CSharp.IncompleteStruct __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.IncompleteStruct.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.IncompleteStruct) global::CSharp.IncompleteStruct.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.IncompleteStruct.__CreateInstance(__ret);
            return __result0;
        }

        public static void UseIncompleteStruct(global::CSharp.IncompleteStruct a)
        {
            var __arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            __Internal.UseIncompleteStruct_0(__arg0);
        }

        public static global::CSharp.DuplicateDeclaredStruct CreateDuplicateDeclaredStruct(int i)
        {
            var __ret = __Internal.CreateDuplicateDeclaredStruct_0(i);
            global::CSharp.DuplicateDeclaredStruct __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.DuplicateDeclaredStruct.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.DuplicateDeclaredStruct) global::CSharp.DuplicateDeclaredStruct.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.DuplicateDeclaredStruct.__CreateInstance(__ret);
            return __result0;
        }

        public static int UseDuplicateDeclaredStruct(global::CSharp.DuplicateDeclaredStruct s)
        {
            var __arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
            var __ret = __Internal.UseDuplicateDeclaredStruct_0(__arg0);
            return __ret;
        }

        public static global::CSharp.ForwardDeclaredStruct CreateForwardDeclaredStruct(int i)
        {
            var __ret = __Internal.CreateForwardDeclaredStruct_0(i);
            global::CSharp.ForwardDeclaredStruct __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::CSharp.ForwardDeclaredStruct.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::CSharp.ForwardDeclaredStruct) global::CSharp.ForwardDeclaredStruct.NativeToManagedMap[__ret];
            else __result0 = global::CSharp.ForwardDeclaredStruct.__CreateInstance(__ret);
            return __result0;
        }

        public static int UseForwardDeclaredStruct(global::CSharp.ForwardDeclaredStruct s)
        {
            var __arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
            var __ret = __Internal.UseForwardDeclaredStruct_0(__arg0);
            return __ret;
        }

        public static void FreeFunctionWithUnsupportedDefaultArg()
        {
            FreeFunctionWithUnsupportedDefaultArg(new global::CSharp.Foo(null));
        }

        public static byte[] VariableWithFixedPrimitiveArray
        {
            get
            {
                var __ptr = (byte*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?variableWithFixedPrimitiveArray@@3QBEB");
                byte[] __value = null;
                if (__ptr != null)
                {
                    __value = new byte[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = __ptr[i];
                }
                return __value;
            }
        }

        public static uint* VariableWithVariablePrimitiveArray
        {
            get
            {
                var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CSharp.Native.dll", "?variableWithVariablePrimitiveArray@@3QBIB");
                return __ptr;
            }
        }
    }

    namespace Qt
    {
        public enum GlobalColor
        {
            Black = 0,
            White = 1
        }
    }

    namespace LowerCaseNameSpace
    {
        public enum Enum
        {
            Item1 = 0,
            Item2 = 1
        }
    }

    namespace NamespaceA
    {
        public unsafe partial struct A
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0A@NamespaceA@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private A.__Internal __instance;
            internal A.__Internal __Instance { get { return __instance; } }

            internal static global::CSharp.NamespaceA.A __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new A(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.NamespaceA.A __CreateInstance(global::CSharp.NamespaceA.A.__Internal native, bool skipVTables = false)
            {
                return new A(native, skipVTables);
            }

            private A(global::CSharp.NamespaceA.A.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private A(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::CSharp.NamespaceA.A.__Internal*) native;
            }

            public A(global::CSharp.NamespaceA.A _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor_1(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }
        }
    }

    namespace NamespaceB
    {
        public unsafe partial class B : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0B@NamespaceB@@QAE@ABV01@@Z")]
                internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?Function@B@NamespaceB@@QAEXAAVA@NamespaceA@@@Z")]
                internal static extern void Function_0(global::System.IntPtr instance, global::System.IntPtr a);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.NamespaceB.B> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.NamespaceB.B>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CSharp.NamespaceB.B __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new B(native.ToPointer(), skipVTables);
            }

            internal static global::CSharp.NamespaceB.B __CreateInstance(global::CSharp.NamespaceB.B.__Internal native, bool skipVTables = false)
            {
                return new B(native, skipVTables);
            }

            private static void* __CopyValue(global::CSharp.NamespaceB.B.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.NamespaceB.B.__Internal));
                *(global::CSharp.NamespaceB.B.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private B(global::CSharp.NamespaceB.B.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected B(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public B()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.NamespaceB.B.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public B(global::CSharp.NamespaceB.B _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.NamespaceB.B.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CSharp.NamespaceB.B.__Internal*) __Instance) = *((global::CSharp.NamespaceB.B.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                global::CSharp.NamespaceB.B __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Function(out global::CSharp.NamespaceA.A a)
            {
                a = new global::CSharp.NamespaceA.A();
                var ____arg0 = new global::CSharp.NamespaceA.A.__Internal();
                var __arg0 = new global::System.IntPtr(&____arg0);
                __Internal.Function_0((__Instance + __PointerAdjustment), __arg0);
                global::CSharp.NamespaceA.A __result0;
                if (__arg0 == IntPtr.Zero) __result0 = new global::CSharp.NamespaceA.A();
                else __result0 = global::CSharp.NamespaceA.A.__CreateInstance(__arg0);
                a = __result0;
            }
        }
    }

    namespace IndependentFields
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internal
        {
            [FieldOffset(0)]
            public int field;
        }
    }

    namespace DependentValueFields
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields__b
        {
            [FieldOffset(0)]
            public byte field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_T1
        {
            [FieldOffset(0)]
            public global::CSharp.T1.__Internal field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_T2
        {
            [FieldOffset(0)]
            public global::CSharp.T2.__Internal field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_IndependentFields__I
        {
            [FieldOffset(0)]
            internal global::CSharp.IndependentFields.__Internal field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_IndependentFields__b
        {
            [FieldOffset(0)]
            internal global::CSharp.IndependentFields.__Internal field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_DependentValueFields___I
        {
            [FieldOffset(0)]
            internal global::CSharp.DependentValueFields.__Internal_Ptr field;

            [FieldOffset(8)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internal_Ptr
        {
            [FieldOffset(0)]
            public global::System.IntPtr field;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public unsafe partial struct __Internalc__S_DependentValueFields____S_DependentValueFields___C
        {
            [FieldOffset(0)]
            internal global::CSharp.DependentValueFields.__Internal_Ptr field;

            [FieldOffset(8)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public unsafe partial struct __Internalc__S_DependentValueFields___
        {
            [FieldOffset(0)]
            public fixed sbyte field[3];

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields._.__Internal _;
        }


        public unsafe partial struct _
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }
        }
    }

    namespace DependentPointerFields
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr field;
        }
    }

    namespace HasDefaultTemplateArgument
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public unsafe partial struct __Internalc__S_HasDefaultTemplateArgument__I___S_IndependentFields__I
        {
            [FieldOffset(0)]
            public int field;
        }
    }

    public unsafe partial class T1 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0T1@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.T1> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.T1>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.T1 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new T1(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.T1 __CreateInstance(global::CSharp.T1.__Internal native, bool skipVTables = false)
        {
            return new T1(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.T1.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.T1.__Internal));
            *(global::CSharp.T1.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private T1(global::CSharp.T1.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected T1(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public T1()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.T1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public T1(global::CSharp.T1 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.T1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.T1.__Internal*) __Instance) = *((global::CSharp.T1.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.T1 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    public unsafe partial class T2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0T2@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.T2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.T2>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.T2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new T2(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.T2 __CreateInstance(global::CSharp.T2.__Internal native, bool skipVTables = false)
        {
            return new T2(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.T2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.T2.__Internal));
            *(global::CSharp.T2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private T2(global::CSharp.T2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected T2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public T2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.T2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public T2(global::CSharp.T2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.T2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.T2.__Internal*) __Instance) = *((global::CSharp.T2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.T2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    namespace TemplateSpecializer_NestedTemplate
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public unsafe partial struct __Internal
        {
        }
    }

    public unsafe partial class TemplateSpecializer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 92)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::CSharp.IndependentFields.__Internal independentFields;

            [FieldOffset(4)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields__b dependentValueFields;

            [FieldOffset(12)]
            internal global::CSharp.DependentPointerFields.__Internal dependentPointerFields;

            [FieldOffset(16)]
            internal global::CSharp.HasDefaultTemplateArgument.__Internalc__S_HasDefaultTemplateArgument__I___S_IndependentFields__I hasDefaultTemplateArgument;

            [FieldOffset(20)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_T1 dependentPointerFieldsT1;

            [FieldOffset(28)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_T2 dependentPointerFieldsT2;

            [FieldOffset(36)]
            internal global::CSharp.TemplateInAnotherUnit.__Internalc__S_TemplateInAnotherUnit__f templateInAnotherUnit;

            [FieldOffset(40)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_IndependentFields__I specializeWithSpecialization;

            [FieldOffset(48)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_IndependentFields__b specializeWithSameSpecialization;

            [FieldOffset(56)]
            internal global::CSharp.TemplateSpecializer_NestedTemplate.__Internal nestedTemplate;

            [FieldOffset(60)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_DependentValueFields___I nestedDependentPointer1;

            [FieldOffset(72)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields____S_DependentValueFields___C nestedDependentPointer2;

            [FieldOffset(84)]
            internal global::CSharp.DependentValueFields.__Internalc__S_DependentValueFields___ dependentFieldArray;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TemplateSpecializer@@QAE@XZ")]
            internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CSharp.Native.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                EntryPoint="??0TemplateSpecializer@@QAE@ABV0@@Z")]
            internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TemplateSpecializer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CSharp.TemplateSpecializer>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::CSharp.TemplateSpecializer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new TemplateSpecializer(native.ToPointer(), skipVTables);
        }

        internal static global::CSharp.TemplateSpecializer __CreateInstance(global::CSharp.TemplateSpecializer.__Internal native, bool skipVTables = false)
        {
            return new TemplateSpecializer(native, skipVTables);
        }

        private static void* __CopyValue(global::CSharp.TemplateSpecializer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::CSharp.TemplateSpecializer.__Internal));
            *(global::CSharp.TemplateSpecializer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TemplateSpecializer(global::CSharp.TemplateSpecializer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected TemplateSpecializer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public TemplateSpecializer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TemplateSpecializer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_0((__Instance + __PointerAdjustment));
        }

        public TemplateSpecializer(global::CSharp.TemplateSpecializer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::CSharp.TemplateSpecializer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::CSharp.TemplateSpecializer.__Internal*) __Instance) = *((global::CSharp.TemplateSpecializer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            global::CSharp.TemplateSpecializer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate int Func_int_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_int(global::System.IntPtr instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_IntPtr_IntPtr(global::System.IntPtr instance, global::System.IntPtr arg1, global::System.IntPtr arg2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_intPtr_sbytePtr_IntPtr_intPtr_intPtr(global::System.IntPtr instance, int* arg1, sbyte* arg2, global::System.IntPtr arg3, int* arg4, int* arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr instance, global::System.IntPtr arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate global::System.IntPtr Func_string_IntPtr_string(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate bool Func_bool_IntPtr_bool(global::System.IntPtr instance, sbyte arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.ThisCall)]
        internal unsafe delegate void Action_IntPtr_bool(global::System.IntPtr instance, sbyte arg1);
    }
}
